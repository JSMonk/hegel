{"version":3,"sources":["webpack:///../src/docs/docs/what-and-why.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-docs-docs-what-and-why-mdx-a33aae0f11e4fe88eab3.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/packages/docs/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"introduction\"\n    }}>{`Introduction`}</h1>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"what-is-hegel\"\n    }}>{`What is Hegel?`}</h2>\n    <p>{`Hegel is a static type checker for JavaScript. It means that it is not a new one language which compiles to JavaScript. No. it's only a tool which analyzes your code ahead of time and show you results of the analysis. Also it means that you don't need to learn a new language to use static strong type system - JavaScript is enough. But, additionaly, this tool provide a type syntax for your variable and function arguments, analysis of your types (even if you don't use type syntax), which gives you an ability to find bugs faster without actually running your program.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Example from real life üò≠\nclass DataBase {\n  reconnect() { /* ... reconnect logic */}\n  dropDatabase() {}\n}\nclass Fixture {\n  reconnect() { this.dropDatabase(); /* ... reconnect logic */}\n  dropDatabase() {}\n}\n\nfunction setupE2E(db) {\n  db.reconnect();\n}\n\n// And your teammate forgot to change something after debugging\nconst db = new Fixture();\ndebugger;\nsetupE2E(db);\n// Congratulations, you became a DropDatabase Engineer \n`}</code></pre>\n    <p>{`But if you have added only one thing in your code with Hegel, you would not have droped the DataBase.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// ...\nfunction setupE2E(db: DataBase) {\n// ...\n`}</code></pre>\n    <p>{`You can see result in `}<a parentName=\"p\" {...{\n        \"href\": \"/hegel/try#MYGwhgzhAEAiYBcwCFIFNoG8BQ1oCc1gB7AO1KIQAoBKLAtBAV31OgQAsBLCAbgHoAVNAB0YhiXKVoIYgHMuwaIP4BfbOtCQYAMS4APZoSy4JZCsGp1M7bhBEATfMQAO8JACN0tXgyNtOHgFhMREzKUsZeUVlNVMnV3cwLwg0Wix1dWwAMyZSSy4yaFTmFwBRACYyqgcPAC44RBR0a3iPEUJJCyteDWxsfn5oAEFSB2gAT2IWdjQwAFtEDGzifDliBHZiaGAOMFI5DAhiecZuA+gwbIQ0fGgHNA8mOQUD7EkITdroAF5oCgA7tA9IYWGkaL0Hk8XrdeoMRmNJtNoHsAG4YYYAeQAKtBbs47lw2FMZmgHFwEKtoFSifcWIhCmxiNloC5nAAraQkeYuLjgBCM7AlJjlKo1DwQ7BAA\"\n      }}>{`Hegel Playground`}</a>{` - you would be notified before the incedent.`}</p>\n    <h2 {...{\n      \"id\": \"why-hegel\"\n    }}>{`Why Hegel?`}</h2>\n    <p>{`First of all, lets explore the main goals of Hegel:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Minimalistic type syntax`}</li>\n      <li parentName=\"ul\">{`Strong type system`}</li>\n      <li parentName=\"ul\">{`Powerful type inference`}</li>\n    </ul>\n    <p>{`But, we need to answer at this question differently for different audience. So, choose list item which describe your experience:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#why-actually-do-we-need-static-analysis\"\n        }}>{`You have never worked with typed languages or type checkers`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#benefits-and-disadvantages-over-typescript\"\n        }}>{`You work with TypeScript`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#benefits-and-disadvantages-over-flowjs\"\n        }}>{`You work with Flow.js`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"why-actually-do-we-need-static-analysis\"\n    }}>{`Why actually do we need static analysis?`}</h2>\n    <p>{`First of all, static analysis means that your code will be analyzed without actually running. So, static type analysis will analyze your code for any type errors.`}</p>\n    <p>{`Actually, there are 2 major benefits of static type analysis:\n1. Static type analysis find and provide to you information about a type error which existed in your code during code writing. It not only gives you garantees that you code will work without runtime type errors but in addition it realy economs a lot of time for finding and fixing errors, especially in big projects which contains a realy long build step.\n2. When you use instrument which provide type information of your variables, functions, methods, classes and etc - you have got an documentation of method usage without any additional efforts.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function deserializeUser(stringifiedUserJson) {\n  const maybeUser = JSON.parse(stringifiedUserJson);\n  if (\n    typeof maybeUser === \"object\" &&\n    maybeUser !== null &&\n    \"name\" in maybeUser &&\n    typeof maybeUser.name === \"string\"\n  ) {\n    return maybeUser;\n  }\n  throw new TypeError(\"Provided serialized user is invalid!\");\n}\n\ndeserializeUser(\"42\");\n`}</code></pre>\n    <p>{`If you open this example in `}<a parentName=\"p\" {...{\n        \"href\": \"/hegel/try#GYVwdgxgLglg9mABAEwKYGdUCcYEMA2MAXqgKqZYAU6UOYA5jMDKsudgFLoICUiA3gChEiCAhqIAtrgCeAIzIVEAXkQcAygHkAcgDoADriyZqtGAyYs2FLrwDcwxE0SVHIqDP2o4wKbIXsWCrKqgBEcHIAVqjQoYgAZPFufvKK2IgAhCGIYCD4+AlJIiKhYLiSqHHmKQFKickeXj41aVi6ZRXBYTR09KGOfELFiFioUCBYSNKpgQ4iAL6OUAAWWHAA7jmomwAqnqgAolhrVKEACmsAbjBoyIgUeIQkdyBKMOhOYJcENxmhPA5FoI0A8fiRApRQgAWABM-zsQA\"\n      }}>{`Hegel Playground`}</a>{` and hover at `}<inlineCode parentName=\"p\">{`deserializeUser`}</inlineCode>{` function invocation, then you will see arguments types of the function, return type of the function and which error this funcation may throw. And you've got it free.`}</p>\n    <h2 {...{\n      \"id\": \"benefits-and-disadvantages-over-typescript\"\n    }}>{`Benefits and disadvantages over TypeScript`}</h2>\n    <p>{`If you familiar with TypeScript you may know benefits of static typing, so lets explore benefits and disadvantages of Hegel over TypeScript`}</p>\n    <h3 {...{\n      \"id\": \"benefits\"\n    }}>{`Benefits`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Ability to skip type annotation`}</li>\n    </ol>\n    <p>{`Hegel is targeting at really powerful type inference which gives an ability to write less type annotations. As example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"promisify\" function is \"<q', c'>((c') => q') => (c') => Promise<q'>\"\nconst promisify = fn => arg => Promise.resolve(fn(arg));\n\n// Type of \"id\" function is \"<c'>(c') => Promise<c'>\"\nconst id = promisify(x => x);\n\n// Type of \"result\" variable is \"Promise<number>\"\nconst result = id(42).then(x => x + x);\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in TypeScript (tested at version 3.7.5) will show 3 errors and inference `}<inlineCode parentName=\"p\">{`Promise<any>`}</inlineCode>{` type for \"result\" variable `}<a parentName=\"p\" {...{\n          \"href\": \"http://www.typescriptlang.org/play/index.html?ssl=1&ssc=1&pln=7&pc=1#code/PTAEBUE8AcFNQPYDNQCJoCcEFsCWBnXJSVUJAVwDsBjAF1wUtALQB4BHAcgBpRrOAfAAoh-AJSgAvANBcJ00KM7yZABSx58sDoNQAoao3y1QmHASKQpZJgoCGGAOZS1GgrAB0GWPgQAbADdYISRKIQdHMTEAbj09EAgYeGQ0XAATUgoaekZmfDZ+YXEXUHVzLVZC-UNKY2Y06zNNSyEADxLWmLiEqDhEFFRvfHI-WlIAh1w7ACM-eBZUMs1tSnJsadgMAWqjEyGRk0l6oQAWACYxD1oAC1gw9oV2gGpQTujQIA\"\n        }}>{`TypeScript Example`}</a>{`.`}</p>\n    </blockquote>\n    <ol {...{\n      \"start\": 2\n    }}>\n      <li parentName=\"ol\">{`No unexpected runtime errors`}</li>\n    </ol>\n    <p>{`One of the non-goals of TypeScript is: \"Apply a sound or \"provably correct\" type system. Instead, strike a balance between correctness and productivity.\". It means that TypeScript never will guarantee that you will not have a Type Error at Runtime. Hegel is at opposite side. We try to implement strong type system which will guarantee that your program is valid.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const doubles: Array<number> = [Math.PI, Math.E];\n// Error: Type \"Array<number>\" is incompatible with type \"Array<number | string>\"\nconst numbersToShow: Array<number | string> = doubles;\nnumbersToShow.push(42..toString(2));\ndoubles.map(double => double.toFixed());\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in TypeScript (tested at version 3.7.5) will be valid, but uncaught type error will be thrown at runtime `}<a parentName=\"p\" {...{\n          \"href\": \"http://www.typescriptlang.org/play/index.html?ssl=4&ssc=11&pln=4&pc=4#code/MYewdgzgLgBAJiArgIwDYFMIC4YEEBO+AhgJ4A8YiAtsuvgHwwC8MA2gLJFQAWAdAAoBJADQxOPXgFEAugG4AUKEixKNOhAAqIAMrcQAdxwFi5VbXwwAPjGj4AlmADmjFghQYICs+q26DvAAdECG4ACgAWACZeXigdKHsnUMiAShSFAHoMmABVMGAiREduWA0SAPRJQhB8HDc0dFiQADE7AA90OBg7CBgwEFgiGAAzRHyoO3B5eo9eKiIA0Jn0ZkZlptaOuFC02SA\"\n        }}>{`TypeScript Example`}</a>{`.`}</p>\n    </blockquote>\n    <ol {...{\n      \"start\": 3\n    }}>\n      <li parentName=\"ol\">{`Typed Errors`}</li>\n    </ol>\n    <p>{`Hegel implements inference and annotation for functions which gives ability to understand which error type is inside catch block and which errors will be, by a function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"assertIsTrue\" function is \"(boolean) => undefined throws TypeError\"\nfunction assertIsTrue(arg) {\n    if (!arg) {\n        throw new TypeError(\"arg is invalid\")\n    }\n}\n\ntry {\n    assertIsTrue(false);\n} catch (e) {\n    // Type of \"e\" variable is \"TypeError | unknown\"\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in TypeScript (tested at version 3.7.5) will inference e as \"any\" type `}<a parentName=\"p\" {...{\n          \"href\": \"http://www.typescriptlang.org/play/index.html#code/GYVwdgxgLglg9mABAQwM6oKYCcoElUAqWIGAFMlgOYCUiA3gFCLOIzCKkCEFN9TLAqAAsscAO6IwGCQQCeABwwBRLKKykARD1apWYAG7IANjAAmG6v2YBfBrYZQssvgLSYc+IiVLBjmagDcdogQyFAQQhwYtIwCAPRxiHKKiHDsGhgaiIZYMMgARkYYOohaYLIadkA\"\n        }}>{`TypeScript Example`}</a>{`.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"disadvantages\"\n    }}>{`Disadvantages`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Minimal changes in JavaScript Syntax`}</li>\n    </ol>\n    <p>{`TypeScript provides a lot of additional syntax features and syntax sugar with types, but Hegel does not. Hegel is only a JavaScript with types. Lets see the example implemented in TypeScript and Hegel.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// TypeScript\nconst Entities = {\n    Plant: class Plant { },\n    Animal: class Animal { },\n    Mushrooms: class Mushrooms { }\n};\n\nfunction model<M extends object, K extends keyof M>(store: M, modelName: K): M[K] {\n    return store[modelName];\n}\n\nconst Class = model(Entities, \"Plant\");\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Hegel\nconst Entities = {\n    Plant: class Plant { },\n    Animal: class Animal { },\n    Mushrooms: class Mushrooms { }\n};\n\nfunction model<M: Object, K: $Keys<M>>(store: M, modelName: K): $PropertyType<M, K> {\n    return store[modelName];\n}\n\nconst Class = model(Entities, \"Plant\");\n`}</code></pre>\n    <ol {...{\n      \"start\": 2\n    }}>\n      <li parentName=\"ol\">{`No type coercion and \"any\" type`}</li>\n    </ol>\n    <p>{`As result of attempt to implement soundness type system Hegel doesn't have a type coercion and \"any\" type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Error: There is no \"any\" type in Hegel.\nconst something: any = null;\n\n// Error: Type cast is not existed in Hegel\n(null: any).call();\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"benefits-and-disadvantages-over-flowjs\"\n    }}>{`Benefits and disadvantages over Flow.js`}</h2>\n    <p>{`If you familiar with Flow.js you may know benefits of static typing, so lets explore benefits and disadvantages of Hegel over Flow.js`}</p>\n    <h3 {...{\n      \"id\": \"benefits-1\"\n    }}>{`Benefits`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Better type inference`}</li>\n    </ol>\n    <p>{`As example Flow.js docs says: \"Flow does not infer generic types. If you want something to have a generic type, annotate it. Otherwise, Flow may infer a type that is less polymorphic than you expect.\". It's because Flow.js inference function type by function usage. Hegel inferences function type by function declaration and as result Hegel inferences polymorphic type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"id\" function is \"<a'>(a') => a'\"\nconst id = x => x;\n// Type of \"num\" variable is \"number\"\nlet num = id(4);\n// Type of \"str\" variable is \"string\"\nlet str = id(\"4\");\n// Type of \"anotherId\" variable is \"<a'>(a') => a'\"\nlet anotherId = id(id);\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in Flow.js (tested at version 0.119.0) will inference every variable type as union of all applied types `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVxhgCoE8AOApmHFGAEQCWAJuWFAK4B2AxgC6VxNiUDOFACiYMAtgCNCAJzAAfMLzaTKTAOaywAgQA8AXGABqAEgCMASjABeAHwHDAJlPnrG4eKnqFS1es27bZyxsjB3JUFi4FHmpLMC1A2IBuDCw8IhIyclc6ADcAQyVcsRhiPgpXCWk5T2U1OV89IwDnYNNQ4rYwVxiaAQAWUyTMHAJiUgpPHPzKQuKefkzRCo9FGp9tBpMnIPtW1Hb5RW7qAXJe8gHk4bSx8lymODYACykASVowPIKikvny9yqVt46ut-FtbCE9oQOncHs9JG8jgIaAMgA\"\n        }}>{`Flow.js Example`}</a>{`.`}</p>\n    </blockquote>\n    <ol {...{\n      \"start\": 2\n    }}>\n      <li parentName=\"ol\">{`Typed Errors`}</li>\n    </ol>\n    <p>{`Hegel implements inference and annotation for functions which gives ability to understand which error type is inside catch block and which errors will be, by a function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"assertIsTrue\" function is \"(boolean) => undefined throws TypeError\"\nfunction assertIsTrue(arg) {\n    if (!arg) {\n        throw new TypeError(\"arg is invalid\")\n    }\n}\n\ntry {\n    assertIsTrue(false);\n} catch (e) {\n    // Type of \"e\" variable is \"TypeError | unknown\"\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in Flow.js (tested at version 0.119.0) will inference e as \"empty\" type `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVUCuA7AxgFwEs5swBDAZwoFMAnfASQoBVbNqAKM2gcwEowAb1RhRYQlDAcAhN35CRYpfgAWtRGGzUkzAJ4AHagFFa62hwBEc8RXHYAbmRiEAJhb6LRAX1Q-U+Wl0FJUoaeiZWdg4oJxo+AG5fMFwyfFwVKWoBYSVgYDA9QzA4SQtqCzBHWkIyACMYahswMoBbfXxdC19UIA\"\n        }}>{`Flow.js Example`}</a>{`.`}</p>\n    </blockquote>\n    <ol {...{\n      \"start\": 3\n    }}>\n      <li parentName=\"ol\">{`No custom library definition language`}</li>\n    </ol>\n    <p>{`Flow.js has custom library definition languages and doesn't support the most popular TypeScript \"d.ts\" format. But for Hegel TypeScript \"d.ts\" it the only way to create type definition for library. So, every library which has TypeScript defintions should work with Hegel. // \"should work with Hegel\", —ç—Ç–æ —Ç—ã –∏–º–µ–ª –≤–≤–∏–¥—É —Å–ª–µ–¥—É–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å? –Ø –±—ã –ª—É—á—à–µ –Ω–∞–ø–∏—Å–∞—Ç—å –∫–∞–∫ \"–±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å\" - \"will work with Hegel\"`}</p>\n    <ol {...{\n      \"start\": 4\n    }}>\n      <li parentName=\"ol\">{`No OCaml in source code`}</li>\n    </ol>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://ocaml.org/\"\n      }}>{`OCaml`}</a>{` is realy great language and this language inspired us to implement the same type inference in Hegel, but the problem is that it's not common language (especially for developer who works with JavaScript stack) and as result it's hard for JavaScript community to contribute into the Flow.js.\nWe decided to implement Hegel in JavaScript.`}</p>\n    <h3 {...{\n      \"id\": \"disadvantages-1\"\n    }}>{`Disadvantages`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`No type coercion and \"any\" type`}</li>\n    </ol>\n    <p>{`As result of atempt to implement soundness type system Hegel doesn't have a type coercion and \"any\" type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Error: There is no \"any\" type in Hegel.\nconst something: any = null;\n\n// Error: Type cast is not existed in Hegel\n(null: any).call();\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}