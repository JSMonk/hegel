{"version":3,"sources":["webpack:///../src/docs/docs/what-and-why.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-docs-docs-what-and-why-mdx-cb905665aac5cddb3d7b.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"introduction\"\n    }}>{`Introduction`}</h1>\n    <hr></hr>\n    <h2 {...{\n      \"id\": \"what-is-hegel\"\n    }}>{`What is Hegel?`}</h2>\n    <p>{`Hegel is a static type checker for JavaScript. It means that it is not a new language which compiles to JavaScript. No, it's only a tool which analyzes your code ahead of time and shows you results of the analysis. Also, it means that you don't need to learn a new language to use a static strong type system - JavaScript is enough. But, additionally, this tool provides a type syntax for your variables and function arguments, analysis of your types (even if you don't use type syntax), which gives you an ability to find bugs faster without actually running your program.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Example from real life ðŸ˜­\nclass DataBase {\n  reconnect() {\n    /* ... reconnect logic */\n  }\n  dropDatabase() {}\n}\nclass Fixture {\n  reconnect() {\n    this.dropDatabase(); /* ... reconnect logic */\n  }\n  dropDatabase() {}\n}\n\nfunction setupE2E(db) {\n  db.reconnect();\n}\n\n// And your teammate forgot to change something after debugging\nconst db = new Fixture();\ndebugger;\nsetupE2E(db);\n// Congratulations, you became a DropDatabase Engineer\n`}</code></pre>\n    <p>{`But if you have added only one thing in your code with Hegel, you would not have dropped the DataBase.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// ...\nfunction setupE2E(db: DataBase) {\n// ...\n`}</code></pre>\n    <p>{`You can see the result in the `}<a parentName=\"p\" {...{\n        \"href\": \"/try#MYGwhgzhAEAiYBcwCFIFNoG8BQ1oCc1gB7AO1KIQAoBKLAtBAV31OgQAsBLCAbgHoAVNAB0YhiXKVoIYgHMuwaIP4BfbOtCQYAMS4APZoSy4JZCsGp1M7bhBEATfMQAO8JACN0tXgyNtOHgFhMREzKUsZeUVlNVMnV3cwLwg0Wix1dWwAMyZSSy4yaFTmFwBRACYyqgcPAC44RBR0a3iPEUJJCyteDWxsfn5oAEFSB2gAT2IWdjQwAFtEDGzifDliBHZiaGAOMFI5DAhiecZuA+gwbIQ0fGgHNA8mOQUD7EkITdroAF5oCgA7tA9IYWGkaL0Hk8XrdeoMRmNJtNoHsAG4YYYAeQAKtBbs47lw2FMZmgHFwEKtoFSifcWIhCmxiNloC5nAAraQkeYuLjgBCM7AlJjlKo1DwQ7BAA\"\n      }}>{`Hegel Playground`}</a>{` - you would be notified before the incident.`}</p>\n    <h2 {...{\n      \"id\": \"why-hegel\"\n    }}>{`Why Hegel?`}</h2>\n    <p>{`First of all, let's explore the main goals of Hegel:`}</p>\n    <ul>\n      <li parentName=\"ul\">{`Minimalistic type syntax`}</li>\n      <li parentName=\"ul\">{`Strong type system`}</li>\n      <li parentName=\"ul\">{`Powerful type inference`}</li>\n    </ul>\n    <p>{`But we need to answer this question differently for different audiences. So, choose the list item which describes your experience:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#why-actually-do-we-need-static-analysis\"\n        }}>{`You have never worked with typed languages or type checkers`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#benefits-and-disadvantages-over-typescript\"\n        }}>{`You work with TypeScript`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#benefits-and-disadvantages-over-flowjs\"\n        }}>{`You work with Flow.js`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"why-actually-do-we-need-static-analysis\"\n    }}>{`Why actually do we need static analysis?`}</h2>\n    <p>{`First of all, static analysis means that your code will be analyzed without actually running. So, static type analysis will analyze your code for any type of errors.`}</p>\n    <p>{`Actually, there are 2 major benefits of static type analysis:`}</p>\n    <ol>\n      <li parentName=\"ol\">{`Static type analysis finds and provides to you information about a type error that exists in your code during code writing. It not only gives you guarantees that your code will work without runtime type errors but in addition, it really saves a lot of time for finding and fixing errors, especially in big projects that contain a really long build step.`}</li>\n      <li parentName=\"ol\">{`When you use an instrument that provides type information of your variables, functions, methods, classes and etc - you have got a documentation of method usage without any additional effort.`}</li>\n    </ol>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function deserializeUser(stringifiedUserJson) {\n  const maybeUser = JSON.parse(stringifiedUserJson);\n  if (\n    typeof maybeUser === \"object\" &&\n    maybeUser !== null &&\n    \"name\" in maybeUser &&\n    typeof maybeUser.name === \"string\"\n  ) {\n    return maybeUser;\n  }\n  throw new TypeError(\"Provided serialized user is invalid!\");\n}\n\nconst user = deserializeUser(\"42\");\n`}</code></pre>\n    <p>{`If you open this example in `}<a parentName=\"p\" {...{\n        \"href\": \"/try#GYVwdgxgLglg9mABAEwKYGdUCcYEMA2MAXqgKqZYAU6UOYA5jMDKsudgFLoICUiA3gChEiCAhqIAtrgCeAIzIVEAXkQcAygHkAcgDoADriyZqtGAyYs2FLrwDcwxE0SVHIqDP2o4wKbIXsWCrKqgBEcHIAVqjQoYgAZPFufvKK2IgAhCGIYCD4+AlJIiKhYLiSqHHmKQFKickeXj41aVi6ZRXBYTR09KGOfELFiFioUCBYSNKpgQ4iAL6OUAAWWHAA7jmomwAqnqgAolhrVKEACmsAbjBoyIgUeIQkdyBKMOhOYJcENxmhPA5FoI0A8fiRApRQgAWABM-zsQA\"\n      }}>{`Hegel Playground`}</a>{` and hover at `}<inlineCode parentName=\"p\">{`deserializeUser`}</inlineCode>{` function invocation, then you will see the argument types of the function, return type of the function and which error this function may throw. And you've got it free.`}</p>\n    <h2 {...{\n      \"id\": \"benefits-and-disadvantages-over-typescript\"\n    }}>{`Benefits and disadvantages over TypeScript`}</h2>\n    <p>{`If you familiar with TypeScript you may know the benefits of static typing, so let's explore benefits and disadvantages of Hegel over TypeScript`}</p>\n    <h3 {...{\n      \"id\": \"benefits\"\n    }}>{`Benefits`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Ability to skip type annotation`}</li>\n    </ol>\n    <p>{`Hegel is targeting at really powerful type inference which gives an ability to write fewer type annotations. For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"promisify\" function is \"<_q, _c>((_c) => _q) => (_c) => Promise<_q>\"\nconst promisify = (fn) => (arg) => Promise.resolve(fn(arg));\n\n// Type of \"id\" function is \"<_c>(_c) => Promise<_c>\"\nconst id = promisify((x) => x);\n\n// Type of \"result\" variable is \"Promise<number>\"\nconst result = id(42).then((x) => x + x);\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in TypeScript (tested at version 3.7.5) will show 3 errors and infer `}<inlineCode parentName=\"p\">{`Promise<any>`}</inlineCode>{` type for the \"result\" variable `}<a parentName=\"p\" {...{\n          \"href\": \"http://www.typescriptlang.org/play/index.html?ssl=1&ssc=1&pln=7&pc=1#code/PTAEBUE8AcFNQPYDNQCJoCcEFsCWBnXJSVUJAVwDsBjAF1wUtALQB4BHAcgBpRrOAfAAoh-AJSgAvANBcJ00KM7yZABSx58sDoNQAoao3y1QmHASKQpZJgoCGGAOZS1GgrAB0GWPgQAbADdYISRKIQdHMTEAbj09EAgYeGQ0XAATUgoaekZmfDZ+YXEXUHVzLVZC-UNKY2Y06zNNSyEADxLWmLiEqDhEFFRvfHI-WlIAh1w7ACM-eBZUMs1tSnJsadgMAWqjEyGRk0l6oQAWACYxD1oAC1gw9oV2gGpQTujQIA\"\n        }}>{`TypeScript Example`}</a>{`.`}</p>\n    </blockquote>\n    <ol {...{\n      \"start\": 2\n    }}>\n      <li parentName=\"ol\">{`No unexpected runtime errors`}</li>\n    </ol>\n    <p>{`One of the non-goals of TypeScript is: \"Apply a sound or \"provably correct\" type system. Instead, strike a balance between correctness and productivity.\". It means that TypeScript never will guarantee that you will not have a Type Error at Runtime. Hegel is on the opposite side. We try to implement a strong type system which will guarantee that your program is valid.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const doubles: Array<number> = [Math.PI, Math.E];\n\n// Error: Type \"Array<number>\" is incompatible with type \"Array<number | string>\"\nconst numbersToShow: Array<number | string> = doubles;\nnumbersToShow.push((42).toString(2));\nconst rounded = doubles.map((double) => double.toFixed());\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in TypeScript (tested at version 3.7.5) will be valid, but an uncaught type error will be thrown at runtime `}<a parentName=\"p\" {...{\n          \"href\": \"http://www.typescriptlang.org/play/index.html?ssl=4&ssc=11&pln=4&pc=4#code/MYewdgzgLgBAJiArgIwDYFMIC4YEEBO+AhgJ4A8YiAtsuvgHwwC8MA2gLJFQAWAdAAoBJADQxOPXgFEAugG4AUKEixKNOhAAqIAMrcQAdxwFi5VbXwwAPjGj4AlmADmjFghQYICs+q26DvAAdECG4ACgAWACZeXigdKHsnUMiAShSFAHoMmABVMGAiREduWA0SAPRJQhB8HDc0dFiQADE7AA90OBg7CBgwEFgiGAAzRHyoO3B5eo9eKiIA0Jn0ZkZlptaOuFC02SA\"\n        }}>{`TypeScript Example`}</a>{`.`}</p>\n    </blockquote>\n    <ol {...{\n      \"start\": 3\n    }}>\n      <li parentName=\"ol\">{`Typed Errors`}</li>\n    </ol>\n    <p>{`Hegel implements inference and annotation for functions which gives an ability to understand which error type is inside the catch block and which errors will be thrown by a function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"assertIsTrue\" function is \"(boolean) => undefined throws TypeError\"\nfunction assertIsTrue(arg) {\n  if (!arg) {\n    throw new TypeError(\"arg is invalid\");\n  }\n}\n\ntry {\n  assertIsTrue(false);\n\n  // Type of \"e\" variable is \"TypeError | unknown\"\n} catch (e) {}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in TypeScript (tested at version 3.7.5) will inference e as \"any\" type `}<a parentName=\"p\" {...{\n          \"href\": \"http://www.typescriptlang.org/play/index.html#code/GYVwdgxgLglg9mABAQwM6oKYCcoElUAqWIGAFMlgOYCUiA3gFCLOIzCKkCEFN9TLAqAAsscAO6IwGCQQCeABwwBRLKKykARD1apWYAG7IANjAAmG6v2YBfBrYZQssvgLSYc+IiVLBjmagDcdogQyFAQQhwYtIwCAPRxiHKKiHDsGhgaiIZYMMgARkYYOohaYLIadkA\"\n        }}>{`TypeScript Example`}</a>{`.`}</p>\n    </blockquote>\n    <h3 {...{\n      \"id\": \"disadvantages\"\n    }}>{`Disadvantages`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Minimal changes in JavaScript syntax`}</li>\n    </ol>\n    <p>{`TypeScript provides a lot of additional syntax features and syntax sugar with types, but Hegel does not. Hegel is only a JavaScript with types. Let's see the example implemented in TypeScript and Hegel.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// TypeScript\nenum UserStatus {\n  Active,\n  Muted,\n  Banned,\n}\n\nclass User {\n  constructor(public name: string, public status: UserStatus) {}\n}\n\nconst Anatoly = new User(\"Anatoly\", UserStatus.Active);\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Hegel\nconst UserStatus = Object.freeze({\n  Active: \"Active\",\n  Muted: \"Muted\",\n  Banned: \"Banned\",\n});\n\nclass User {\n  name: string;\n  status: $Values<$TypeOf<UserStatus>>;\n\n  constructor(name, status) {\n    this.name = name;\n    this.status = status;\n  }\n}\n\nconst Anatoly = new User(\"Anatoly\", UserStatus.Active);\n`}</code></pre>\n    <ol {...{\n      \"start\": 2\n    }}>\n      <li parentName=\"ol\">{`No type coercion and \"any\" type`}</li>\n    </ol>\n    <p>{`As result of attempting to implement a sound type system Hegel doesn't have type coercion and \"any\" type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Error: There is no \"any\" type in Hegel.\nconst something: any = null;\n\n// Error: Type cast does not exist in Hegel\n(null: any).call();\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"benefits-and-disadvantages-over-flowjs\"\n    }}>{`Benefits and disadvantages over Flow.js`}</h2>\n    <p>{`If you are familiar with Flow.js you may know the benefits of static typing, so let's explore benefits and disadvantages of Hegel over Flow.js`}</p>\n    <h3 {...{\n      \"id\": \"benefits-1\"\n    }}>{`Benefits`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`Better type inference`}</li>\n    </ol>\n    <p>{`As example Flow.js docs says: \"Flow does not infer generic types. If you want something to have a generic type, annotate it. Otherwise, Flow may infer a type that is less polymorphic than you expect.\". It's because Flow.js infers function types by function usage. Hegel infers function types by function declarations and as result Hegel infers polymorphic types.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"id\" function is \"<_a>(_a) => _a\"\nconst id = (x) => x;\n// Type of \"num\" variable is \"number\"\nlet num = id(4);\n// Type of \"str\" variable is \"string\"\nlet str = id(\"4\");\n// Type of \"anotherId\" variable is \"<_a>(_a) => _a\"\nlet anotherId = id(id);\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in Flow.js (tested at version 0.119.0) will infer every variable type as union of all applied types `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVxhgCoE8AOApmHFGAEQCWAJuWFAK4B2AxgC6VxNiUDOFACiYMAtgCNCAJzAAfMLzaTKTAOaywAgQA8AXGABqAEgCMASjABeAHwHDAJlPnrG4eKnqFS1es27bZyxsjB3JUFi4FHmpLMC1A2IBuDCw8IhIyclc6ADcAQyVcsRhiPgpXCWk5T2U1OV89IwDnYNNQ4rYwVxiaAQAWUyTMHAJiUgpPHPzKQuKefkzRCo9FGp9tBpMnIPtW1Hb5RW7qAXJe8gHk4bSx8lymODYACykASVowPIKikvny9yqVt46ut-FtbCE9oQOncHs9JG8jgIaAMgA\"\n        }}>{`Flow.js Example`}</a>{`.`}</p>\n    </blockquote>\n    <ol {...{\n      \"start\": 2\n    }}>\n      <li parentName=\"ol\">{`Typed Errors`}</li>\n    </ol>\n    <p>{`Hegel implements inference and annotation for functions which gives an ability to understand which error type is inside catch block and which errors will be thrown by a function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"assertIsTrue\" function is \"(boolean) => undefined throws TypeError\"\nfunction assertIsTrue(arg) {\n  if (!arg) {\n    throw new TypeError(\"arg is invalid\");\n  }\n}\n\ntry {\n  assertIsTrue(false);\n} catch (e) {\n  // Type of \"e\" variable is \"TypeError | unknown\"\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The same example in Flow.js (tested at version 0.119.0) will infer e as \"empty\" type `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVUCuA7AxgFwEs5swBDAZwoFMAnfASQoBVbNqAKM2gcwEowAb1RhRYQlDAcAhN35CRYpfgAWtRGGzUkzAJ4AHagFFa62hwBEc8RXHYAbmRiEAJhb6LRAX1Q-U+Wl0FJUoaeiZWdg4oJxo+AG5fMFwyfFwVKWoBYSVgYDA9QzA4SQtqCzBHWkIyACMYahswMoBbfXxdC19UIA\"\n        }}>{`Flow.js Example`}</a>{`.`}</p>\n    </blockquote>\n    <ol {...{\n      \"start\": 3\n    }}>\n      <li parentName=\"ol\">{`No custom library definition language`}</li>\n    </ol>\n    <p>{`Flow.js has a custom library definition language and doesn't support the most popular TypeScript \"d.ts\" format. But for Hegel, the TypeScript \"d.ts\" it is the only way to create the type definition for a library. So, every library which has TypeScript definitions should work with Hegel.`}</p>\n    <ol {...{\n      \"start\": 4\n    }}>\n      <li parentName=\"ol\">{`No OCaml in source code`}</li>\n    </ol>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"https://ocaml.org/\"\n      }}>{`OCaml`}</a>{` is really great language and this language inspired us to implement the same type inference in Hegel, but the problem is that it's not common language (especially for developers who work with a JavaScript stack) and as result it's hard for the JavaScript community to contribute to Flow.js.\nWe decided to implement Hegel in JavaScript.`}</p>\n    <h3 {...{\n      \"id\": \"disadvantages-1\"\n    }}>{`Disadvantages`}</h3>\n    <ol>\n      <li parentName=\"ol\">{`No type coercion and \"any\" type`}</li>\n    </ol>\n    <p>{`As a result of attempting to implement a sound type system Hegel doesn't have type coercion and the \"any\" type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Error: There is no \"any\" type in Hegel.\nconst something: any = null;\n\n// Error: Type cast does not exist in Hegel\n(null: any).call();\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}