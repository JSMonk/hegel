{"version":3,"sources":["webpack:///../src/docs/docs/generic-types.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ocAMO,IAAMA,EAAe,Q,iNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,iBADR,iBAGA,uBACA,uHAAsG,0BAAYC,WAAW,KAAvB,YAAtG,cACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qDAML,8JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,4ZAuBL,iEAAgD,0BAAYA,WAAW,KAAvB,YAAhD,sIAA2O,mBAAGA,WAAW,KAAQ,CAC7P,KAAQ,uBAD+N,gBAA3O,qDAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,oPAeL,uDACA,4MACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,wYAmBL,6HACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qXAmBL,yGACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,8kBAmBL,iBAAQ,CACN,GAAM,kBADR,kBAGA,yLAEA,iBAAQ,CACN,GAAM,aADR,aAGA,mIAAkH,0BAAYA,WAAW,KAAvB,KAAlH,IAAoK,0BAAYA,WAAW,KAAvB,KAApK,kCAAoP,0BAAYA,WAAW,KAAvB,KAApP,kCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,iyBAuBL,iBAAQ,CACN,GAAM,iBADR,iBAGA,4GACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,sNAUL,iBAAQ,CACN,GAAM,WADR,WAGA,4HAA2G,0BAAYA,WAAW,KAAvB,KAA3G,IAA6J,0BAAYA,WAAW,KAAvB,KAA7J,kCAA6O,0BAAYA,WAAW,KAAvB,KAA7O,mCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,sWAoBL,iBAAQ,CACN,GAAM,cADR,cAGA,qIAAoH,0BAAYA,WAAW,KAAvB,KAApH,IAAsK,0BAAYA,WAAW,KAAvB,KAAtK,kCAAsP,0BAAYA,WAAW,KAAvB,KAAtP,yCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,4FAML,iBAAQ,CACN,GAAM,iBADR,iBAGA,4HACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,wSAeL,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kOASL,oLACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6QAYL,0CAAyB,mBAAGA,WAAW,KAAQ,CAC3C,KAAQ,uBADa,gBAAzB,uJAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mJAQL,iBAAQ,CACN,GAAM,eADR,eAGA,wLAAuK,0BAAYA,WAAW,KAAvB,KAAvK,aACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6dAgBL,2DACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,8WAiBL,iBAAQ,CACN,GAAM,gBADR,gBAGA,+GACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2J,+MAWTJ,EAAWK,gBAAiB","file":"component---src-docs-docs-generic-types-mdx-e396221886449d0ba54b.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"generic-types\"\n    }}>{`Generic Types`}</h1>\n    <hr></hr>\n    <p>{`Sometimes you can have different types for the same logic. The easiest example of this case is `}<inlineCode parentName=\"p\">{`identity`}</inlineCode>{` function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function identity(value) {\n  return value;\n}\n`}</code></pre>\n    <p>{`If you try to annotate only types with which you currently use this function you will have multiple declaration of the same function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function identityString(value: string): string {\n  return value;\n}\n\nfunction identityNumber(value: number): number {\n  return value;\n}\n\nfunction identityBoolean(value: boolean): boolean {\n  return value;\n}\n\n// Type of num is \"number\"\nlet num = identityNumber(2);\n\n// Type of str is \"string\"\nlet str = identityString(\"2\");\n\n// Type of bool is \"boolean\"\nlet bool = identityBoolean(false);\n`}</code></pre>\n    <p>{`As you can see, you need to redefine the `}<inlineCode parentName=\"p\">{`identity`}</inlineCode>{` function only for type safety. These functions do not add new business value to your code. You can try to solve this problem with `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/unknown-type\"\n      }}>{`Unknown Type`}</a>{`, but you will lose the type of the return value.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function identity(value: unknown): unknown {\n  return value;\n}\n\n// Type of num is \"unknown\"\nlet num = identity(2);\n\n// Type of str is \"unknown\"\nlet str = identity(\"2\");\n\n// Type of bool is \"unknown\"\nlet bool = identity(false);\n`}</code></pre>\n    <p>{`And then Generic Types appear.`}</p>\n    <p>{`Generic Types are the way to create something like a \"type function\". You can define \"type arguments\" which can be applied to this \"type function\" and a new type will be returned.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// \"T\" is type variable\nfunction identity<T>(value: T): T {\n  return value;\n}\n\n// T will be replaced by \"number\".\n// Type of num is \"number\"\nlet num = identity<number>(2);\n\n// T will be replaced by \"string\".\n// Type of str is \"string\"\nlet str = identity<string>(\"2\");\n\n// T will be replaced by \"boolean\".\n// Type of bool is \"boolean\"\nlet bool = identity<boolean>(false);\n`}</code></pre>\n    <p>{`And also, you can drop this \"type application\", because Hegel will infer which type you want to use.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// \"T\" is type variable\nfunction identity<T>(value: T): T {\n  return value;\n}\n\n// T will be replaced by type of 2.\n// Type of num is \"number\"\nlet num = identity(2);\n\n// T will be replaced by type of \"2\"\n// Type of str is \"string\"\nlet str = identity(\"2\");\n\n// T will be replaced by type of false\n// Type of bool is \"boolean\"\nlet bool = identity(false);\n`}</code></pre>\n    <p>{`Generics can be used within functions, function types, classes and type aliases.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type Response<Body> = { status: 200, body: Body };\n\nfunction respondWith<Body>(body: Body): Response<Body> {\n  return { status: 200, body };\n}\n\n// Type of response1 is \"Response<{ message: 'Good response' }>\"\n// is the same as \"{ status: 200, body: { message: \"Good response \" } }\"\nconst response1 = respondWith({ message: \"Good response\" });\n\n// Type of response2 is \"Response<[1, 2, 3]>\"\n// is the same as \"{ status: 200, body: [1, 2, 3] }\"\nconst response2 = respondWith([1, 2, 3]);\n\n// Type of bodyOfResponse2 is [1, 2, 3]\"\nconst bodyOfResponse2 = response2.body;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"generic-syntax\"\n    }}>{`Generic Syntax`}</h2>\n    <p>{`As was mentioned before, generics can be used within functions, function types, classes and type aliases.\nSo, there are different syntaxes in different places.`}</p>\n    <h3 {...{\n      \"id\": \"functions\"\n    }}>{`Functions`}</h3>\n    <p>{`To define generic parameters for a function you need to add a sequence of needed type variables wrapped in `}<inlineCode parentName=\"p\">{`<`}</inlineCode>{` `}<inlineCode parentName=\"p\">{`>`}</inlineCode>{` (angle brackets) separated by `}<inlineCode parentName=\"p\">{`,`}</inlineCode>{` (comma) before arguments list`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Function Declaration Generic Syntax\nfunction getResponseBodyAndStatus<Status, Body>(response: { status: Status, body: Body }): [Status, Body] {\n  return [response.status, response.body];\n}\n\n// Function Expression Generic Syntax\nconst getResponseBodyAndStatus = function<Status, Body>(response: { status: Status, body: Body }): [Status, Body] {\n  return [response.status, response.body];\n}\n\n// Arrow Function Expression Generic Syntax\nconst getResponseBodyAndStatus = <Status, Body>(response: { status: Status, body: Body }): [Status, Body] =>\n  [response.status, response.body];\n\nconst obj = {\n  // Method Generic Syntax\n  getResponseBodyAndStatus<Status, Body>(response: { status: Status, body: Body }): [Status, Body] {\n    return [response.status, response.body];\n  }\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"function-type\"\n    }}>{`Function Type`}</h3>\n    <p>{`Function type has the same syntax as for \"Arrow Function Expression\" with generic: `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Function Type Generic Syntax\nconst getResponseBodyAndStatus: <Status, Body>({\n  status: Status,\n  body: Body\n}) => [Status, Body] = function(response) {\n  return [response.status, response.body];\n};\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"classes\"\n    }}>{`Classes`}</h3>\n    <p>{`To define generic parameters for class you need to add sequence of needed type variables wrapped in `}<inlineCode parentName=\"p\">{`<`}</inlineCode>{` `}<inlineCode parentName=\"p\">{`>`}</inlineCode>{` (angle brackets) separated by `}<inlineCode parentName=\"p\">{`,`}</inlineCode>{` (comma) after class identifier`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class Container<T> {\n  value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n}\n\nlet value = 2;\n\n// Explicit type application\n// container1 type is Container<number>\nconst container1 = new Container<number>(value);\n\n// Implicit type application\n// container2 type is Container<number>\nconst container2 = new Container(value);\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"type-alias\"\n    }}>{`Type Alias`}</h3>\n    <p>{`To define generic parameters for type aliases you need to add a sequence of needed type variables wrapped in `}<inlineCode parentName=\"p\">{`<`}</inlineCode>{` `}<inlineCode parentName=\"p\">{`>`}</inlineCode>{` (angle brackets) separated by `}<inlineCode parentName=\"p\">{`,`}</inlineCode>{` (comma) after type alias identifier.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type Container<T> = { value: T }\n\nconst container: Container<number> = { value: 2 }\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"type-checking\"\n    }}>{`Type Checking`}</h2>\n    <p>{`First of all, if you defined some type as generic you can't use this type without type application.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class Container<T> {\n  value: T;\n\n  constructor(value: T) {\n    this.value = value;\n  }\n}\n\nconst container1: Container<number> = new Container(2);  // ðŸ‘Œ!\n\n// Error: Generic type \"Container<T>\" should be used with type parameters!\nconst container2: Container = new Container(2);\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type Container<T> = { value: T };\n\nconst container1: Container<number> = { value: 2 };  // ðŸ‘Œ!\n\n// Error: Generic type \"Container<T>\" should be used with type parameters!\nconst container2: Container = { value: 4 };\n`}</code></pre>\n    <p>{`As you may understand, none value will be valid for \"type variable\". Only arguments which annotated as \"type variable\" will be a valid value for this type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function getResponseBodyAndStatus<Status, Body>(\n  response: {\n    status: Status,\n    body: Body\n  }): [Status, Body] {\n\n  // Error: Type \"[Status, 'Custom Body']\" is incompatible with type \"[Status, Body]\"\n  return [response.status, \"Custom Body\"];\n}\n`}</code></pre>\n    <p>{`Also, the same as `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/unknown-type\"\n      }}>{`Unknown Type`}</a>{` you can't get properties from \"type variable\", because you can be replaced by \"undefined\", \"null\" or object which doesn't contain this property.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function length<T>(somethingWithLength: T) {\n\n  // Error: Property \"length\" does not exist in \"T\"\n  return somethingWithLength.length;\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"constraints\"\n    }}>{`Constraints`}</h2>\n    <p>{`But sometimes you need to annotate that your \"type variable\" can be only subtype of some existed in Hegel type. In Hegel you can annotate this super type after `}<inlineCode parentName=\"p\">{`:`}</inlineCode>{` (colon).`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function length<T: { length: number, ... }>(somethingWithLength: T) {\n  return somethingWithLength.length; // ðŸ‘Œ!\n}\n\nlet result = 0;\n\nresult = length([1, 2, 3]);     // ðŸ‘Œ!\nresult = length({ length: 4 }); // ðŸ‘Œ!\nresult = length(() => 2);       // ðŸ‘Œ!\n\n// Error: Parameter \"Set<number>\" is incompatible with restriction \"{ length: number, ... }\"\n// Because Set, WeakSet, Map and WeakMap has \"size\" property instead \"length\"\nresult = length(new Set<number>());\n`}</code></pre>\n    <p>{`Also, it works for primitive types`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function plus<T: number | bigint>(a: T, b: T): T {\n  return a + b;\n}\n\nlet result: bigint | number = 0;\n\nresult = plus(1, 2);   // ðŸ‘Œ!\nresult = plus(1n, 2n); // ðŸ‘Œ!\n\n// Error: Parameter \"'1'\" is incompatible with restriction \"bigint | number\"\nresult = plus(\"1\", \"2\");\n\n// Error: Type \"2n\" is incompatible with type \"number\"\nresult = plus(1, 2n);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"default-type\"\n    }}>{`Default Type`}</h2>\n    <p>{`You can also provide defaults for \"type variable\" the same as for a function argument.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type Container<T = unknown> = { value: T }\n\n// container type is \"Container<unknown>\"\nconst container: Container<> = { value: \"something\" }\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}