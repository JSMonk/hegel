{"version":3,"sources":["webpack:///../src/docs/docs/unknown-type.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ocAMO,IAAMA,EAAe,Q,gNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,gBADR,gBAGA,uBACA,6IACS,mBAAGC,WAAW,KAAQ,CAC3B,KAAQ,6FACP,0BAAYA,WAAW,KAAvB,eAHL,2IAIA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,yDAIL,0DAAyC,0BAAYA,WAAW,KAAvB,WAAzC,kCAA+H,mBAAGA,WAAW,KAAQ,CACjJ,KAAQ,gDADmH,mBAA/H,yDAEsF,0BAAYA,WAAW,KAAvB,WAFtF,+DAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uHAML,8BACE,iBAAGA,WAAW,cAAd,0FAAsH,0BAAYA,WAAW,KAAvB,WAAtH,aAAuL,0BAAYA,WAAW,KAAvB,SAAvL,gBAEF,oJACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+SAWL,4IACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,iNAWL,qCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,yLASL,8BACE,iBAAGA,WAAW,cAAd,uCAAmE,mBAAGA,WAAW,KAAQ,CACrF,KAAQ,0BADuD,eAAnE,Y,8MAQNJ,EAAWK,gBAAiB","file":"component---src-docs-docs-unknown-type-mdx-39fbb9f640d584674088.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"unknown-type\"\n    }}>{`Unknown Type`}</h1>\n    <hr></hr>\n    <p>{`Sometimes you don't know which type will come as function argument/variable value/object property value.\nAs example `}<a parentName=\"p\" {...{\n        \"href\": \"https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\"\n      }}><inlineCode parentName=\"a\">{`JSON.parse`}</inlineCode></a>{`. This function can return array of any types, object with any properties or any valid JSON value like string, number, boolean and etc.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const anything = JSON.parse('{ \"name\": null }');\n`}</code></pre>\n    <p>{`The most general type in Hegel is `}<inlineCode parentName=\"p\">{`unknown`}</inlineCode>{`. You can imagine this type as `}<a parentName=\"p\" {...{\n        \"href\": \"https://en.wikipedia.org/wiki/Universal_set\"\n      }}>{`\"Universal Set\"`}</a>{`. It means that all possible values in JavaScript has `}<inlineCode parentName=\"p\">{`unknown`}</inlineCode>{` type. It's a supertype for all types in Hegel type system.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const anyNumber: unknown = 2;\nconst anyString: unknown = \"something\";\nconst anything: unknown = class User {};\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you already familiar with TypeScript or Flow.js, this type has the same semantic as `}<inlineCode parentName=\"p\">{`unknown`}</inlineCode>{` in TS or `}<inlineCode parentName=\"p\">{`mixed`}</inlineCode>{` in Flow.js`}</p>\n    </blockquote>\n    <p>{`But, as you can understand, you can assign concrete type to wider type, but you can't assign wider type to a concrete type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const concreteType: string = \"I'm good for unknown\";\nconst wideType: unknown = \"I'm too wide for string\";\n\nconst iCanBeUnknown: unknown = concreteType;\nconst andICanBeString: string = concreteType;\n\nconst andICanBeUnknownToo: unknown = wideType;\nconst butCantBeString: string = wideType;\n`}</code></pre>\n    <p>{`Also, it means that you can't use unknown type as an argument for function which is waiting for some concrete type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function waitingFor(value: string) {\n  return \\`Awesome \\${value}\\`;\n}\n\nconst anything: unknown = 4;\n\n// Error: Type \"unknown\" is incompatible with type \"string\"\nconst result = waitingFor(anything);\n`}</code></pre>\n    <p>{`Or operator:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function waitingFor(value: unknown) {\n  // Error: Type \"unknown\" is incompatible with type \"string\"\n  return \\`Awesome \\${value}\\`;\n}\n\nconst result = waitingFor(class User {});\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Actually, Hegel provides ability to `}<a parentName=\"p\" {...{\n          \"href\": \"/docs/type-refinement\"\n        }}>{`refine type`}</a>{`.`}</p>\n    </blockquote>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}