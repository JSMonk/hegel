{"version":3,"sources":["webpack:///../src/docs/docs/architecture-overview.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"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","file":"component---src-docs-docs-architecture-overview-md-9e8602b2881f26da735b.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"architecture-overview\"\n    }}>{`Architecture Overview`}</h1>\n    <hr></hr>\n    <p>{`In this overview we will talk mostly about the Core of Hegel. It should help you to get a high-level understanding of the Hegel architecture.`}</p>\n    <p>{`Core is placed in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core\"\n      }}>{`@hegel/core`}</a>{` and contains the main logic of type checking and type inference.\nThe main logic of Core: take `}<a parentName=\"p\" {...{\n        \"href\": \"\"\n      }}>{`Abstract Syntax Tree`}</a>{` and convert it into symbols table (inside Hegel it's called `}<inlineCode parentName=\"p\">{`moduleScope`}</inlineCode>{`) which contains information about variables, scopes, and types.`}</p>\n    <p>{`So, AST conversion starts from tree traverse which is placed in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/utils/traverse.js\"\n      }}><inlineCode parentName=\"a\">{`src/utils/traverse.js`}</inlineCode></a>{`.\nIn traverse we have 3 steps:`}</p>\n    <h4 {...{\n      \"id\": \"precompute\"\n    }}><strong parentName=\"h4\">{`Precompute`}</strong></h4>\n    <p><a parentName=\"p\" {...{\n        \"href\": \"#precomute\"\n      }}>{`The Precompute step`}</a>{` is a step in `}<inlineCode parentName=\"p\">{`traverseTree`}</inlineCode>{` function inside `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/utils/traverse.js\"\n      }}><inlineCode parentName=\"a\">{`src/utils/traverse.js`}</inlineCode></a>{` which process AST node before the node children was processed.`}</p>\n    <p>{`It's needed to add initial information about `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/variable-info.js\"\n      }}>{`variables`}</a>{` and `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/variable-scope.js\"\n      }}>{`scopes`}</a>{`. Also, we use `}<a parentName=\"p\" {...{\n        \"href\": \"#precomute\"\n      }}>{`Precompute`}</a>{` for type refinement (which main logic is placed in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/inference/refinement.js\"\n      }}>{`src/inference/refinement.js`}</a>{`).`}</p>\n    <h4 {...{\n      \"id\": \"middlecompute\"\n    }}><strong parentName=\"h4\">{`Middlecompute`}</strong></h4>\n    <p>{`The most simple type of computation. The step processes node children one-by-one without deep processing. It's needed because JavaScript contains hoisting.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`const a = getA();\n\nfunction getA() {\n  return 1;\n}\n`}</code></pre>\n    <p>{`This step hoist Function Declarations and Interface Declarations (only inside `}<inlineCode parentName=\"p\">{`.d.ts`}</inlineCode>{` files) by adding raw nodes into symbols table (we will do lazy processing of the nodes if these nodes are used before own declaration or will process it (in `}<a parentName=\"p\" {...{\n        \"href\": \"#precomute\"\n      }}>{`Precompute step`}</a>{` ) when we find their declarations).`}</p>\n    <p>{`Also, it's used for fast adding class and object methods, because in JavaScript we can call a method in another method which currently are not be processed.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`class Main {\n  constructor() {\n    this.a = this.getA();\n  }\n\n  getA() {\n    return 1;\n  }\n}\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"postcompute\"\n    }}><strong parentName=\"h4\">{`Postcompute`}</strong></h4>\n    <p>{`In oposite to `}<a parentName=\"p\" {...{\n        \"href\": \"#precompute\"\n      }}>{`Precompute step`}</a>{`, `}<a parentName=\"p\" {...{\n        \"href\": \"#postcumpute\"\n      }}>{`Postcompute step`}</a>{` processes AST node after all node's children were processed.\nWe use the step for `}<a parentName=\"p\" {...{\n        \"href\": \"#type-inference\"\n      }}>{`type inference`}</a>{` (which main logic is placed in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/inference/\"\n      }}><inlineCode parentName=\"a\">{`src/inference`}</inlineCode>{` directory`}</a>{`) and collecting of `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/meta/call-meta.js\"\n      }}>{`Calls Infromation`}</a>{`. The `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/meta/call-meta.js\"\n      }}>{`Calls Infromation`}</a>{` is used in `}<a parentName=\"p\" {...{\n        \"href\": \"#checking-step\"\n      }}>{`Checking Step`}</a></p>\n    <h3 {...{\n      \"id\": \"type-inference\"\n    }}>{`Type Inference`}</h3>\n    <p>{`So, type inference logics for each literal are placed in (which main logic is placed in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/inference/\"\n      }}><inlineCode parentName=\"a\">{`src/inference`}</inlineCode>{` directory`}</a>{`). For an expression in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/call.js\"\n      }}><inlineCode parentName=\"a\">{`src/type-graph/call.js`}</inlineCode>{` file`}</a>{` which adds `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/meta/call-meta.js\"\n      }}>{`Calls Infromation`}</a>{` ).`}</p>\n    <p>{`For literals, we have a really simple logic. For example, code for type inference of a simple type:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`switch (currentNode.type) {\n  case NODE.NUMERIC_LITERAL:\n    result = Type.term(currentNode.value, {\n      isSubtypeOf: Type.Number\n    });\n    break;\n  case NODE.BIGINT_LITERAL:\n    result = Type.term(\\`\\${currentNode.value}n\\`, {\n      isSubtypeOf: Type.BigInt\n    });\n    break;\n  case NODE.TEMPLATE_LITERAL:\n    result = Type.String;\n    break;\n  case NODE.STRING_LITERAL:\n    result = Type.term(\\`'\\${currentNode.value}'\\`, {\n      isSubtypeOf: Type.String\n    });\n    break;\n  case NODE.BOOLEAN_LITERAL:\n    result = Type.term(currentNode.value);\n    break;\n  case NODE.NULL_LITERAL:\n    result = Type.Null;\n    break;\n  case NODE.REG_EXP_LITERAL:\n    result = Type.find(\"RegExp\");\n    break;\n`}</code></pre>\n    <p>{`The tricky moments start for `}<a parentName=\"p\" {...{\n        \"href\": \"#function-inference\"\n      }}>{`Function`}</a>{` and `}<a parentName=\"p\" {...{\n        \"href\": \"#class-and-object-inference\"\n      }}>{`Objects/Classes`}</a>{`.`}</p>\n    <h4 {...{\n      \"id\": \"function-inference\"\n    }}>{`Function Inference`}</h4>\n    <p>{`First of all, we try to collect any defined type for arguments or return type at `}<a parentName=\"p\" {...{\n        \"href\": \"#precompute\"\n      }}>{`Precompute step`}</a>{`, if argument or function doesn't have a type annotation then we create `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/type-var.js\"\n      }}><inlineCode parentName=\"a\">{`TypeVar`}</inlineCode></a>{` (this type represents generic variables), and add it to generic arguments list. The code is placed in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/inference/function-type.js\"\n      }}>{`/src/inference/function-type.js`}</a>{` in `}<inlineCode parentName=\"p\">{`inferenceFunctionLiteralType`}</inlineCode>{`.`}</p>\n    <p>{`After processing every child node, we will try to find the type of an argument or return type by `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/meta/call-meta.js\"\n      }}>{`Call Information`}</a>{`, which is taken from all child `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/variable-scope.js\"\n      }}>{`VariableScopes`}</a>{` of the function scope.`}</p>\n    <p>{`Arguments Resolving Colde is placed in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/inference/function-type.js\"\n      }}>{`/src/inference/function-type.js`}</a>{` in `}<inlineCode parentName=\"p\">{`resolveOuterTypeVarsFromCall`}</inlineCode>{`.`}</p>\n    <h4 {...{\n      \"id\": \"class-and-object-inference\"\n    }}>{`Class and Object inference`}</h4>\n    <p>{`From the other side, inference of class or object type, because we have `}<inlineCode parentName=\"p\">{`this`}</inlineCode>{` keyword in JavaScript. It means that when we try to use any property or method from other methods in object or class instance we should have access to all the object or class methods and properties wherever it's defined.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const obj = {\n  c: 4,\n  a() {\n    return this.b();\n  },\n  b() {\n    return this.c;\n  },\n};\n`}</code></pre>\n    <p>{`So, we need to add methods and properties lazily. First of all, we add all methods and properties raw nodes in object/class type (We make it in `}<a parentName=\"p\" {...{\n        \"href\": \"#middlecompute\"\n      }}>{`Middlecompute step`}</a>{`), and, if we try to access a property or method then we traverse saved node and infer the type of the method or property (We make it by `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/scope.js\"\n      }}>{`Scope`}</a>{` static method `}<inlineCode parentName=\"p\">{`addAndTraverseNodeWithType`}</inlineCode>{`).`}</p>\n    <h3 {...{\n      \"id\": \"checking-step\"\n    }}>{`Checking Step`}</h3>\n    <p>{`This step is described in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/checking/index.js\"\n      }}>{`/src/checking/index.js`}</a>{` and only take all `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/meta/call-meta.js\"\n      }}>{`Calls Information`}</a>{` from every defined `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/variable-scope.js\"\n      }}>{`VariableScope`}</a>{` (this calls is stored in `}<inlineCode parentName=\"p\">{`calls`}</inlineCode>{` property of every instance of `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/variable-scope.js\"\n      }}>{`VariableScope class`}</a>{`) and check that every defined argument `}<a parentName=\"p\" {...{\n        \"href\": \"#principal-type\"\n      }}>{`is a principal type for`}</a>{` given argument at the position.\n`}<inlineCode parentName=\"p\">{`checkCalls`}</inlineCode>{` function in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/checking/index.js\"\n      }}>{`/src/checking/index.js`}</a>{`. We call the function in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/type-graph.js\"\n      }}>{`/src/type-graph/type-graph.js `}<inlineCode parentName=\"a\">{`createModuleScope`}</inlineCode>{` function`}</a>{` )`}</p>\n    <h3 {...{\n      \"id\": \"types\"\n    }}>{`Types`}</h3>\n    <p>{`All types in Hegel Core are defined in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/\"\n      }}>{`/src/type-graph/types/`}</a>{` and every type is a child for the base `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/type.js\"\n      }}>{`Type class`}</a>{`.`}</p>\n    <h4 {...{\n      \"id\": \"principal-type\"\n    }}>{`Principal Type`}</h4>\n    <p>{`Principal type is a type which equals to current or will be a supertype of current. From early version of `}<inlineCode parentName=\"p\">{`isPrincipalTypeFor`}</inlineCode>{` function:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`isPrincipalTypeFor(type: Type) {\n  return this.equalsTo(type) || this.isSuperTypeFor(type);\n}\n`}</code></pre>\n    <p>{`Each type defined own `}<inlineCode parentName=\"p\">{`equalsTo`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`isSuperTypeFor`}</inlineCode>{`. As example, `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/union-type.js\"\n      }}>{`UnionType class`}</a>{` defined `}<inlineCode parentName=\"p\">{`isSuperTypeFor`}</inlineCode>{` as (simplified version without performance details):`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`isSuperTypeFor(anotherType: Type): boolean {\n  if (anotherType instanceof UnionType) {\n    for (const variantType of anotherType.variants) {\n      if (!this.variants.some(type => type.isPrincipalTypeFor(variantType))) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return this.variants.some(type =>\n    type.isPrincipalTypeFor(anotherType)\n  );\n}\n`}</code></pre>\n    <h4 {...{\n      \"id\": \"bottomtype\"\n    }}>{`\\\\$BottomType`}</h4>\n    <p>{`One of the interesting architecture decisions is `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/bottom-type.js\"\n      }}><inlineCode parentName=\"a\">{`$BottomType`}</inlineCode></a>{`. This type behaves like a `}<inlineCode parentName=\"p\">{`Promise`}</inlineCode>{` in types world. It means that when we want to apply `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/union-type.js\"\n      }}>{`GenericType`}</a>{` (which behaves like a function in types world) any `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/type-var.js\"\n      }}>{`TypeVar`}</a>{` we can reduce the cost of `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/type.js\"\n      }}><inlineCode parentName=\"a\">{`changeAll`}</inlineCode>{` function`}</a>{` and instead of deep changing of generic arguments to another type variables, we can return `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/bottom-type.js\"\n      }}><inlineCode parentName=\"a\">{`$BottomType`}</inlineCode></a>{` which say that we want to apply new type variables instead old ones, and if we will replace a new type variable to a specific type instead of one more call of `}<inlineCode parentName=\"p\">{`changeAll`}</inlineCode>{`, we only change new type variable to a specific type and that's all.`}</p>\n    <h3 {...{\n      \"id\": \"refinement\"\n    }}>{`Refinement`}</h3>\n    <p>{`Another tricky and interesting moment in Hegel is type refinement. It's tricky because, for refinement variable (for example), we need to create a new `}<inlineCode parentName=\"p\">{`VariableScope`}</inlineCode>{` and add a refined type of the variable in the scope. For example the next code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const a: number | null = 14;\nif (a !== null) {\n  const b = a + 12;\n}\n`}</code></pre>\n    <p>{`After the decision that inside `}<inlineCode parentName=\"p\">{`if`}</inlineCode>{` scope the variable `}<inlineCode parentName=\"p\">{`a`}</inlineCode>{` will be `}<inlineCode parentName=\"p\">{`number`}</inlineCode>{` type (we decide it in the `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/inference/equals-refinement.js\"\n      }}>{`/src/inference/equals-refinement.js`}</a>{` ), we will add into `}<inlineCode parentName=\"p\">{`if`}</inlineCode>{` scope variable `}<inlineCode parentName=\"p\">{`a`}</inlineCode>{` with new type `}<inlineCode parentName=\"p\">{`number`}</inlineCode>{` instead of `}<inlineCode parentName=\"p\">{`number | null`}</inlineCode>{` (check `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/inference/refinement.js\"\n      }}>{`/src/inference/refinement.js `}<inlineCode parentName=\"a\">{`refinement`}</inlineCode>{` function`}</a>{` ).`}</p>\n    <p>{`But, sometimes we should save a previous type to stay sound. An example is objects.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function assert(obj: { a: number | string }): { a: number } | undefined {\n  if (typeof obj.a === \"number\") {\n    // With defined algorithm \"obj\" should be { a: number }, but it's not\n    return obj;\n  }\n}\n\nconst original: { a: number | string } = { a: 2 };\nconst refinement = assert(original); // { a: number }\noriginal.a = \"str\";\n\nif (refinement !== undefined) {\n  // TypeError\n  void refinement.a.toFixed(0);\n}\n`}</code></pre>\n    <p>{`So, to solve the problem we use `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/tree/master/packages/core/src/type-graph/types/refinemented-type.js\"\n      }}><inlineCode parentName=\"a\">{`$RefinementedType`}</inlineCode></a>{`, which saves an original type and refined type.`}</p>\n    <h3 {...{\n      \"id\": \"ps\"\n    }}>{`P.S.`}</h3>\n    <p>{`If you need more details in the overview then ask the questions in `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/JSMonk/hegel/issues\"\n      }}>{`Hegel Issues`}</a>{`, and we will add more information about the weird block or will answer the question in the issue.`}</p>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}