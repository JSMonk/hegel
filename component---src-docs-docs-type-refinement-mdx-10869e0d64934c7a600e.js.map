{"version":3,"sources":["webpack:///../src/docs/docs/type-refinement.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ocAMO,IAAMA,EAAe,Q,mNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,mBADR,mBAGA,uBACA,wOACA,uDACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,sZAYL,oDAAmC,mBAAGA,WAAW,KAAQ,CACrD,KAAQ,wXADuB,cAAnC,sFAGA,kJACA,6EAA4D,0BAAYA,WAAW,KAAvB,MAA5D,KAAgH,0BAAYA,WAAW,KAAvB,SAAhH,KAAuK,0BAAYA,WAAW,KAAvB,aAAvK,KAAkO,0BAAYA,WAAW,KAAvB,OAAlO,wEACA,iGACA,2CACA,sBACE,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,cADQ,aAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,YADQ,WAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,gBADQ,eAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,YADQ,WAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,gBADQ,eAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,QADQ,OAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,SADQ,QAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,kBADQ,iBAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,iCADQ,mCAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,wBADQ,yBAItB,iBAAQ,CACN,GAAM,YADR,YAGA,6JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qLAWL,iBAAQ,CACN,GAAM,UADR,UAGA,4PACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,i3BA4BL,iBAAQ,CACN,GAAM,cADR,cAGA,yKACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,meAYL,iBAAQ,CACN,GAAM,UADR,UAGA,iFAAgE,0BAAYA,WAAW,KAAvB,UAAhE,iCACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,yTAQL,iBAAQ,CACN,GAAM,cADR,cAGA,mIACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2JAWL,iBAAQ,CACN,GAAM,MADR,MAGA,8GACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6JAWL,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,sKAUL,iBAAQ,CACN,GAAM,OADR,OAGA,kMACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,yNAaL,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+NAaL,iBAAQ,CACN,GAAM,gBADR,gBAGA,+GACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6UAeL,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,4UAWL,iBAAQ,CACN,GAAM,+BADR,kCAGA,qLACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0PAcL,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,4NAeL,iBAAQ,CACN,GAAM,uBADR,uBAGA,4KAA2J,0BAAYA,WAAW,KAAvB,UAA3J,kCAAgP,0BAAYA,WAAW,KAAvB,UAAhP,oDACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+HASL,+JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,o0B,iNA2BTJ,EAAWK,gBAAiB","file":"component---src-docs-docs-type-refinement-mdx-10869e0d64934c7a600e.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"type-refinement\"\n    }}>{`Type Refinement`}</h1>\n    <hr></hr>\n    <p>{`Type refinement is an ability to prove that your variable has specific type. It helps you to build more type safe program when you work with user input or server response and don't miss static type analysis.`}</p>\n    <p>{`Lets explore the next example.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function calculateSum(firstUserInput: unknown, secondUserInput: unknown) {\n  if (typeof firstUserInput !== \"number\") {\n    throw new TypeError(\"first provided value has a wrong type. Shoulde be a number\");\n  }\n  if (typeof secondUserInput !== \"number\") {\n    throw new TypeError(\"second provided value has a wrong type. Shoulde be a number\");\n  }\n  return firstUserInput + secondUserInput;\n}\n`}</code></pre>\n    <p>{`If you open this example in `}<a parentName=\"p\" {...{\n        \"href\": \"/try#GYVwdgxgLglg9mABBAhgGwiNKoFMDKIAtgBTAwBOAzlAKpW4UCSYADiFAFyLgDWYcAO5gANIgYQEAE3qMW7LjzD8hYAJSIA3gChEiGMEQkoAT1a44h8tToNmbDogCEAXheIARGGIAjRh40dPT0oAAsKIUQwXEFEABUzXABRCgiKEg9rGkRWCIA3GClcKUQ89BBcRFCUKkQUREEIsABzRFNzADpEfFC4LCLEPzqo3381AG5dRABfKYMjdotDCWlZewVnN09vIj8KAK0pkPDI6NiE8xS0jJWwEty4AqKSsrQKqprhxoRWxa6evpoAZDeo7PYBSZ6WZ6Ci4KAgChILK2OQOKCIADU4lwkjua3kHEm0yAA\"\n      }}>{`Playground`}</a>{` then you will see that Hegel doesn't show any type error at the 8 line. But why? `}</p>\n    <p>{`It's because we proved by conditions that \"firstUserInput\" and \"secondUserInput\" will always be a numbers at the 8 line.`}</p>\n    <p>{`So, type refinement it's a specific condition inside `}<inlineCode parentName=\"p\">{`if`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`while`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`do..while`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`for`}</inlineCode>{`, ternary and logical operators, which precise the type of variable.`}</p>\n    <p>{`Hegel has several conditions which could be used as refinement operator.`}</p>\n    <p>{`Table of contents:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#equality\"\n        }}>{`Equality`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#switch\"\n        }}>{`switch`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#identifier\"\n        }}>{`Identifier`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#typeof\"\n        }}>{`typeof`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#instanceof\"\n        }}>{`instanceof`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#in\"\n        }}>{`in`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#not\"\n        }}>{`Not`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#combinations\"\n        }}>{`Combinations`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#return-break-continue-throw\"\n        }}>{`return, break, continue, throw`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#needlessrefinement\"\n        }}>{`Needless refinement`}</a></li>\n    </ul>\n    <h2 {...{\n      \"id\": \"equality\"\n    }}>{`Equality`}</h2>\n    <p>{`The most simple refinement operator is equality. You only may prove equality of variable and some literal inside the block like this`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function get2(arg: unknown): 2 {\n  if (arg === 2) {\n\n    // Inside if block type of \"arg\" variable is \"2\"\n    return arg;\n  }\n  throw new TypeError(\"Arg is not 2\");\n} \n`}</code></pre>\n    <h2 {...{\n      \"id\": \"switch\"\n    }}>{`switch`}</h2>\n    <p>{`The same logic has switch expression. In each case you prove that variable equals to a value. But with an exception - if you drop \"break\", \"return\" and \"throw\" statement from case then the next case will include previous prove.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type User = { name: string, age: number, id: number };\n\ntype Action =\n  | { type: \"DELETE_USER\", payload: { userId: number } }\n  | { type: \"REMOVE_USER\", payload: { userId: number } }\n  | { type: \"CREATE_USER\", payload: { user: User } };\n\nfunction reducer(action: Action) {\n  switch (action.type) {\n    case \"REMOVE_USER\":\n    case \"DELETE_USER\":\n      // In this case action type is \"{ payload: { userId: number }, type: 'DELETE_USER' } | { payload: { userId: number }, type: 'REMOVE_USER' }\"\n      return \"User deleted\";\n    case \"CREATE_USER\":\n      // In this case action type is \"{ payload: { user: { age: number, id: number, name: string } }, type: 'CREATE_USER' }\"\n      return action.payload.user;\n    default:\n      // In this case action type is \"never\"\n      panic(action);\n  }\n}\n\nfunction panic(arg: ?never) {\n  throw new Error();\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"identifier\"\n    }}>{`Identifier`}</h2>\n    <p>{`The second simple refinement operator is identifier. The main restriction of this refinement that it can be used only inside logical expressions`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const maybeTwo: ?number = 2;\n\n// We have proved that \"maybeTwo\" at the right part of \"logical and\" is not \"falsy\", so we can use \"maybeTwo\" with \"+\" operator\n// Type of \"sub\" variable is \"0 | number | undefined\"\nconst sum = maybeTwo && maybeTwo + 4;\n\n// We have proved that \"maybeTwo\" at the right part of \"logical or\" is  \"falsy\", so we can return something to remove this union case.\n// Type of \"defaultTwo\" variable is \"2 | number\"\nconst defaultTwo = maybeTwo || 2;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"typeof\"\n    }}>{`typeof`}</h2>\n    <p>{`Typeof refinement based on comparison of return value of `}<inlineCode parentName=\"p\">{`typeof`}</inlineCode>{` operator and string literal.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const maybeTwo: number | string = 2;\n\n// We have proved that in positive case of condition inside ternary operator \"maybeTwo\" variable will have a type \"string\" and in negative - type \"number\"\n// Type of \"two\" variable is \"number\"\nconst two = typeof maybeTwo === \"string\" ? Number(maybeTwo) : maybeTwo;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"instanceof\"\n    }}>{`instanceof`}</h2>\n    <p>{`Instanceof refinement prove that variable or property inside variable is instance of provided constructor.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class User {}\nclass Admin extends User { sayHiToAdmin() {} }\n\nconst user = new User();\n\nif (user instanceof Admin) {\n  user.sayHiToAdmin();\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"in\"\n    }}>{`in`}</h2>\n    <p>{`In refinement prove that variable or property inside variable has specified property.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class User {}\nclass Admin { sayHiToAdmin() {} }\n\nconst user: User | Admin = new User();\n\nif (\"sayHiToAdmin\" in user) {\n  user.sayHiToAdmin();\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const unknownObj: {...} = {};\n\nif (\"value\" in unknownObj) {\n\n  // Type of \"unknownValue\" variable is \"unknown\"\n  const unknownValue = unknownObj.value;\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"not\"\n    }}>{`Not`}</h2>\n    <p>{`If you use any refinement condition with logical \"not\" operator or oposite operators like not-equal, strict not-not equal you will prove negative case of your refinement`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class Empire { aveEmperor() {} }\nclass Republic { spqr() {} }\n\nconst rome: Empire | Republic = new Empire();\n\nif (!(rome instanceof Republic)) {\n\n  // rome in this case is Empire\n  rome.aveEmperor();\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type Answer = 'To Be' | 'Not to Be';\n\nfunction hamlet(answer: Answer) {\n  if (answer !== 'To Be') {\n\n    // Type of variable is \"'Not to Be'\" inside this scope\n    return answer;\n  }\n  throw new Error();\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"combinations\"\n    }}>{`Combinations`}</h2>\n    <p>{`Also, you may combine existed refinements via \"logical and\" or \"logical or\" operators.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const stranger = JSON.parse('{}');\n\nif (\n  typeof stranger === \"object\" &&\n  stranger != null &&\n  \"secretPhrase\" in stranger &&\n  stranger.secretPhrase === \"valar morghulis\"\n) {\n\n  // Type of \"stranger\" variable in this scope is \"{ secretPhrase: \"valar morghulis\", ... }\"\n  const someoneWithoutName = stranger;\n}\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function detectSong(songPhrase: string) {\n  if (songPhrase === \"It's like I'm paranoid\" || songPhrase === \"looking over my back\") {\n\n    // Type of \"songPhrase\" in this scope is \"'It's like I'm paranoid' | 'looking over my back'\n    const familiarPhrase = songPhrase;\n    return \"Linkin Park - Papercut\";\n  }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"return-break-continue-throw\"\n    }}>{`return, break, continue, throw`}</h2>\n    <p>{`If you use next statements (return, throw, break, continue) inside refinement scope, you prove that outside this block your variable will have oposite type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class Empire { aveEmperor() {} }\nclass Republic { spqr() {} }\n\nconst rome: Empire | Republic = new Empire();\n\nif (rome instanceof Empire) {\n  throw new TypeError(\"Empire was fallen!\");\n}\n\n// rome in this case is Republic\nrome.spqr();\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class Empire { aveEmperor() {} }\n\nconst empires: Array<Empire> = [];\n\nempires[1] = new Empire();\n\nfor (const empire of empires) {\n  if (empire === undefined) {\n    continue;\n  }\n  empire.aveEmperor();\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"needless-refinement\"\n    }}>{`Needless refinement`}</h2>\n    <p>{`Sometimes (especially after refactoring) you may do refinement which does not do something useful. As example is provement that type of variable is `}<inlineCode parentName=\"p\">{`number`}</inlineCode>{` while variable type is always `}<inlineCode parentName=\"p\">{`number`}</inlineCode>{`. In this case Hegel try to notify you about it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const calculatedSum = 42 + 14;\n\n// Error: Variable is always \"number\"\nif (typeof calculatedSum === \"number\") {\n  \n}\n`}</code></pre>\n    <p>{`Another reallife example that after refactoring you dropped a variant of union in switch, but your code still try to handle this case:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type User = { name: string, age: number, id: number };\n\ntype Action =\n  | { type: \"DELETE_USER\", payload: { userId: number } }\n// Deleted after refactoring case\n//  | { type: \"REMOVE_USER\", payload: { userId: number } }\n  | { type: \"CREATE_USER\", payload: { user: User } };\n\nfunction reducer(action: Action) {\n  switch (action.type) {\n    // Error: Property can't be \"'REMOVE_USER'\"\n    case \"REMOVE_USER\":\n    case \"DELETE_USER\":\n      // In this case action type is \"{ payload: { userId: number }, type: 'DELETE_USER' } | { payload: { userId: number }, type: 'REMOVE_USER' }\"\n      return \"User deleted\";\n    case \"CREATE_USER\":\n      // In this case action type is \"{ payload: { user: { age: number, id: number, name: string } }, type: 'CREATE_USER' }\"\n      return action.payload.user;\n  }\n}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}