{"version":3,"sources":["webpack:///../src/docs/docs/array-types.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"mcAMO,IAAMA,EAAe,Q,+MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,eADR,eAGA,uBACA,8QACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,gDAIL,8BACE,iBAAGA,WAAW,cAAd,iMAA6N,0BAAYA,WAAW,KAAvB,MAA7N,oDAEF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,wFAKL,8GACA,iBAAQ,CACN,GAAM,qBADR,qBAGA,6EACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2FAKL,yFAAwE,0BAAYA,WAAW,KAAvB,WAAxE,0HACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6RAYL,yPACA,8BACE,iBAAGA,WAAW,cAAd,oHAAgJ,mBAAGA,WAAW,KAAQ,CAClK,KAAQ,iTADoI,sBAAhJ,KAEqC,mBAAGA,WAAW,KAAQ,CACvD,KAAQ,4RADyB,mBAFrC,MAMF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mNAUL,iBAAQ,CACN,GAAM,8BADR,8BAGA,0IACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,8HAOL,8BACE,iBAAGA,WAAW,cAAd,gFAA4G,0BAAYA,WAAW,KAAvB,gBAA5G,OAA4K,0BAAYA,WAAW,KAAvB,UAA5K,8CACJ,mBAAGA,WAAW,KAAQ,CACd,KAAQ,mPADhB,sBADI,KAGqC,mBAAGA,WAAW,KAAQ,CACvD,KAAQ,mOADyB,mBAHrC,MAOF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kJAOL,4OACwL,mBAAGA,WAAW,KAAQ,CAC1M,KAAQ,0BAD4K,mBADxL,KAIA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2MAUL,8BACE,iBAAGA,WAAW,cAAd,yLACJ,mBAAGA,WAAW,KAAQ,CACd,KAAQ,0VADhB,sBADI,KAGqC,mBAAGA,WAAW,KAAQ,CACvD,KAAQ,yUADyB,qBAIvC,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kPAUL,8BACE,iBAAGA,WAAW,cAAd,6DAAyF,0BAAYA,WAAW,KAAvB,UAAzF,mIAEF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,4BAIL,gFAMA,wGAAuF,0BAAYA,WAAW,KAAvB,WAAvF,iCAA4K,0BAAYA,WAAW,KAAvB,OAA5K,KAAiO,0BAAYA,WAAW,KAAvB,UAAjO,6DACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0GAOL,iBAAQ,CACN,GAAM,aADR,aAGA,oKACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gMAOL,8BACE,iBAAGA,WAAW,cAAd,kMAEF,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+PAUL,8BACE,iBAAGA,WAAW,cAAd,yEAAqG,mBAAGA,WAAW,KAAQ,CACvH,KAAQ,4UADyF,8B,6MAQ3GJ,EAAWK,gBAAiB","file":"component---src-docs-docs-array-types-mdx-cb608c2856f5fc75286e.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"array-types\"\n    }}>{`Array Types`}</h1>\n    <hr></hr>\n    <p>{`Array is another fundamental JavaScript data type which represents a heterogeneous collection (collection which can contain more than one data-type inside). Hegel provides syntax for annotating array types and restricts collection element types.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you are familiar with TypeScript or Flow.js, you may know about array types, but both Flow.js and TypeScript provide two methods of array definition: via Array-constructor and via adding `}<inlineCode parentName=\"p\">{`[]`}</inlineCode>{` (square brackets) at the end of the type name:`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const oneWay: Array<number> = [1, 2, 3];\nconst anotherOne: number[] = [1, 2, 3];\n`}</code></pre>\n    <p>{`Hegel provides only the first variant without additional syntax with square brackets.`}</p>\n    <h2 {...{\n      \"id\": \"array-constructor\"\n    }}>{`Array Constructor`}</h2>\n    <p>{`There are two ways to define an array in JavaScript:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const arrayLiteral = [];\nconst arrayConstructorInvocationWithLength = new Array(0);\n`}</code></pre>\n    <p>{`Hegel treats these differently. When you create an array via the `}<inlineCode parentName=\"p\">{`Array()`}</inlineCode>{` constructor - items of the array will be \"undefined\" and will have \"undefined\" type in addition to the annotated one.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const arrayLiteral: Array<number> = [];\narrayLiteral[0] = 4; // ðŸ‘Œ!\n\n// Error: Type \"undefined\" is incompatible with type \"number\"\narrayLiteral[1] = undefined;\n\nconst arrayInstance = new Array<number>(4);\narrayInstance[0] = 4; // ðŸ‘Œ!\narrayInstance[1] = undefined; // ðŸ‘Œ!\n`}</code></pre>\n    <p>{`The reason for this is the behavior of the Array constructor. Even if you set the length of your array it will be filled with undefined, so Hegel can't give any guarantees that all your elements will have the annotated type.`}</p>\n    <blockquote>\n      <p parentName=\"blockquote\">{`TypeScript and Flow.js do not handle this condition, so it's easy to get runtime TypeErrors with these analyzers `}<a parentName=\"p\" {...{\n          \"href\": \"https://www.typescriptlang.org/v2/en/play?ts=3.8.0-beta#code/MYewdgzgLgBAhgJwXAngSUlOZgFMYC8MYuA7jAIJKoA8YArgLYBGuCAfABQAsAlANwAoQQBtcsAJZgoAZVwBHerhz4iAIjVCAZiAQxOoTMSYwQW+NXSZseXjADegmDAD0LmABUUAB1wBRJF0ALhgAYWwwEFgEXDgAExhvBBBfBCgUGAByKBAAMQkAD1w4zNNzejA43C0pYqcYKVkFJRUYAGoiBkYAOhz8orjOAAYBQQBfIA\"\n        }}>{`TypeScript Example`}</a>{`, `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoAxnAdgZwC5gCGATsYQJ4CSuehW6ApmALxhYNICCpFAPFgFcAtgCMGxAHwAKACwBKANypUMBgQCWWPAGUGARwEN6TVgCJTSqHGJgpmGm2Fg4UIjyo06jOWADeqMDBgYDAAFXIABwYAUVJrAC4wAGE6LDgCYgZCABMwCOI4KOI8cjAAcjw4ADF1AA8GbLLnVwEsbIYoTQaAsE0dfUNjMABqVkEhADpKmvrsqQAGRVQAXyA\"\n        }}>{`Flow.js Example`}</a>{`:`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const arrayInstance = new Array<number>(4);\n\nlet intSequence = \"\";\nfor (const num of arrayInstance) {\n  // TypeError: Cannot read property 'toFixed' of undefined\n  intSequence += num.toFixed(0);\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"getting-element-from-array\"\n    }}>{`Getting element from Array`}</h2>\n    <p>{`Another interesting Hegel \"feature\" is type inference for elements which retrieved from an array by index syntax.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [];\n\n// Type of firstElement is \"number | undefined\"\nconst firstElement = numbers[0];\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you are familiar with TypeScript or Flow.js, these \"analyzers\" will infer `}<inlineCode parentName=\"p\">{`firstElement`}</inlineCode>{` as `}<inlineCode parentName=\"p\">{`number`}</inlineCode>{` which can create a TypeError at runtime.\n`}<a parentName=\"p\" {...{\n          \"href\": \"https://www.typescriptlang.org/v2/en/play?ts=3.8.0-beta#code/MYewdgzgLgBGCuBbARgUwE4QFwwILvQEMBPAHgRQwD4YBeGAbQF0BuAKAHoOYAVYgB1QBRAiHQ4AwoTBgQsdKkIATGP3QhB6KMRgByKCABiASwAeqJbpggAZjHhglqG8bAW2oSLBeYoQgDaoiKhgsPQUaJgMAAxMAHQGJuZKABQAlCxAA\"\n        }}>{`TypeScript Example`}</a>{`, `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoVBjOA7AzgFzGwFcBbAIwFMAnXALjAEFrqBDATwB4SKaA+MAF4wAbQC6AblTBgYACrsADpQCiLONQYBhVtmxxC1SqwAmYRdTjLq+dmADk+OADEAlgA9KJ+2DhQwxNgmlFCu2F6YOARgobT4KjCUpJTYhMI8VLQiAAxiAHRObp4mABQAlFJAA\"\n        }}>{`Flow.js example`}</a>{`.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [];\n\n// TypeError: Cannot read property 'toFixed' of undefined\nconst firstElement = numbers[0].toFixed();\n`}</code></pre>\n    <p>{`Let's go back to Hegel.\nThis behavior also means that even if you try to access an element in a for loop you still get \"number | undefined\" element type. You must specify that your value is not undefined using `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/type-refinement\"\n      }}>{`type refinement`}</a>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\nfor (let i = 0; i < numbers.length; i++) {\n  const num = numbers[i]; // still \"number | undefined\"\n  if (typeof num === \"number\") {\n    // ...\n  }\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The reason for this decision is the mutable nature of the \"length\" property of Array, so I can write the following code, which will break my program without this property behavior.\n`}<a parentName=\"p\" {...{\n          \"href\": \"https://www.typescriptlang.org/v2/en/play?ts=3.8.0-beta#code/MYewdgzgLgBGCuBbARgUwE4QFwwILvQEMBPAHgRQwD4YBeGAbQEYAaGAJjYGYBdAbgBQAG1SwAlmCgBlVAEd4qMMFR0YAIjWCKaTADoRYAOZQAFqoCsggGYh0MABQjxqgAx8YYmKThIdEfYrGJu5iANShAJQwAN4CMDAA9AkwACrEAA6oAKIEtjgAwoRgYCCw6KiEACYw6eggmehQxDAA5FAgAGJiAB6olS0wIFYw8GCVqFYSfXEekjLyisowofTaGBAMYjy67V29lfYRggC+AkA\"\n        }}>{`TypeScript example`}</a>{`, `}<a parentName=\"p\" {...{\n          \"href\": \"https://flow.org/try/#0PQKgBAAgZgNg9gdzCYAoAxnAdgZwC5hYCuAtgEYCmATjgFxgCCVVAhgJ4A8x51AfGAF4wAbQCMAGjAAmSQGYAugG5UMCgQCWWPAGUKARyIUs6CoLAAic8u6UaAOlVYA5ngAWZgKzKocKmAAUqhpmAAyKYOpgHISktjgORi6u4eoA1KkAlGAA3qhgYMDAYAAqbAAOFACizL70AMIsWFhwBFQULAAmYGVUcBVUeGxgAOR4cABi6gAeFB3DYHBQYERYHRRQmrN5EVq6BkYmYKlCNtQ4wurydmOTMx3+GcoAvqhAA\"\n        }}>{`Flow.js Example`}</a></p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\nlet intSequence = \"\";\nnumbers.length = 5;\nfor (let i = 0; i < numbers.length; i++) {\n  // TypeError: Cannot read property 'toFixed' of undefined\n  intSequence += numbers[i].toFixed();\n}\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`Why not make length 'readonly' and add refinement for the `}<inlineCode parentName=\"p\">{`length`}</inlineCode>{` array property?\". The answer is a popular method of cleaning an array. In many JavaScript programs you may see the next line:`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`someArray.length = 0;\n`}</code></pre>\n    <p>{`This is the most popular way to quickly clean an array.`}</p>\n    {\n      /*-\n      I believe there is content missing here. The paragraph above needs a conclusion, and the paragraph below needs an introduction.\n      */\n    }\n    <p>{`Nowadays this is not the best practice for iterating over an array. You can use `}<inlineCode parentName=\"p\">{`forEach`}</inlineCode>{` (or other array methods like `}<inlineCode parentName=\"p\">{`map`}</inlineCode>{`, `}<inlineCode parentName=\"p\">{`filter`}</inlineCode>{` and etc.) as a safe variant of iterating over the array.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\n\n// num type is \"number\"\nnumbers.forEach((num) => {});\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"subtyping\"\n    }}>{`Subtyping`}</h2>\n    <p>{`Another safe part of Hegel Arrays is their invariant nature. You can't assign one array to another if they contain different element types:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\n\n// Error: Type \"Array<number>\" is incompatible with type \"Array<number | string>\"\nconst numbersOrStrings: Array<number | string> = numbers;\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`The reason for this decision is the reference nature of JavaScript arrays. If Hegel allows this assignment you will be able mutate the source array via another and get unpredictable errors.`}</p>\n    </blockquote>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: Array<number> = [1, 2, 3];\nconst numbersOrStrings: Array<number | string> = numbers;\n\nnumbersOrStrings.push(\"some string\");\n\n// TypeError: num.toFixed is not a function\nconst fixedNumbers = numbers.map((num) => num.toFixed(0));\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you are familiar with TypeScript, you may know about this problem. `}<a parentName=\"p\" {...{\n          \"href\": \"http://www.typescriptlang.org/play/index.html?ssl=1&ssc=1&pln=8&pc=1#code/MYewdgzgLgBGCuBbARgUwE4QFwwILvQEMBPAHgRQwD4YBeGAbQEYAaGAJjYGYBdAbgBQoSLAppMAeXQBlKOgCWYAObY8BEuSTiYAHxjQFymvTEYIggacky5ilQDoADvAgALABQAiCCESp9tsqeAJQWAPRhMAAqxI6oAKIEIOg4FPZQIABi8gAeqAAmMPIQcCCwhDAAZvBgwFDy4ELg0FW5BQByWmZ0cF2Y9oiEju4UdDRpGdl5+e4ADMGhAkA\"\n        }}>{`TypeScript Example`}</a></p>\n    </blockquote>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}