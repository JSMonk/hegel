{"version":3,"sources":["webpack://lib/webpack/bootstrap","webpack://lib/../node_modules/@babel/parser/lib/index.js","webpack://lib/../node_modules/@hegel/core/checking/index.js","webpack://lib/../node_modules/@hegel/core/index.js","webpack://lib/../node_modules/@hegel/core/inference/equals-refinement.js","webpack://lib/../node_modules/@hegel/core/inference/error-type.js","webpack://lib/../node_modules/@hegel/core/inference/function-type.js","webpack://lib/../node_modules/@hegel/core/inference/in-operator.js","webpack://lib/../node_modules/@hegel/core/inference/index.js","webpack://lib/../node_modules/@hegel/core/inference/instanceof.js","webpack://lib/../node_modules/@hegel/core/inference/refinement.js","webpack://lib/../node_modules/@hegel/core/inference/switch-refinement.js","webpack://lib/../node_modules/@hegel/core/inference/tuple-type.js","webpack://lib/../node_modules/@hegel/core/inference/typeof.js","webpack://lib/../node_modules/@hegel/core/inference/variable-refinement.js","webpack://lib/../node_modules/@hegel/core/type-graph/call.js","webpack://lib/../node_modules/@hegel/core/type-graph/constants.js","webpack://lib/../node_modules/@hegel/core/type-graph/meta/call-meta.js","webpack://lib/../node_modules/@hegel/core/type-graph/meta/meta.js","webpack://lib/../node_modules/@hegel/core/type-graph/module-scope.js","webpack://lib/../node_modules/@hegel/core/type-graph/scope.js","webpack://lib/../node_modules/@hegel/core/type-graph/type-graph.js","webpack://lib/../node_modules/@hegel/core/type-graph/type-scope.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/bottom-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/class-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/collection-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/entries-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/exclude-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/function-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/generic-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/immutable-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/instance-of-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/intersection-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/keys-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/object-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/omit-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/partial-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/pick-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/property-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/refinemented-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/return-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/soft-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/strict-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/throws-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/tuple-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/type-of-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/type-var.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/union-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/types/values-type.js","webpack://lib/../node_modules/@hegel/core/type-graph/variable-info.js","webpack://lib/../node_modules/@hegel/core/type-graph/variable-scope.js","webpack://lib/../node_modules/@hegel/core/utils/class-utils.js","webpack://lib/../node_modules/@hegel/core/utils/common.js","webpack://lib/../node_modules/@hegel/core/utils/errors.js","webpack://lib/../node_modules/@hegel/core/utils/function-utils.js","webpack://lib/../node_modules/@hegel/core/utils/globals.js","webpack://lib/../node_modules/@hegel/core/utils/hierarchy.js","webpack://lib/../node_modules/@hegel/core/utils/ignore.js","webpack://lib/../node_modules/@hegel/core/utils/imports.js","webpack://lib/../node_modules/@hegel/core/utils/inference-utils.js","webpack://lib/../node_modules/@hegel/core/utils/nodes.js","webpack://lib/../node_modules/@hegel/core/utils/operators.js","webpack://lib/../node_modules/@hegel/core/utils/scope-utils.js","webpack://lib/../node_modules/@hegel/core/utils/throwable.js","webpack://lib/../node_modules/@hegel/core/utils/traverse.js","webpack://lib/../node_modules/@hegel/core/utils/type-utils.js","webpack://lib/../node_modules/@hegel/core/utils/utility-types.js","webpack://lib/../node_modules/@hegel/core/utils/variable-utils.js","webpack://lib/../src/docs/try/components/hegel.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,0BAA0B;AAC1B;AACA;AACA,GAAG;AACH,6BAA6B;AAC7B;AACA;AACA,GAAG;AACH,+BAA+B;AAC/B;AACA;AACA,GAAG;AACH,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,wBAAwB;AACxB;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,iCAAiC;AACjC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,uCAAuC;AAC1D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wDAAwD,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,uCAAuC;AAC5D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kLAAkL;AAClL,gGAAgG,MAAM;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,mFAAmF;AACnF,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,SAAS,QAAQ,EAAE;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,4DAA4D,2EAA2E,yDAAyD,uEAAuE;AACvQ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iFAAiF,SAAS,GAAG,WAAW;AACxG;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC,oCAAoC;AACpC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iEAAiE;AACjE;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sCAAsC,YAAY;AAClD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,oBAAoB;AAC3C;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,sBAAsB,gCAAgC;AACtD;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL,uBAAuB,+BAA+B;AACtD;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX,+EAA+E,oCAAoC;AACnH;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,WAAW;AACX,gFAAgF,qCAAqC;AACrH;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kCAAkC,EAAE;AACpC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,CAAC;;AAED;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qIAAqI,EAAE;AACvI;;AAEA;AACA,gJAAgJ,EAAE;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,0BAA0B;AACxF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,YAAY;AACrD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,OAAO;AAC5D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qDAAqD,oBAAoB;AACzE;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,oEAAoE,KAAK;AAChF;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,wFAAwF,iBAAiB;AAChH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yCAAyC,YAAY;AACrD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2EAA2E,YAAY;AACvF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,UAAU;;AAEpC;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,6DAA6D,+BAA+B;AAC5F;AACA,gEAAgE;AAChE;AACA;;AAEA;;AAEA;AACA,yDAAyD,6BAA6B;AACtF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,sBAAsB,sBAAsB;AAC5C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iFAAiF,cAAc;AAC/F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6EAA6E,yBAAyB;AACtG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,8BAA8B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,iCAAiC;AAC9F;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,8CAA8C,QAAQ;AACtD;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,6DAA6D,+BAA+B;AAC5F;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT,kFAAkF,oCAAoC;AACtH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,2DAA2D,+BAA+B;AAC1F;AACA;AACA;AACA,KAAK;AACL,uDAAuD,6BAA6B;AACpF;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mFAAmF,yBAAyB;AAC5G;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,+CAA+C,0BAA0B;AACzE;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA,wEAAwE;AACxE,+DAA+D;AAC/D;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACj+Ya;;AAEb;AACA;AACA,CAAC;;AAED,cAAc,mBAAO,CAAC,oEAAiB;;AAEvC;;AAEA,YAAY,mBAAO,CAAC,sFAA0B;;AAE9C,eAAe,mBAAO,CAAC,8FAA8B;;AAErD,gBAAgB,mBAAO,CAAC,8FAA8B;;AAEtD,iBAAiB,mBAAO,CAAC,sFAA0B;;AAEnD,iBAAiB,mBAAO,CAAC,kGAAgC;;AAEzD,iBAAiB,mBAAO,CAAC,kGAAgC;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EA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uDAAuD;AACvD,8DAA8D,oCAAoC;AAClG;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,2DAA2D;;AAE3D;AACA;;AAEA;AACA;AACA;;AAEA,kDAAkD;AAClD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;;AAEA,iBAAiB,2BAA2B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qDAAqD;AACrD;AACA;;AAEA;AACA,4DAA4D;;AAE5D;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,qCAAqC;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA;;AAEA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,iBAAiB,6BAA6B;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mCAAmC;;AAEnC;;AAEA;AACA;AACA,GAAG;AACH,mBAAmB,kBAAkB;AACrC;AACA;AACA;;AAEA,iBAAiB,kBAAkB;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;;AAEA;;AAEA,iBAAiB,6BAA6B;AAC9C;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sGAAsG;;AAEtG;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;;AAEA,qBAAqB,iBAAiB;AACtC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,gCAAgC;AACjD;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;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C,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;AACA;AACA,GAAG,EAAE;;;AAGL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,EAAE;;;AAGL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sFAAsF;;;AAGtF;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,oCAAoC,mCAAmC;AACvE;;AAEA,sFAAsF;;;AAGtF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,EAAE;;;AAGL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,EAAE;;;AAGL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,yDAAyD;AACzD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,S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A;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;;AAGP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,4GAA4G;AAC5G;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,8CAA8C;;AAErD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,kEAAkE;;AAElE,4DAA4D;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,2CAA2C;;AAE7I,4DAA4D;AAC5D;;AAEA;AACA,qFAAqF,sBAAsB;AAC3G;AACA,uMAAuM,aAAa;AACpN;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,OAAO,wCAAwC;AAC/C,gEAAgE,sBAAsB,KAAK,uDAAuD;AAClJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA,OAAO;;AAEP,0DAA0D,GAAG,KAAK;;AAElE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2KAA2K,oBAAoB,qDAAqD,oBAAoB;AACxQ;;AAEA;AACA,kCAAkC;;AAElC;AACA,sNAAsN;AACtN;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT,oDAAoD;;AAEpD;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qEAAqE,qCAAqC,2DAA2D,iCAAiC;AACtM;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,WAAW;AAChB;AACA,KAAK;AACL;AACA;AACA;;AAEA,wGAAwG;AACxG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA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ACpF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oFAAoF;AACpF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sTAAsT;;AAEtT;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D;;AAE/D;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,gEAAgE,aAAa,8CAA8C,kCAAkC;AAC7J;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,+DAA+D,uCAAuC;AACtG;;AAEA;AACA;;AAEA;;AAEA,0EAA0E;;AAE1E;;AAEA;AACA,qEAAqE;AACrE;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mHAAmH;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,oC;;;;;;;;;;;;AC5lBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,0EAAc;;AAElC,aAAa,mBAAO,CAAC,gEAAS;;AAE9B,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,uD;;;;;;;;;;;;AClEa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,oBAAoB,mBAAO,CAAC,sFAAiB;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,aAAa,GAAG,iCAAiC,IAAI,EAAE,gBAAgB,EAAE,uCAAuC,OAAO;AACrI;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD;AACjD;;AAEA;AACA,iDAAiD;AACjD;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA,gCAAgC,wBAAwB;AACxD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kHAAkH;AAClH,yGAAyG;AACzG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kC;;;;;;;;;;;;ACjTa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,kBAAkB,mB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AEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,UAAU,EAAE,YAAY,EAAE,SAAS,MAAM,WAAW,EAAE,WAAW;AAC/E;;AAEA;AACA,cAAc,UAAU,EAAE,YAAY,EAAE,SAAS,MAAM,kCAAkC,EAAE,WAAW;AACtG;;AAEA;AACA;AACA;;AAEA;AACA,iDAAiD,oCAAoC,IAAI,EAAE,UAAU,2BAA2B,OAAO,EAAE,eAAe,EAAE,oBAAoB,0BAA0B,OAAO,OAAO;AACtN;;AAEA;AACA,eAAe,0BAA0B,EAAE;AAC3C,mDAAmD;;AAEnD;AACA;AACA,kCAAkC,EAAE;AACpC;AACA,KAAK,qCAAqC,EAAE,wBAAwB;AACpE;;AAEA;AACA,6CAA6C,oBAAoB;AACjE;;AAEA;AACA;AACA;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,iHAAiH;AACjH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO,QAAQ;;AAEf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kDAAkD;;AAElD;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,4E;;;;;;;;;;;;AC3Xa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,sCAAsC,uCAAuC,gBAAgB;;AAE7F,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,KAAK;AACL;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,aAAa,GAAG,kCAAkC,EAAE,gDAAgD,EAAE,gCAAgC;AACpJ;;AAEA;AACA,4CAA4C,IAAI,EAAE,UAAU,2BAA2B,OAAO,EAAE,sCAAsC;AACtI;;AAEA,6BAA6B;AAC7B;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C,kBAAkB,mDAAmD,sBAAsB,YAAY,kBAAkB;AACtK;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,+CAA+C,uBAAuB,qCAAqC,yBAAyB,gCAAgC,gBAAgB,qBAAqB,GAAG;AAC5M;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;;;AAGP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kC;;;;;;;;;;;;ACpVa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C,sBAAsB,mBAAO,CAAC,0FAAmB;;AAEjD,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA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B,yCAAyC;AACzC;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;;AAGP;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,sE;;;;;;;;;;;;AChYa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,0FAA0F,KAAK;AAC/F,wFAAwF;AACxF;;AAEA;;AAEA,sB;;;;;;;;;;;;AC/Ea;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C,oBAAoB,mBAAO,CAAC,iFAAkB;;AAE9C,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wDAAwD;;AAExD;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,4B;;;;;;;;;;;;AC/Ea;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA,yFAAyF,KAAK;AAC9F,wFAAwF;AACxF;;AAEA;;AAEA,sB;;;;;;;;;;;;AC/Ea;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,gBAAgB,mBAAO,CAAC,8EAAa;;AAErC,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C,oBAAoB,mBAAO,CAAC,iFAAkB;;AAE9C,sBAAsB,mBAAO,CAAC,0FAAmB;;AAEjD,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT,gGAAgG,gBAAgB;AAChH;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,mIAAmI,gBAAgB,EAAE,sCAAsC;AAC3L;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,OAAO;AACP,uDAAuD,gEAAgE,IAAI;AAC3H;AACA,SAAS;AACT,OAAO;AACP,mDAAmD;AACnD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD,OAAO;AACP,gDAAgD,aAAa,uBAAuB,mBAAmB;AACvG;AACA;;AAEA;AACA;AACA;AACA,iDAAiD;AACjD,OAAO;AACP,gDAAgD,aAAa,uBAAuB,mBAAmB;AACvG;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4CAA4C,aAAa,uBAAuB,mBAAmB;AACnG;;AAEA;;AAEA,sC;;;;;;;;;;;;AC1Ka;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,sC;;;;;;;;;;;;AC/Da;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C,oBAAoB,mBAAO,CAAC,sFAAiB;;AAE7C,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,kC;;;;;;;;;;;;ACxEa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,sB;;;;;;;;;;;;AClEa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,0B;;;;;;;;;;;;AClEa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,uBAAuB;AAC7C;;AAEA,6BAA6B;AAC7B;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA,0B;;;;;;;;;;;;AChFa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,iBAAiB,mBAAO,CAAC,gFAAc;;AAEvC,kBAAkB,mBAAO,CAAC,kFAAe;;AAEzC,sBAAsB,mBAAO,CAAC,0FAAmB;;AAEjD,sCAAsC,uCAAuC,gBAAgB;;AAE7F,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;;AAEA,mBAAmB,YAAY;AAC/B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,0BAA0B,EAAE,6BAA6B,IAAI,EAAE,UAAU,2BAA2B,OAAO,EAAE,8DAA8D,OAAO,EAAE,wBAAwB;AAC3N;;AAEA,6BAA6B;AAC7B,+EAA+E;AAC/E,mGAAmG;AACnG;AACA,iBAAiB;AACjB;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,mF;;;;;;;;;;;;AC1Pa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,eAAe,mBAAO,CAAC,4EAAY;;AAEnC,iBAAiB,mBAAO,CAAC,2EAAe;;AAExC,mBAAmB,mBAAO,CAAC,oFAAgB;;AAE3C;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA,uBAAuB;AACvB;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,0B;;;;;;;;;;;;AC7Ca;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,oEAAQ;;AAE5B,iBAAiB,mBAAO,CAAC,yEAAc;;AAEvC,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,6BAA6B;AAC7B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD;;AAElD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,kD;;;;;;;;;;;;ACxNa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,uEAAoB;;AAE1C;;AAEA,iBAAiB,mBAAO,CAAC,yEAAc;;AAEvC,sCAAsC,uCAAuC,gBAAgB;;AAE7F,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;;AAEA,6BAA6B;AAC7B,sDAAsD;;AAEtD;;AAEA;AACA,0CAA0C,aAAa;AACvD;;AAEA;AACA;;AAEA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA,KAAK;AACL;AACA;AACA;;AAEA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,6BAA6B;AAC7B;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE,QAAQ;AAC9E;AACA;AACA;AACA,KAAK;AACL,uCAAuC,QAAQ;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;AACA;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CA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,8FAA8F,EAAE;AAChG;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,qGAAqG;AACrG;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD,uBAAuB;AACzE;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,8FAA8F;;AAE9F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yVAAyV,KAAK;AAC9V;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB,KAAK;AAClF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,4CAA4C,GAAG,KAAK;AACpD;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA,wEAAwE;;AAExE;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iDAAiD;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG,4CAA4C;;AAE/C;AACA;AACA,GAAG;;AAEH,2BAA2B,GAAG;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mFAAmF;AACnF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qEAAqE,QAAQ;AAC7E;AACA,KAAK;AACL;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,sDAAsD,IAAI;AAC1D;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA,gCAAgC;;AAEhC;AACA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;;AAEA,6BAA6B,yBAAyB,GAAG,uBAAuB;AAChF,C;;;;;;;;;;;;AC1Za;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,2DAAS;;AAE9B;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F,wEAAwE,oBAAoB,GAAG,sBAAsB;;AAErH;;AAEA;AACA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,GAAG;;;AAGH;AACA,C;;;;;;;;;;;;ACrFa;;AAEb;AACA;AACA,CAAC;;AAED,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4C;;;;;;;;;;;;ACzCa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,2DAAS;;AAE9B;;AAEA,YAAY,mBAAO,CAAC,oFAAyB;;AAE7C,YAAY,mBAAO,CAAC,sFAA0B;;AAE9C,eAAe,mBAAO,CAAC,8FAA8B;;AAErD,iBAAiB,mBAAO,CAAC,kGAAgC;;AAEzD,mBAAmB,mBAAO,CAAC,sGAAkC;;AAE7D,oBAAoB,mBAAO,CAAC,4FAA6B;;AAEzD,qBAAqB,mBAAO,CAAC,8FAA8B;;AAE3D,qBAAqB,mBAAO,CAAC,6EAAkB;;AAE/C,iBAAiB,mBAAO,CAAC,oEAAc;;AAEvC,mBAAmB,mBAAO,CAAC,0FAA4B;;AAEvD,oBAAoB,mBAAO,CAAC,wGAAmC;;AAE/D,cAAc,mBAAO,CAAC,6DAAU;;AAEhC,kBAAkB,mBAAO,CAAC,8EAAsB;;AAEhD,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA,yEAAyE;AACzE;AACA,8GAA8G;AAC9G;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,2LAA2L;;AAE3L;AACA;AACA;;AAEA,8DAA8D;AAC9D,C;;;;;;;;;;;;ACpMa;;AAEb;AACA;AACA,CAAC;;AAED,YAAY,mBAAO,CAAC,sFAA0B;;AAE9C,iBAAiB,mBAAO,CAAC,kGAAgC;;AAEzD,oBAAoB,mBAAO,CAAC,4FAA6B;;AAEzD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iC;;;;;;;;;;;;AC5Ba;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,sFAA0B;;AAE9C,eAAe,mBAAO,CAAC,8FAA8B;;AAErD,iBAAiB,mBAAO,CAAC,kGAAgC;;AAEzD,iBAAiB,mBAAO,CAAC,sFAA0B;;AAEnD,iBAAiB,mBAAO,CAAC,kGAAgC;;AAEzD,kBAAkB,mBAAO,CAAC,oGAAiC;;AAE3D,mBAAmB,mBAAO,CAAC,sGAAkC;;AAE7D,oBAAoB,mBAAO,CAAC,wGAAmC;;AAE/D,sBAAsB,mBAAO,CAAC,4GAAqC;;AAEnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+EAA+E;AAC/E;AACA,uFAAuF;AACvF;AACA;AACA,6FAA6F;AAC7F;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uFAAuF;AACvF;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;AC1Ea;;AAEb;AACA;AACA,CAAC;;AAED,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,EAAE;;AAEP;AACA;;AAEA;;AAEA,wC;;;;;;;;;;;;ACpCa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,aAAa,mBAAO,CAAC,2DAAS;;AAE9B;;AAEA,cAAc,mBAAO,CAAC,6DAAU;;AAEhC;;AAEA,YAAY,mBAAO,CAAC,oFAAyB;;AAE7C,YAAY,mBAAO,CAAC,sFAA0B;;AAE9C,kBAAkB,mBAAO,CAAC,oGAAiC;;AAE3D,oBAAoB,mBAAO,CAAC,4FAA6B;;AAEzD,mBAAmB,mBAAO,CAAC,0FAA4B;;AAEvD,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,4CAA4C,wBAAwB,YAAY,kBAAkB;AAClG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;;AAGL;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA,uBAAuB,+BAA+B;AACtD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uEAAuE,kBAAkB;AACzF;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,+BAA+B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACnIa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,kEAAgB;;AAErC;;AAEA,iBAAiB,mBAAO,CAAC,kGAAgC;;AAEzD,iBAAiB,mBAAO,CAAC,qEAAc;;AAEvC,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA,iFAAiF;;;AAGjF;;AAEA,0EAA0E,kGAAkG;AAC5K;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACnDa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;AC1Ma;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,oFAAyB;;AAE7C,YAAY,mBAAO,CAAC,sFAA0B;;AAE9C,eAAe,mBAAO,CAAC,8FAA8B;;AAErD,iBAAiB,mBAAO,CAAC,sFAA0B;;AAEnD,iBAAiB,mBAAO,CAAC,kGAAgC;;AAEzD,kBAAkB,mBAAO,CAAC,oGAAiC;;AAE3D,mBAAmB,mBAAO,CAAC,sGAAkC;;AAE7D,kBAAkB,mBAAO,CAAC,oGAAiC;;AAE3D,oBAAoB,mBAAO,CAAC,wGAAmC;;AAE/D,oBAAoB,mBAAO,CAAC,4FAA6B;;AAEzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG,6CAA6C;AAChD;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,0DAA0D;AAC7D;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG,0DAA0D;AAC7D;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG;AACH;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA;AACA,GAAG,iDAAiD;AACpD;AACA,GAAG,iDAAiD;AACpD;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG,sDAAsD,kGAAkG,kGAAkG;AAC7P;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA,mC;;;;;;;;;;;;ACtMa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,kEAAgB;;AAErC;;AAEA,iBAAiB,mBAAO,CAAC,sFAA0B;;AAEnD,mBAAmB,mBAAO,CAAC,0FAA4B;;AAEvD,oBAAoB,mBAAO,CAAC,4FAA6B;;AAEzD,qBAAqB,mBAAO,CAAC,8FAA8B;;AAE3D,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,C;;;;;;;;;;;;ACxJa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,YAAY,mBAAO,CAAC,sFAA0B;;AAE9C,mBAAmB,mBAAO,CAAC,0FAA4B;;AAEvD,oBAAoB,mBAAO,CAAC,4FAA6B;;AAEzD,qBAAqB,mBAAO,CAAC,8FAA8B;;AAE3D;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;;AC1Ca;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,aAAa,mBAAO,CAAC,2DAAS;;AAE9B;;AAEA,cAAc,mBAAO,CAAC,oEAAiB;;AAEvC,cAAc,mBAAO,CAAC,6DAAU;;AAEhC;;AAEA,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,8BAA8B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA;AACA;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ACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,4CAA4C,yBAAyB,+BAA+B,wBAAwB;AAC5H;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;;AAEA;AACA,yEAAyE,YAAY;AACrF;;AAEA;AACA;AACA,2CAA2C,wBAAwB;AACnE;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,sDAAsD,yBAAyB;AAC/E;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA,oDAAoD,yBAAyB;AAC7E;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,gEAAgE;AAChE;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,mHAAmH;AACnH,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA,2DAA2D;AAC3D,kEAAkE,oCAAoC;AACtG;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,+DAA+D;;AAE/D;;AAEA;AACA;AACA;;AAEA,sDAAsD;AACtD;;AAEA;AACA;;AAEA,gEAAgE,EAAE,KAAK,4CAA4C,EAAE,KAAK;AAC1H;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,mFAAmF;AACnF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2DAA2D,0BAA0B;AACrF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,C;;;;;;;;;;;;AC1pBa;;AAEb;AACA;AACA,CAAC;;AAED,gBAAgB,mBAAO,CAAC,gGAA+B;;AAEvD,gBAAgB,mBAAO,CAAC,gGAA+B;;AAEvD,gBAAgB,mBAAO,CAAC,gGAA+B;;AAEvD,gBAAgB,mBAAO,CAAC,gGAA+B;;AAEvD,iBAAiB,mBAAO,CAAC,kGAAgC;;AAEzD,kBAAk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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAAe,uBAA8B,qCAAqC,uBAAuB,QAAQ,sDAAsD,8BAA8B,QAAQ,gCAAgC,wDAAY,mCAAmC,sMAAsM,sDAAsD,yBAAyB,sEAAsE,GAAG,sMAAsM,sDAAsD,yBAAyB,sEAAsE,GAAG,oBAA2B,+CAA+C,gCAAgC,+DAA+D,qCAAqC,2DAA2D,4BAA4B,yBAAyB,oDAAoD,iEAAiE,kCAAkC,0BAA0B,sBAAsB,sCAAsC,4MAA4M,uDAAuD,yBAAyB,uEAAuE,GAAG,4MAA4M,uDAAuD,yBAAyB,uEAAuE,GAAU,uDAAuD,gBAAgB,kBAAkB,qEAAiB,2BAA2B,mBAAmB,oBAAoB,cAAc,cAAc,4PAA4P,+DAA+D,yBAAyB,+EAA+E,GAAG,4PAA4P,+DAA+D,yBAAyB,+EAA+E,GAAU,0CAA0C,cAAc,IAAI,WAAW,2DAAK,6BAA6B,wBAAwB,qEAAiB,cAAc,iCAAiC,SAAS,gBAAgB,sDAAU,sBAAsB,UAAU,GAAG,OAAO,gBAAgB,MAAM,+CAA+C,EAAE,gBAAgB,yCAAyC,oLAAoL,mDAAmD,yBAAyB,mEAAmE,GAAG,oLAAoL,mDAAmD,yBAAyB,mEAAmE,GAAG,qCAAqC,oBAAoB,OAAO,oEAAoE,wBAAwB,kBAAkB,OAAO,4CAA4C,MAAM,yCAAyC,EAAE,OAAO,gCAAgC,MAAM;AACnmJ,kCAAkC,KAAK,sBAAsB,cAAc,+BAA+B,sCAAsC,wEAAwE,OAAO,sCAAsC,kBAAkB,aAAa,sBAAsB,GAAG,cAAc,aAAa,YAAY,cAAc,0BAA0B,sBAAsB,qBAAqB,aAAa,qBAAqB,GAAG,IAAI,EAAE,aAAa,4BAA4B,E","file":"46a19dcf20ef5c066f12.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"../node_modules/workerize-loader/dist/rpc-worker-loader.js!../node_modules/gatsby/dist/utils/babel-loader.js?!../node_modules/gatsby/dist/utils/babel-loader.js?!../src/docs/try/components/hegel.js\");\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst beforeExpr = true;\nconst startsExpr = true;\nconst isLoop = true;\nconst isAssign = true;\nconst prefix = true;\nconst postfix = true;\nclass TokenType {\n  constructor(label, conf = {}) {\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.rightAssociative = !!conf.rightAssociative;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop != null ? conf.binop : null;\n    this.updateContext = null;\n  }\n\n}\nconst keywords = new Map();\n\nfunction createKeyword(name, options = {}) {\n  options.keyword = name;\n  const token = new TokenType(name, options);\n  keywords.set(name, token);\n  return token;\n}\n\nfunction createBinop(name, binop) {\n  return new TokenType(name, {\n    beforeExpr,\n    binop\n  });\n}\n\nconst types = {\n  num: new TokenType(\"num\", {\n    startsExpr\n  }),\n  bigint: new TokenType(\"bigint\", {\n    startsExpr\n  }),\n  regexp: new TokenType(\"regexp\", {\n    startsExpr\n  }),\n  string: new TokenType(\"string\", {\n    startsExpr\n  }),\n  name: new TokenType(\"name\", {\n    startsExpr\n  }),\n  eof: new TokenType(\"eof\"),\n  bracketL: new TokenType(\"[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketHashL: new TokenType(\"#[\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketBarL: new TokenType(\"[|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  bracketR: new TokenType(\"]\"),\n  bracketBarR: new TokenType(\"|]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceBarL: new TokenType(\"{|\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceHashL: new TokenType(\"#{\", {\n    beforeExpr,\n    startsExpr\n  }),\n  braceR: new TokenType(\"}\"),\n  braceBarR: new TokenType(\"|}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr,\n    startsExpr\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", {\n    beforeExpr\n  }),\n  semi: new TokenType(\";\", {\n    beforeExpr\n  }),\n  colon: new TokenType(\":\", {\n    beforeExpr\n  }),\n  doubleColon: new TokenType(\"::\", {\n    beforeExpr\n  }),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", {\n    beforeExpr\n  }),\n  questionDot: new TokenType(\"?.\"),\n  arrow: new TokenType(\"=>\", {\n    beforeExpr\n  }),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", {\n    beforeExpr\n  }),\n  backQuote: new TokenType(\"`\", {\n    startsExpr\n  }),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr,\n    startsExpr\n  }),\n  at: new TokenType(\"@\"),\n  hash: new TokenType(\"#\", {\n    startsExpr\n  }),\n  interpreterDirective: new TokenType(\"#!...\"),\n  eq: new TokenType(\"=\", {\n    beforeExpr,\n    isAssign\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr,\n    isAssign\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix,\n    postfix,\n    startsExpr\n  }),\n  bang: new TokenType(\"!\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  tilde: new TokenType(\"~\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  pipeline: createBinop(\"|>\", 0),\n  nullishCoalescing: createBinop(\"??\", 1),\n  logicalOR: createBinop(\"||\", 1),\n  logicalAND: createBinop(\"&&\", 2),\n  bitwiseOR: createBinop(\"|\", 3),\n  bitwiseXOR: createBinop(\"^\", 4),\n  bitwiseAND: createBinop(\"&\", 5),\n  equality: createBinop(\"==/!=/===/!==\", 6),\n  relational: createBinop(\"</>/<=/>=\", 7),\n  bitShift: createBinop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr,\n    binop: 9,\n    prefix,\n    startsExpr\n  }),\n  modulo: new TokenType(\"%\", {\n    beforeExpr,\n    binop: 10,\n    startsExpr\n  }),\n  star: createBinop(\"*\", 10),\n  slash: createBinop(\"/\", 10),\n  exponent: new TokenType(\"**\", {\n    beforeExpr,\n    binop: 11,\n    rightAssociative: true\n  }),\n  _break: createKeyword(\"break\"),\n  _case: createKeyword(\"case\", {\n    beforeExpr\n  }),\n  _catch: createKeyword(\"catch\"),\n  _continue: createKeyword(\"continue\"),\n  _debugger: createKeyword(\"debugger\"),\n  _default: createKeyword(\"default\", {\n    beforeExpr\n  }),\n  _do: createKeyword(\"do\", {\n    isLoop,\n    beforeExpr\n  }),\n  _else: createKeyword(\"else\", {\n    beforeExpr\n  }),\n  _finally: createKeyword(\"finally\"),\n  _for: createKeyword(\"for\", {\n    isLoop\n  }),\n  _function: createKeyword(\"function\", {\n    startsExpr\n  }),\n  _if: createKeyword(\"if\"),\n  _return: createKeyword(\"return\", {\n    beforeExpr\n  }),\n  _switch: createKeyword(\"switch\"),\n  _throw: createKeyword(\"throw\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _try: createKeyword(\"try\"),\n  _var: createKeyword(\"var\"),\n  _const: createKeyword(\"const\"),\n  _while: createKeyword(\"while\", {\n    isLoop\n  }),\n  _with: createKeyword(\"with\"),\n  _new: createKeyword(\"new\", {\n    beforeExpr,\n    startsExpr\n  }),\n  _this: createKeyword(\"this\", {\n    startsExpr\n  }),\n  _super: createKeyword(\"super\", {\n    startsExpr\n  }),\n  _class: createKeyword(\"class\", {\n    startsExpr\n  }),\n  _extends: createKeyword(\"extends\", {\n    beforeExpr\n  }),\n  _export: createKeyword(\"export\"),\n  _import: createKeyword(\"import\", {\n    startsExpr\n  }),\n  _null: createKeyword(\"null\", {\n    startsExpr\n  }),\n  _true: createKeyword(\"true\", {\n    startsExpr\n  }),\n  _false: createKeyword(\"false\", {\n    startsExpr\n  }),\n  _in: createKeyword(\"in\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _instanceof: createKeyword(\"instanceof\", {\n    beforeExpr,\n    binop: 7\n  }),\n  _typeof: createKeyword(\"typeof\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _void: createKeyword(\"void\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  }),\n  _delete: createKeyword(\"delete\", {\n    beforeExpr,\n    prefix,\n    startsExpr\n  })\n};\n\nconst SCOPE_OTHER = 0b00000000,\n      SCOPE_PROGRAM = 0b00000001,\n      SCOPE_FUNCTION = 0b00000010,\n      SCOPE_ARROW = 0b00000100,\n      SCOPE_SIMPLE_CATCH = 0b00001000,\n      SCOPE_SUPER = 0b00010000,\n      SCOPE_DIRECT_SUPER = 0b00100000,\n      SCOPE_CLASS = 0b01000000,\n      SCOPE_TS_MODULE = 0b10000000,\n      SCOPE_VAR = SCOPE_PROGRAM | SCOPE_FUNCTION | SCOPE_TS_MODULE;\nconst BIND_KIND_VALUE = 0b00000000001,\n      BIND_KIND_TYPE = 0b00000000010,\n      BIND_SCOPE_VAR = 0b00000000100,\n      BIND_SCOPE_LEXICAL = 0b00000001000,\n      BIND_SCOPE_FUNCTION = 0b00000010000,\n      BIND_FLAGS_NONE = 0b00001000000,\n      BIND_FLAGS_CLASS = 0b00010000000,\n      BIND_FLAGS_TS_ENUM = 0b00100000000,\n      BIND_FLAGS_TS_CONST_ENUM = 0b01000000000,\n      BIND_FLAGS_TS_EXPORT_ONLY = 0b10000000000;\nconst BIND_CLASS = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_CLASS,\n      BIND_LEXICAL = BIND_KIND_VALUE | 0 | BIND_SCOPE_LEXICAL | 0,\n      BIND_VAR = BIND_KIND_VALUE | 0 | BIND_SCOPE_VAR | 0,\n      BIND_FUNCTION = BIND_KIND_VALUE | 0 | BIND_SCOPE_FUNCTION | 0,\n      BIND_TS_INTERFACE = 0 | BIND_KIND_TYPE | 0 | BIND_FLAGS_CLASS,\n      BIND_TS_TYPE = 0 | BIND_KIND_TYPE | 0 | 0,\n      BIND_TS_ENUM = BIND_KIND_VALUE | BIND_KIND_TYPE | BIND_SCOPE_LEXICAL | BIND_FLAGS_TS_ENUM,\n      BIND_TS_AMBIENT = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY,\n      BIND_NONE = 0 | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_OUTSIDE = BIND_KIND_VALUE | 0 | 0 | BIND_FLAGS_NONE,\n      BIND_TS_CONST_ENUM = BIND_TS_ENUM | BIND_FLAGS_TS_CONST_ENUM,\n      BIND_TS_NAMESPACE = 0 | 0 | 0 | BIND_FLAGS_TS_EXPORT_ONLY;\nconst CLASS_ELEMENT_FLAG_STATIC = 0b100,\n      CLASS_ELEMENT_KIND_GETTER = 0b010,\n      CLASS_ELEMENT_KIND_SETTER = 0b001,\n      CLASS_ELEMENT_KIND_ACCESSOR = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_KIND_SETTER;\nconst CLASS_ELEMENT_STATIC_GETTER = CLASS_ELEMENT_KIND_GETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_STATIC_SETTER = CLASS_ELEMENT_KIND_SETTER | CLASS_ELEMENT_FLAG_STATIC,\n      CLASS_ELEMENT_INSTANCE_GETTER = CLASS_ELEMENT_KIND_GETTER,\n      CLASS_ELEMENT_INSTANCE_SETTER = CLASS_ELEMENT_KIND_SETTER,\n      CLASS_ELEMENT_OTHER = 0;\n\nconst lineBreak = /\\r\\n?|[\\n\\u2028\\u2029]/;\nconst lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code) {\n  switch (code) {\n    case 10:\n    case 13:\n    case 8232:\n    case 8233:\n      return true;\n\n    default:\n      return false;\n  }\n}\nconst skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nfunction isWhitespace(code) {\n  switch (code) {\n    case 0x0009:\n    case 0x000b:\n    case 0x000c:\n    case 32:\n    case 160:\n    case 5760:\n    case 0x2000:\n    case 0x2001:\n    case 0x2002:\n    case 0x2003:\n    case 0x2004:\n    case 0x2005:\n    case 0x2006:\n    case 0x2007:\n    case 0x2008:\n    case 0x2009:\n    case 0x200a:\n    case 0x202f:\n    case 0x205f:\n    case 0x3000:\n    case 0xfeff:\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nclass Position {\n  constructor(line, col) {\n    this.line = line;\n    this.column = col;\n  }\n\n}\nclass SourceLocation {\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n}\nfunction getLineInfo(input, offset) {\n  let line = 1;\n  let lineStart = 0;\n  let match;\n  lineBreakG.lastIndex = 0;\n\n  while ((match = lineBreakG.exec(input)) && match.index < offset) {\n    line++;\n    lineStart = lineBreakG.lastIndex;\n  }\n\n  return new Position(line, offset - lineStart);\n}\n\nclass BaseParser {\n  constructor() {\n    this.sawUnambiguousESM = false;\n    this.ambiguousScriptDifferentAst = false;\n  }\n\n  hasPlugin(name) {\n    return this.plugins.has(name);\n  }\n\n  getPluginOption(plugin, name) {\n    if (this.hasPlugin(plugin)) return this.plugins.get(plugin)[name];\n  }\n\n}\n\nfunction last(stack) {\n  return stack[stack.length - 1];\n}\n\nclass CommentsParser extends BaseParser {\n  addComment(comment) {\n    if (this.filename) comment.loc.filename = this.filename;\n    this.state.trailingComments.push(comment);\n    this.state.leadingComments.push(comment);\n  }\n\n  adjustCommentsAfterTrailingComma(node, elements, takeAllComments) {\n    if (this.state.leadingComments.length === 0) {\n      return;\n    }\n\n    let lastElement = null;\n    let i = elements.length;\n\n    while (lastElement === null && i > 0) {\n      lastElement = elements[--i];\n    }\n\n    if (lastElement === null) {\n      return;\n    }\n\n    for (let j = 0; j < this.state.leadingComments.length; j++) {\n      if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n        this.state.leadingComments.splice(j, 1);\n        j--;\n      }\n    }\n\n    const newTrailingComments = [];\n\n    for (let i = 0; i < this.state.leadingComments.length; i++) {\n      const leadingComment = this.state.leadingComments[i];\n\n      if (leadingComment.end < node.end) {\n        newTrailingComments.push(leadingComment);\n\n        if (!takeAllComments) {\n          this.state.leadingComments.splice(i, 1);\n          i--;\n        }\n      } else {\n        if (node.trailingComments === undefined) {\n          node.trailingComments = [];\n        }\n\n        node.trailingComments.push(leadingComment);\n      }\n    }\n\n    if (takeAllComments) this.state.leadingComments = [];\n\n    if (newTrailingComments.length > 0) {\n      lastElement.trailingComments = newTrailingComments;\n    } else if (lastElement.trailingComments !== undefined) {\n      lastElement.trailingComments = [];\n    }\n  }\n\n  processComment(node) {\n    if (node.type === \"Program\" && node.body.length > 0) return;\n    const stack = this.state.commentStack;\n    let firstChild, lastChild, trailingComments, i, j;\n\n    if (this.state.trailingComments.length > 0) {\n      if (this.state.trailingComments[0].start >= node.end) {\n        trailingComments = this.state.trailingComments;\n        this.state.trailingComments = [];\n      } else {\n        this.state.trailingComments.length = 0;\n      }\n    } else if (stack.length > 0) {\n      const lastInStack = last(stack);\n\n      if (lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {\n        trailingComments = lastInStack.trailingComments;\n        delete lastInStack.trailingComments;\n      }\n    }\n\n    if (stack.length > 0 && last(stack).start >= node.start) {\n      firstChild = stack.pop();\n    }\n\n    while (stack.length > 0 && last(stack).start >= node.start) {\n      lastChild = stack.pop();\n    }\n\n    if (!lastChild && firstChild) lastChild = firstChild;\n\n    if (firstChild) {\n      switch (node.type) {\n        case \"ObjectExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties);\n          break;\n\n        case \"ObjectPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.properties, true);\n          break;\n\n        case \"CallExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.arguments);\n          break;\n\n        case \"ArrayExpression\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements);\n          break;\n\n        case \"ArrayPattern\":\n          this.adjustCommentsAfterTrailingComma(node, node.elements, true);\n          break;\n      }\n    } else if (this.state.commentPreviousNode && (this.state.commentPreviousNode.type === \"ImportSpecifier\" && node.type !== \"ImportSpecifier\" || this.state.commentPreviousNode.type === \"ExportSpecifier\" && node.type !== \"ExportSpecifier\")) {\n      this.adjustCommentsAfterTrailingComma(node, [this.state.commentPreviousNode]);\n    }\n\n    if (lastChild) {\n      if (lastChild.leadingComments) {\n        if (lastChild !== node && lastChild.leadingComments.length > 0 && last(lastChild.leadingComments).end <= node.start) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        } else {\n          for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {\n            if (lastChild.leadingComments[i].end <= node.start) {\n              node.leadingComments = lastChild.leadingComments.splice(0, i + 1);\n              break;\n            }\n          }\n        }\n      }\n    } else if (this.state.leadingComments.length > 0) {\n      if (last(this.state.leadingComments).end <= node.start) {\n        if (this.state.commentPreviousNode) {\n          for (j = 0; j < this.state.leadingComments.length; j++) {\n            if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {\n              this.state.leadingComments.splice(j, 1);\n              j--;\n            }\n          }\n        }\n\n        if (this.state.leadingComments.length > 0) {\n          node.leadingComments = this.state.leadingComments;\n          this.state.leadingComments = [];\n        }\n      } else {\n        for (i = 0; i < this.state.leadingComments.length; i++) {\n          if (this.state.leadingComments[i].end > node.start) {\n            break;\n          }\n        }\n\n        const leadingComments = this.state.leadingComments.slice(0, i);\n\n        if (leadingComments.length) {\n          node.leadingComments = leadingComments;\n        }\n\n        trailingComments = this.state.leadingComments.slice(i);\n\n        if (trailingComments.length === 0) {\n          trailingComments = null;\n        }\n      }\n    }\n\n    this.state.commentPreviousNode = node;\n\n    if (trailingComments) {\n      if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {\n        node.innerComments = trailingComments;\n      } else {\n        node.trailingComments = trailingComments;\n      }\n    }\n\n    stack.push(node);\n  }\n\n}\n\nconst Errors = Object.freeze({\n  ArgumentsDisallowedInInitializer: \"'arguments' is not allowed in class field initializer\",\n  AsyncFunctionInSingleStatementContext: \"Async functions can only be declared at the top level or inside a block\",\n  AwaitBindingIdentifier: \"Can not use 'await' as identifier inside an async function\",\n  AwaitExpressionFormalParameter: \"await is not allowed in async function parameters\",\n  AwaitNotInAsyncFunction: \"Can not use keyword 'await' outside an async function\",\n  BadGetterArity: \"getter must not have any formal parameters\",\n  BadSetterArity: \"setter must have exactly one formal parameter\",\n  BadSetterRestParameter: \"setter function argument must not be a rest parameter\",\n  ConstructorClassField: \"Classes may not have a field named 'constructor'\",\n  ConstructorClassPrivateField: \"Classes may not have a private field named '#constructor'\",\n  ConstructorIsAccessor: \"Class constructor may not be an accessor\",\n  ConstructorIsAsync: \"Constructor can't be an async function\",\n  ConstructorIsGenerator: \"Constructor can't be a generator\",\n  DeclarationMissingInitializer: \"%0 require an initialization value\",\n  DecoratorBeforeExport: \"Decorators must be placed *before* the 'export' keyword. You can set the 'decoratorsBeforeExport' option to false to use the 'export @decorator class {}' syntax\",\n  DecoratorConstructor: \"Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?\",\n  DecoratorExportClass: \"Using the export keyword between a decorator and a class is not allowed. Please use `export @dec class` instead.\",\n  DecoratorSemicolon: \"Decorators must not be followed by a semicolon\",\n  DeletePrivateField: \"Deleting a private field is not allowed\",\n  DestructureNamedImport: \"ES2015 named imports do not destructure. Use another statement for destructuring after the import.\",\n  DuplicateConstructor: \"Duplicate constructor in the same class\",\n  DuplicateDefaultExport: \"Only one default export allowed per module.\",\n  DuplicateExport: \"`%0` has already been exported. Exported identifiers must be unique.\",\n  DuplicateProto: \"Redefinition of __proto__ property\",\n  DuplicateRegExpFlags: \"Duplicate regular expression flag\",\n  ElementAfterRest: \"Rest element must be last element\",\n  EscapedCharNotAnIdentifier: \"Invalid Unicode escape\",\n  ForInOfLoopInitializer: \"%0 loop variable declaration may not have an initializer\",\n  GeneratorInSingleStatementContext: \"Generators can only be declared at the top level or inside a block\",\n  IllegalBreakContinue: \"Unsyntactic %0\",\n  IllegalLanguageModeDirective: \"Illegal 'use strict' directive in function with non-simple parameter list\",\n  IllegalReturn: \"'return' outside of function\",\n  ImportCallArgumentTrailingComma: \"Trailing comma is disallowed inside import(...) arguments\",\n  ImportCallArity: \"import() requires exactly one argument\",\n  ImportCallArityLtOne: \"Dynamic imports require a parameter: import('a.js')\",\n  ImportCallNotNewExpression: \"Cannot use new with import(...)\",\n  ImportCallSpreadArgument: \"... is not allowed in import()\",\n  ImportMetaOutsideModule: `import.meta may appear only with 'sourceType: \"module\"'`,\n  ImportOutsideModule: `'import' and 'export' may appear only with 'sourceType: \"module\"'`,\n  InvalidCodePoint: \"Code point out of bounds\",\n  InvalidDigit: \"Expected number in radix %0\",\n  InvalidEscapeSequence: \"Bad character escape sequence\",\n  InvalidEscapeSequenceTemplate: \"Invalid escape sequence in template\",\n  InvalidEscapedReservedWord: \"Escape sequence in keyword %0\",\n  InvalidIdentifier: \"Invalid identifier %0\",\n  InvalidLhs: \"Invalid left-hand side in %0\",\n  InvalidLhsBinding: \"Binding invalid left-hand side in %0\",\n  InvalidNumber: \"Invalid number\",\n  InvalidOrUnexpectedToken: \"Unexpected character '%0'\",\n  InvalidParenthesizedAssignment: \"Invalid parenthesized assignment pattern\",\n  InvalidPrivateFieldResolution: \"Private name #%0 is not defined\",\n  InvalidPropertyBindingPattern: \"Binding member expression\",\n  InvalidRestAssignmentPattern: \"Invalid rest operator's argument\",\n  LabelRedeclaration: \"Label '%0' is already declared\",\n  LetInLexicalBinding: \"'let' is not allowed to be used as a name in 'let' or 'const' declarations.\",\n  MalformedRegExpFlags: \"Invalid regular expression flag\",\n  MissingClassName: \"A class name is required\",\n  MissingEqInAssignment: \"Only '=' operator can be used for specifying default value.\",\n  MissingUnicodeEscape: \"Expecting Unicode escape sequence \\\\uXXXX\",\n  MixingCoalesceWithLogical: \"Nullish coalescing operator(??) requires parens when mixing with logical operators\",\n  ModuleExportUndefined: \"Export '%0' is not defined\",\n  MultipleDefaultsInSwitch: \"Multiple default clauses\",\n  NewlineAfterThrow: \"Illegal newline after throw\",\n  NoCatchOrFinally: \"Missing catch or finally clause\",\n  NumberIdentifier: \"Identifier directly after number\",\n  NumericSeparatorInEscapeSequence: \"Numeric separators are not allowed inside unicode escape sequences or hex escape sequences\",\n  ObsoleteAwaitStar: \"await* has been removed from the async functions proposal. Use Promise.all() instead.\",\n  OptionalChainingNoNew: \"constructors in/after an Optional Chain are not allowed\",\n  OptionalChainingNoTemplate: \"Tagged Template Literals are not allowed in optionalChain\",\n  ParamDupe: \"Argument name clash\",\n  PatternHasAccessor: \"Object pattern can't contain getter or setter\",\n  PatternHasMethod: \"Object pattern can't contain methods\",\n  PipelineBodyNoArrow: 'Unexpected arrow \"=>\" after pipeline body; arrow function in pipeline body must be parenthesized',\n  PipelineBodySequenceExpression: \"Pipeline body may not be a comma-separated sequence expression\",\n  PipelineHeadSequenceExpression: \"Pipeline head should not be a comma-separated sequence expression\",\n  PipelineTopicUnused: \"Pipeline is in topic style but does not use topic reference\",\n  PrimaryTopicNotAllowed: \"Topic reference was used in a lexical context without topic binding\",\n  PrimaryTopicRequiresSmartPipeline: \"Primary Topic Reference found but pipelineOperator not passed 'smart' for 'proposal' option.\",\n  PrivateNameRedeclaration: \"Duplicate private name #%0\",\n  RecordExpressionBarIncorrectEndSyntaxType: \"Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionBarIncorrectStartSyntaxType: \"Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  RecordExpressionHashIncorrectStartSyntaxType: \"Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  RestTrailingComma: \"Unexpected trailing comma after rest element\",\n  SloppyFunction: \"In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement\",\n  StaticPrototype: \"Classes may not have static property named prototype\",\n  StrictDelete: \"Deleting local variable in strict mode\",\n  StrictEvalArguments: \"Assigning to '%0' in strict mode\",\n  StrictEvalArgumentsBinding: \"Binding '%0' in strict mode\",\n  StrictFunction: \"In strict mode code, functions can only be declared at top level or inside a block\",\n  StrictOctalLiteral: \"Legacy octal literals are not allowed in strict mode\",\n  StrictWith: \"'with' in strict mode\",\n  SuperNotAllowed: \"super() is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?\",\n  SuperPrivateField: \"Private fields can't be accessed on super\",\n  TrailingDecorator: \"Decorators must be attached to a class element\",\n  TupleExpressionBarIncorrectEndSyntaxType: \"Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionBarIncorrectStartSyntaxType: \"Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'\",\n  TupleExpressionHashIncorrectStartSyntaxType: \"Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'\",\n  UnexpectedArgumentPlaceholder: \"Unexpected argument placeholder\",\n  UnexpectedAwaitAfterPipelineBody: 'Unexpected \"await\" after pipeline body; await must have parentheses in minimal proposal',\n  UnexpectedDigitAfterHash: \"Unexpected digit after hash token\",\n  UnexpectedImportExport: \"'import' and 'export' may only appear at the top level\",\n  UnexpectedKeyword: \"Unexpected keyword '%0'\",\n  UnexpectedLeadingDecorator: \"Leading decorators must be attached to a class declaration\",\n  UnexpectedLexicalDeclaration: \"Lexical declaration cannot appear in a single-statement context\",\n  UnexpectedNewTarget: \"new.target can only be used in functions\",\n  UnexpectedNumericSeparator: \"A numeric separator is only allowed between two digits\",\n  UnexpectedPrivateField: \"Private names can only be used as the name of a class element (i.e. class C { #p = 42; #m() {} } )\\n or a property of member expression (i.e. this.#p).\",\n  UnexpectedReservedWord: \"Unexpected reserved word '%0'\",\n  UnexpectedSuper: \"super is only allowed in object methods and classes\",\n  UnexpectedToken: \"Unexpected token '%'\",\n  UnexpectedTokenUnaryExponentiation: \"Illegal expression. Wrap left hand side or entire exponentiation in parentheses.\",\n  UnsupportedBind: \"Binding should be performed on object property.\",\n  UnsupportedDecoratorExport: \"A decorated export must export a class declaration\",\n  UnsupportedDefaultExport: \"Only expressions, functions or classes are allowed as the `default` export.\",\n  UnsupportedImport: \"import can only be used in import() or import.meta\",\n  UnsupportedMetaProperty: \"The only valid meta property for %0 is %0.%1\",\n  UnsupportedParameterDecorator: \"Decorators cannot be used to decorate parameters\",\n  UnsupportedPropertyDecorator: \"Decorators cannot be used to decorate object literal properties\",\n  UnsupportedSuper: \"super can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop])\",\n  UnterminatedComment: \"Unterminated comment\",\n  UnterminatedRegExp: \"Unterminated regular expression\",\n  UnterminatedString: \"Unterminated string constant\",\n  UnterminatedTemplate: \"Unterminated template\",\n  VarRedeclaration: \"Identifier '%0' has already been declared\",\n  YieldBindingIdentifier: \"Can not use 'yield' as identifier inside a generator\",\n  YieldInParameter: \"yield is not allowed in generator parameters\",\n  ZeroDigitNumericSeparator: \"Numeric separator can not be used after leading 0\"\n});\nclass LocationParser extends CommentsParser {\n  getLocationForPosition(pos) {\n    let loc;\n    if (pos === this.state.start) loc = this.state.startLoc;else if (pos === this.state.lastTokStart) loc = this.state.lastTokStartLoc;else if (pos === this.state.end) loc = this.state.endLoc;else if (pos === this.state.lastTokEnd) loc = this.state.lastTokEndLoc;else loc = getLineInfo(this.input, pos);\n    return loc;\n  }\n\n  raise(pos, errorTemplate, ...params) {\n    return this.raiseWithData(pos, undefined, errorTemplate, ...params);\n  }\n\n  raiseWithData(pos, data, errorTemplate, ...params) {\n    const loc = this.getLocationForPosition(pos);\n    const message = errorTemplate.replace(/%(\\d+)/g, (_, i) => params[i]) + ` (${loc.line}:${loc.column})`;\n    return this._raise(Object.assign({\n      loc,\n      pos\n    }, data), message);\n  }\n\n  _raise(errorContext, message) {\n    const err = new SyntaxError(message);\n    Object.assign(err, errorContext);\n\n    if (this.options.errorRecovery) {\n      if (!this.isLookahead) this.state.errors.push(err);\n      return err;\n    } else {\n      throw err;\n    }\n  }\n\n}\n\nfunction isSimpleProperty(node) {\n  return node != null && node.type === \"Property\" && node.kind === \"init\" && node.method === false;\n}\n\nvar estree = (superClass => class extends superClass {\n  estreeParseRegExpLiteral({\n    pattern,\n    flags\n  }) {\n    let regex = null;\n\n    try {\n      regex = new RegExp(pattern, flags);\n    } catch (e) {}\n\n    const node = this.estreeParseLiteral(regex);\n    node.regex = {\n      pattern,\n      flags\n    };\n    return node;\n  }\n\n  estreeParseBigIntLiteral(value) {\n    const bigInt = typeof BigInt !== \"undefined\" ? BigInt(value) : null;\n    const node = this.estreeParseLiteral(bigInt);\n    node.bigint = String(node.value || value);\n    return node;\n  }\n\n  estreeParseLiteral(value) {\n    return this.parseLiteral(value, \"Literal\");\n  }\n\n  directiveToStmt(directive) {\n    const directiveLiteral = directive.value;\n    const stmt = this.startNodeAt(directive.start, directive.loc.start);\n    const expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);\n    expression.value = directiveLiteral.value;\n    expression.raw = directiveLiteral.extra.raw;\n    stmt.expression = this.finishNodeAt(expression, \"Literal\", directiveLiteral.end, directiveLiteral.loc.end);\n    stmt.directive = directiveLiteral.extra.raw.slice(1, -1);\n    return this.finishNodeAt(stmt, \"ExpressionStatement\", directive.end, directive.loc.end);\n  }\n\n  initFunction(node, isAsync) {\n    super.initFunction(node, isAsync);\n    node.expression = false;\n  }\n\n  checkDeclaration(node) {\n    if (isSimpleProperty(node)) {\n      this.checkDeclaration(node.value);\n    } else {\n      super.checkDeclaration(node);\n    }\n  }\n\n  checkGetterSetterParams(method) {\n    const prop = method;\n    const paramCount = prop.kind === \"get\" ? 0 : 1;\n    const start = prop.start;\n\n    if (prop.value.params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, Errors.BadGetterArity);\n      } else {\n        this.raise(start, Errors.BadSetterArity);\n      }\n    } else if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n      this.raise(start, Errors.BadSetterRestParameter);\n    }\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding) {\n    switch (expr.type) {\n      case \"ObjectPattern\":\n        expr.properties.forEach(prop => {\n          this.checkLVal(prop.type === \"Property\" ? prop.value : prop, bindingType, checkClashes, \"object destructuring pattern\", disallowLetBinding);\n        });\n        break;\n\n      default:\n        super.checkLVal(expr, bindingType, checkClashes, contextDescription, disallowLetBinding);\n    }\n  }\n\n  checkDuplicatedProto(prop, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || prop.computed || prop.method || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n    if (name === \"__proto__\" && prop.kind === \"init\") {\n      if (protoRef.used) {\n        if (refExpressionErrors && refExpressionErrors.doubleProto === -1) {\n          refExpressionErrors.doubleProto = key.start;\n        } else {\n          this.raise(key.start, Errors.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"Literal\" && typeof stmt.expression.value === \"string\" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);\n  }\n\n  stmtToDirective(stmt) {\n    const directive = super.stmtToDirective(stmt);\n    const value = stmt.expression.value;\n    directive.value.value = value;\n    return directive;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end) {\n    super.parseBlockBody(node, allowDirectives, topLevel, end);\n    const directiveStatements = node.directives.map(d => this.directiveToStmt(d));\n    node.body = directiveStatements.concat(node.body);\n    delete node.directives;\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true);\n\n    if (method.typeParameters) {\n      method.value.typeParameters = method.typeParameters;\n      delete method.typeParameters;\n    }\n\n    classBody.body.push(method);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    switch (this.state.type) {\n      case types.num:\n      case types.string:\n        return this.estreeParseLiteral(this.state.value);\n\n      case types.regexp:\n        return this.estreeParseRegExpLiteral(this.state.value);\n\n      case types.bigint:\n        return this.estreeParseBigIntLiteral(this.state.value);\n\n      case types._null:\n        return this.estreeParseLiteral(null);\n\n      case types._true:\n        return this.estreeParseLiteral(true);\n\n      case types._false:\n        return this.estreeParseLiteral(false);\n\n      default:\n        return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    const node = super.parseLiteral(value, type, startPos, startLoc);\n    node.raw = node.extra.raw;\n    delete node.extra;\n    return node;\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    super.parseFunctionBody(node, allowExpression, isMethod);\n    node.expression = node.body.type !== \"BlockStatement\";\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    let funcNode = this.startNode();\n    funcNode.kind = node.kind;\n    funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);\n    funcNode.type = \"FunctionExpression\";\n    delete funcNode.kind;\n    node.value = funcNode;\n    type = type === \"ClassMethod\" ? \"MethodDefinition\" : type;\n    return this.finishNode(node, type);\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {\n    const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc);\n\n    if (node) {\n      node.type = \"Property\";\n      if (node.kind === \"method\") node.kind = \"init\";\n      node.shorthand = false;\n    }\n\n    return node;\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    const node = super.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n\n    if (node) {\n      node.kind = \"init\";\n      node.type = \"Property\";\n    }\n\n    return node;\n  }\n\n  toAssignable(node) {\n    if (isSimpleProperty(node)) {\n      this.toAssignable(node.value);\n      return node;\n    }\n\n    return super.toAssignable(node);\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast) {\n    if (prop.kind === \"get\" || prop.kind === \"set\") {\n      throw this.raise(prop.key.start, Errors.PatternHasAccessor);\n    } else if (prop.method) {\n      throw this.raise(prop.key.start, Errors.PatternHasMethod);\n    } else {\n      super.toAssignableObjectExpressionProp(prop, isLast);\n    }\n  }\n\n  finishCallExpression(node, optional) {\n    super.finishCallExpression(node, optional);\n\n    if (node.callee.type === \"Import\") {\n      node.type = \"ImportExpression\";\n      node.source = node.arguments[0];\n      delete node.arguments;\n      delete node.callee;\n    }\n\n    return node;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    if (!exprList) {\n      return;\n    }\n\n    super.toReferencedListDeep(exprList, isParenthesizedExpr);\n  }\n\n  parseExport(node) {\n    super.parseExport(node);\n\n    switch (node.type) {\n      case \"ExportAllDeclaration\":\n        node.exported = null;\n        break;\n\n      case \"ExportNamedDeclaration\":\n        if (node.specifiers.length === 1 && node.specifiers[0].type === \"ExportNamespaceSpecifier\") {\n          node.type = \"ExportAllDeclaration\";\n          node.exported = node.specifiers[0].exported;\n          delete node.specifiers;\n        }\n\n        break;\n    }\n\n    return node;\n  }\n\n});\n\nclass TokContext {\n  constructor(token, isExpr, preserveSpace, override) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n  }\n\n}\nconst types$1 = {\n  braceStatement: new TokContext(\"{\", false),\n  braceExpression: new TokContext(\"{\", true),\n  templateQuasi: new TokContext(\"${\", false),\n  parenStatement: new TokContext(\"(\", false),\n  parenExpression: new TokContext(\"(\", true),\n  template: new TokContext(\"`\", true, true, p => p.readTmplToken()),\n  functionExpression: new TokContext(\"function\", true),\n  functionStatement: new TokContext(\"function\", false)\n};\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.state.context.length === 1) {\n    this.state.exprAllowed = true;\n    return;\n  }\n\n  let out = this.state.context.pop();\n\n  if (out === types$1.braceStatement && this.curContext().token === \"function\") {\n    out = this.state.context.pop();\n  }\n\n  this.state.exprAllowed = !out.isExpr;\n};\n\ntypes.name.updateContext = function (prevType) {\n  let allowed = false;\n\n  if (prevType !== types.dot) {\n    if (this.state.value === \"of\" && !this.state.exprAllowed && prevType !== types._function && prevType !== types._class || this.state.value === \"yield\" && this.prodParam.hasYield) {\n      allowed = true;\n    }\n  }\n\n  this.state.exprAllowed = allowed;\n\n  if (this.state.isIterator) {\n    this.state.isIterator = false;\n  }\n};\n\ntypes.braceL.updateContext = function (prevType) {\n  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function () {\n  this.state.context.push(types$1.templateQuasi);\n  this.state.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function (prevType) {\n  const statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);\n  this.state.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function () {};\n\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType === types.dot || prevType === types.questionDot) ; else if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !(prevType === types._return && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.state.context.push(types$1.functionExpression);\n  } else {\n    this.state.context.push(types$1.functionStatement);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.template) {\n    this.state.context.pop();\n  } else {\n    this.state.context.push(types$1.template);\n  }\n\n  this.state.exprAllowed = false;\n};\n\ntypes.star.updateContext = function () {\n  this.state.exprAllowed = false;\n};\n\nlet nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08c7\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d04-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31bf\\u31f0-\\u31ff\\u3400-\\u4dbf\\u4e00-\\u9ffc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7ca\\ua7f5-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab69\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nlet nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b55-\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d81-\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1abf\\u1ac0\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua82c\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nconst nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nconst nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\nconst astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 107, 20, 28, 22, 13, 52, 76, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 230, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 190, 0, 80, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8952, 286, 50, 2, 18, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 2357, 44, 11, 6, 17, 0, 370, 43, 1301, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42717, 35, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938];\nconst astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 154, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 262, 6, 10, 9, 419, 13, 1495, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];\n\nfunction isInAstralSet(code, set) {\n  let pos = 0x10000;\n\n  for (let i = 0, length = set.length; i < length; i += 2) {\n    pos += set[i];\n    if (pos > code) return false;\n    pos += set[i + 1];\n    if (pos >= code) return true;\n  }\n\n  return false;\n}\n\nfunction isIdentifierStart(code) {\n  if (code < 65) return code === 36;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\nfunction isIdentifierChar(code) {\n  if (code < 48) return code === 36;\n  if (code < 58) return true;\n  if (code < 65) return false;\n  if (code <= 90) return true;\n  if (code < 97) return code === 95;\n  if (code <= 122) return true;\n\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\nconst reservedWords = {\n  keyword: [\"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\", \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"const\", \"while\", \"with\", \"new\", \"this\", \"super\", \"class\", \"extends\", \"export\", \"import\", \"null\", \"true\", \"false\", \"in\", \"instanceof\", \"typeof\", \"void\", \"delete\"],\n  strict: [\"implements\", \"interface\", \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\"],\n  strictBind: [\"eval\", \"arguments\"]\n};\nconst keywords$1 = new Set(reservedWords.keyword);\nconst reservedWordsStrictSet = new Set(reservedWords.strict);\nconst reservedWordsStrictBindSet = new Set(reservedWords.strictBind);\nfunction isReservedWord(word, inModule) {\n  return inModule && word === \"await\" || word === \"enum\";\n}\nfunction isStrictReservedWord(word, inModule) {\n  return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);\n}\nfunction isStrictBindOnlyReservedWord(word) {\n  return reservedWordsStrictBindSet.has(word);\n}\nfunction isStrictBindReservedWord(word, inModule) {\n  return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);\n}\nfunction isKeyword(word) {\n  return keywords$1.has(word);\n}\n\nconst keywordRelationalOperator = /^in(stanceof)?$/;\nfunction isIteratorStart(current, next) {\n  return current === 64 && next === 64;\n}\n\nconst reservedTypes = new Set([\"_\", \"any\", \"bool\", \"boolean\", \"empty\", \"extends\", \"false\", \"interface\", \"mixed\", \"null\", \"number\", \"static\", \"string\", \"true\", \"typeof\", \"void\"]);\nconst FlowErrors = Object.freeze({\n  AmbiguousConditionalArrow: \"Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.\",\n  AmbiguousDeclareModuleKind: \"Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module\",\n  AssignReservedType: \"Cannot overwrite reserved type %0\",\n  DeclareClassElement: \"The `declare` modifier can only appear on class fields.\",\n  DeclareClassFieldInitializer: \"Initializers are not allowed in fields with the `declare` modifier.\",\n  DuplicateDeclareModuleExports: \"Duplicate `declare module.exports` statement\",\n  EnumBooleanMemberNotInitialized: \"Boolean enum members need to be initialized. Use either `%0 = true,` or `%0 = false,` in enum `%1`.\",\n  EnumDuplicateMemberName: \"Enum member names need to be unique, but the name `%0` has already been used before in enum `%1`.\",\n  EnumInconsistentMemberValues: \"Enum `%0` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.\",\n  EnumInvalidExplicitType: \"Enum type `%1` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidExplicitTypeUnknownSupplied: \"Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `%0`.\",\n  EnumInvalidMemberInitializerPrimaryType: \"Enum `%0` has type `%2`, so the initializer of `%1` needs to be a %2 literal.\",\n  EnumInvalidMemberInitializerSymbolType: \"Symbol enum members cannot be initialized. Use `%1,` in enum `%0`.\",\n  EnumInvalidMemberInitializerUnknownType: \"The enum member initializer for `%1` needs to be a literal (either a boolean, number, or string) in enum `%0`.\",\n  EnumInvalidMemberName: \"Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `%0`, consider using `%1`, in enum `%2`.\",\n  EnumNumberMemberNotInitialized: \"Number enum members need to be initialized, e.g. `%1 = 1` in enum `%0`.\",\n  EnumStringMemberInconsistentlyInitailized: \"String enum members need to consistently either all use initializers, or use no initializers, in enum `%0`.\",\n  ImportTypeShorthandOnlyInPureImport: \"The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements\",\n  InexactInsideExact: \"Explicit inexact syntax cannot appear inside an explicit exact object type\",\n  InexactInsideNonObject: \"Explicit inexact syntax cannot appear in class or interface definitions\",\n  InexactVariance: \"Explicit inexact syntax cannot have variance\",\n  InvalidNonTypeImportInDeclareModule: \"Imports within a `declare module` body must always be `import type` or `import typeof`\",\n  MissingTypeParamDefault: \"Type parameter declaration needs a default, since a preceding type parameter declaration has a default.\",\n  NestedDeclareModule: \"`declare module` cannot be used inside another `declare module`\",\n  NestedFlowComment: \"Cannot have a flow comment inside another flow comment\",\n  OptionalBindingPattern: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  SpreadVariance: \"Spread properties cannot have variance\",\n  TypeBeforeInitializer: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  TypeCastInPattern: \"The type cast expression is expected to be wrapped with parenthesis\",\n  UnexpectedExplicitInexactInObject: \"Explicit inexact syntax must appear at the end of an inexact object\",\n  UnexpectedReservedType: \"Unexpected reserved type %0\",\n  UnexpectedReservedUnderscore: \"`_` is only allowed as a type argument to call or new\",\n  UnexpectedSpaceBetweenModuloChecks: \"Spaces between `%` and `checks` are not allowed here.\",\n  UnexpectedSpreadType: \"Spread operator cannot appear in class or interface definitions\",\n  UnexpectedSubtractionOperand: 'Unexpected token, expected \"number\" or \"bigint\"',\n  UnexpectedTokenAfterTypeParameter: \"Expected an arrow function after this type parameter declaration\",\n  UnsupportedDeclareExportKind: \"`declare export %0` is not supported. Use `%1` instead\",\n  UnsupportedStatementInDeclareModule: \"Only declares and type imports are allowed inside declare module\",\n  UnterminatedFlowComment: \"Unterminated flow-comment\"\n});\n\nfunction isEsModuleType(bodyElement) {\n  return bodyElement.type === \"DeclareExportAllDeclaration\" || bodyElement.type === \"DeclareExportDeclaration\" && (!bodyElement.declaration || bodyElement.declaration.type !== \"TypeAlias\" && bodyElement.declaration.type !== \"InterfaceDeclaration\");\n}\n\nfunction hasTypeImportKind(node) {\n  return node.importKind === \"type\" || node.importKind === \"typeof\";\n}\n\nfunction isMaybeDefaultImport(state) {\n  return (state.type === types.name || !!state.type.keyword) && state.value !== \"from\";\n}\n\nconst exportSuggestions = {\n  const: \"declare export var\",\n  let: \"declare export var\",\n  type: \"export type\",\n  interface: \"export interface\"\n};\n\nfunction partition(list, test) {\n  const list1 = [];\n  const list2 = [];\n\n  for (let i = 0; i < list.length; i++) {\n    (test(list[i], i, list) ? list1 : list2).push(list[i]);\n  }\n\n  return [list1, list2];\n}\n\nconst FLOW_PRAGMA_REGEX = /\\*?\\s*@((?:no)?flow)\\b/;\nvar flow = (superClass => class extends superClass {\n  constructor(options, input) {\n    super(options, input);\n    this.flowPragma = undefined;\n  }\n\n  shouldParseTypes() {\n    return this.getPluginOption(\"flow\", \"all\") || this.flowPragma === \"flow\";\n  }\n\n  shouldParseEnums() {\n    return !!this.getPluginOption(\"flow\", \"enums\");\n  }\n\n  finishToken(type, val) {\n    if (type !== types.string && type !== types.semi && type !== types.interpreterDirective) {\n      if (this.flowPragma === undefined) {\n        this.flowPragma = null;\n      }\n    }\n\n    return super.finishToken(type, val);\n  }\n\n  addComment(comment) {\n    if (this.flowPragma === undefined) {\n      const matches = FLOW_PRAGMA_REGEX.exec(comment.value);\n\n      if (!matches) ; else if (matches[1] === \"flow\") {\n        this.flowPragma = \"flow\";\n      } else if (matches[1] === \"noflow\") {\n        this.flowPragma = \"noflow\";\n      } else {\n        throw new Error(\"Unexpected flow pragma\");\n      }\n    }\n\n    return super.addComment(comment);\n  }\n\n  flowParseTypeInitialiser(tok) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(tok || types.colon);\n    const type = this.flowParseType();\n    this.state.inType = oldInType;\n    return type;\n  }\n\n  flowParsePredicate() {\n    const node = this.startNode();\n    const moduloLoc = this.state.startLoc;\n    const moduloPos = this.state.start;\n    this.expect(types.modulo);\n    const checksLoc = this.state.startLoc;\n    this.expectContextual(\"checks\");\n\n    if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {\n      this.raise(moduloPos, FlowErrors.UnexpectedSpaceBetweenModuloChecks);\n    }\n\n    if (this.eat(types.parenL)) {\n      node.value = this.parseExpression();\n      this.expect(types.parenR);\n      return this.finishNode(node, \"DeclaredPredicate\");\n    } else {\n      return this.finishNode(node, \"InferredPredicate\");\n    }\n  }\n\n  flowParseTypeAndPredicateInitialiser() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    this.expect(types.colon);\n    let type = null;\n    let predicate = null;\n\n    if (this.match(types.modulo)) {\n      this.state.inType = oldInType;\n      predicate = this.flowParsePredicate();\n    } else {\n      type = this.flowParseType();\n      this.state.inType = oldInType;\n\n      if (this.match(types.modulo)) {\n        predicate = this.flowParsePredicate();\n      }\n    }\n\n    return [type, predicate];\n  }\n\n  flowParseDeclareClass(node) {\n    this.next();\n    this.flowParseInterfaceish(node, true);\n    return this.finishNode(node, \"DeclareClass\");\n  }\n\n  flowParseDeclareFunction(node) {\n    this.next();\n    const id = node.id = this.parseIdentifier();\n    const typeNode = this.startNode();\n    const typeContainer = this.startNode();\n\n    if (this.isRelational(\"<\")) {\n      typeNode.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      typeNode.typeParameters = null;\n    }\n\n    this.expect(types.parenL);\n    const tmp = this.flowParseFunctionTypeParams();\n    typeNode.params = tmp.params;\n    typeNode.rest = tmp.rest;\n    this.expect(types.parenR);\n    [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n    typeContainer.typeAnnotation = this.finishNode(typeNode, \"FunctionTypeAnnotation\");\n    id.typeAnnotation = this.finishNode(typeContainer, \"TypeAnnotation\");\n    this.resetEndLocation(id);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareFunction\");\n  }\n\n  flowParseDeclare(node, insideModule) {\n    if (this.match(types._class)) {\n      return this.flowParseDeclareClass(node);\n    } else if (this.match(types._function)) {\n      return this.flowParseDeclareFunction(node);\n    } else if (this.match(types._var)) {\n      return this.flowParseDeclareVariable(node);\n    } else if (this.eatContextual(\"module\")) {\n      if (this.match(types.dot)) {\n        return this.flowParseDeclareModuleExports(node);\n      } else {\n        if (insideModule) {\n          this.raise(this.state.lastTokStart, FlowErrors.NestedDeclareModule);\n        }\n\n        return this.flowParseDeclareModule(node);\n      }\n    } else if (this.isContextual(\"type\")) {\n      return this.flowParseDeclareTypeAlias(node);\n    } else if (this.isContextual(\"opaque\")) {\n      return this.flowParseDeclareOpaqueType(node);\n    } else if (this.isContextual(\"interface\")) {\n      return this.flowParseDeclareInterface(node);\n    } else if (this.match(types._export)) {\n      return this.flowParseDeclareExportDeclaration(node, insideModule);\n    } else {\n      throw this.unexpected();\n    }\n  }\n\n  flowParseDeclareVariable(node) {\n    this.next();\n    node.id = this.flowParseTypeAnnotatableIdentifier(true);\n    this.scope.declareName(node.id.name, BIND_VAR, node.id.start);\n    this.semicolon();\n    return this.finishNode(node, \"DeclareVariable\");\n  }\n\n  flowParseDeclareModule(node) {\n    this.scope.enter(SCOPE_OTHER);\n\n    if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      node.id = this.parseIdentifier();\n    }\n\n    const bodyNode = node.body = this.startNode();\n    const body = bodyNode.body = [];\n    this.expect(types.braceL);\n\n    while (!this.match(types.braceR)) {\n      let bodyNode = this.startNode();\n\n      if (this.match(types._import)) {\n        this.next();\n\n        if (!this.isContextual(\"type\") && !this.match(types._typeof)) {\n          this.raise(this.state.lastTokStart, FlowErrors.InvalidNonTypeImportInDeclareModule);\n        }\n\n        this.parseImport(bodyNode);\n      } else {\n        this.expectContextual(\"declare\", FlowErrors.UnsupportedStatementInDeclareModule);\n        bodyNode = this.flowParseDeclare(bodyNode, true);\n      }\n\n      body.push(bodyNode);\n    }\n\n    this.scope.exit();\n    this.expect(types.braceR);\n    this.finishNode(bodyNode, \"BlockStatement\");\n    let kind = null;\n    let hasModuleExport = false;\n    body.forEach(bodyElement => {\n      if (isEsModuleType(bodyElement)) {\n        if (kind === \"CommonJS\") {\n          this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n        }\n\n        kind = \"ES\";\n      } else if (bodyElement.type === \"DeclareModuleExports\") {\n        if (hasModuleExport) {\n          this.raise(bodyElement.start, FlowErrors.DuplicateDeclareModuleExports);\n        }\n\n        if (kind === \"ES\") {\n          this.raise(bodyElement.start, FlowErrors.AmbiguousDeclareModuleKind);\n        }\n\n        kind = \"CommonJS\";\n        hasModuleExport = true;\n      }\n    });\n    node.kind = kind || \"CommonJS\";\n    return this.finishNode(node, \"DeclareModule\");\n  }\n\n  flowParseDeclareExportDeclaration(node, insideModule) {\n    this.expect(types._export);\n\n    if (this.eat(types._default)) {\n      if (this.match(types._function) || this.match(types._class)) {\n        node.declaration = this.flowParseDeclare(this.startNode());\n      } else {\n        node.declaration = this.flowParseType();\n        this.semicolon();\n      }\n\n      node.default = true;\n      return this.finishNode(node, \"DeclareExportDeclaration\");\n    } else {\n      if (this.match(types._const) || this.isLet() || (this.isContextual(\"type\") || this.isContextual(\"interface\")) && !insideModule) {\n        const label = this.state.value;\n        const suggestion = exportSuggestions[label];\n        throw this.raise(this.state.start, FlowErrors.UnsupportedDeclareExportKind, label, suggestion);\n      }\n\n      if (this.match(types._var) || this.match(types._function) || this.match(types._class) || this.isContextual(\"opaque\")) {\n          node.declaration = this.flowParseDeclare(this.startNode());\n          node.default = false;\n          return this.finishNode(node, \"DeclareExportDeclaration\");\n        } else if (this.match(types.star) || this.match(types.braceL) || this.isContextual(\"interface\") || this.isContextual(\"type\") || this.isContextual(\"opaque\")) {\n          node = this.parseExport(node);\n\n          if (node.type === \"ExportNamedDeclaration\") {\n            node.type = \"ExportDeclaration\";\n            node.default = false;\n            delete node.exportKind;\n          }\n\n          node.type = \"Declare\" + node.type;\n          return node;\n        }\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParseDeclareModuleExports(node) {\n    this.next();\n    this.expectContextual(\"exports\");\n    node.typeAnnotation = this.flowParseTypeAnnotation();\n    this.semicolon();\n    return this.finishNode(node, \"DeclareModuleExports\");\n  }\n\n  flowParseDeclareTypeAlias(node) {\n    this.next();\n    this.flowParseTypeAlias(node);\n    node.type = \"DeclareTypeAlias\";\n    return node;\n  }\n\n  flowParseDeclareOpaqueType(node) {\n    this.next();\n    this.flowParseOpaqueType(node, true);\n    node.type = \"DeclareOpaqueType\";\n    return node;\n  }\n\n  flowParseDeclareInterface(node) {\n    this.next();\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"DeclareInterface\");\n  }\n\n  flowParseInterfaceish(node, isClass = false) {\n    node.id = this.flowParseRestrictedIdentifier(!isClass, true);\n    this.scope.declareName(node.id.name, isClass ? BIND_FUNCTION : BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.extends = [];\n    node.implements = [];\n    node.mixins = [];\n\n    if (this.eat(types._extends)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (!isClass && this.eat(types.comma));\n    }\n\n    if (this.isContextual(\"mixins\")) {\n      this.next();\n\n      do {\n        node.mixins.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    if (this.isContextual(\"implements\")) {\n      this.next();\n\n      do {\n        node.implements.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: isClass,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: isClass,\n      allowInexact: false\n    });\n  }\n\n  flowParseInterfaceExtends() {\n    const node = this.startNode();\n    node.id = this.flowParseQualifiedTypeIdentifier();\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    } else {\n      node.typeParameters = null;\n    }\n\n    return this.finishNode(node, \"InterfaceExtends\");\n  }\n\n  flowParseInterface(node) {\n    this.flowParseInterfaceish(node);\n    return this.finishNode(node, \"InterfaceDeclaration\");\n  }\n\n  checkNotUnderscore(word) {\n    if (word === \"_\") {\n      this.raise(this.state.start, FlowErrors.UnexpectedReservedUnderscore);\n    }\n  }\n\n  checkReservedType(word, startLoc, declaration) {\n    if (!reservedTypes.has(word)) return;\n    this.raise(startLoc, declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, word);\n  }\n\n  flowParseRestrictedIdentifier(liberal, declaration) {\n    this.checkReservedType(this.state.value, this.state.start, declaration);\n    return this.parseIdentifier(liberal);\n  }\n\n  flowParseTypeAlias(node) {\n    node.id = this.flowParseRestrictedIdentifier(false, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.right = this.flowParseTypeInitialiser(types.eq);\n    this.semicolon();\n    return this.finishNode(node, \"TypeAlias\");\n  }\n\n  flowParseOpaqueType(node, declare) {\n    this.expectContextual(\"type\");\n    node.id = this.flowParseRestrictedIdentifier(true, true);\n    this.scope.declareName(node.id.name, BIND_LEXICAL, node.id.start);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    } else {\n      node.typeParameters = null;\n    }\n\n    node.supertype = null;\n\n    if (this.match(types.colon)) {\n      node.supertype = this.flowParseTypeInitialiser(types.colon);\n    }\n\n    node.impltype = null;\n\n    if (!declare) {\n      node.impltype = this.flowParseTypeInitialiser(types.eq);\n    }\n\n    this.semicolon();\n    return this.finishNode(node, \"OpaqueType\");\n  }\n\n  flowParseTypeParameter(requireDefault = false) {\n    const nodeStart = this.state.start;\n    const node = this.startNode();\n    const variance = this.flowParseVariance();\n    const ident = this.flowParseTypeAnnotatableIdentifier();\n    node.name = ident.name;\n    node.variance = variance;\n    node.bound = ident.typeAnnotation;\n\n    if (this.match(types.eq)) {\n      this.eat(types.eq);\n      node.default = this.flowParseType();\n    } else {\n      if (requireDefault) {\n        this.raise(nodeStart, FlowErrors.MissingTypeParamDefault);\n      }\n    }\n\n    return this.finishNode(node, \"TypeParameter\");\n  }\n\n  flowParseTypeParameterDeclaration() {\n    const oldInType = this.state.inType;\n    const node = this.startNode();\n    node.params = [];\n    this.state.inType = true;\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    let defaultRequired = false;\n\n    do {\n      const typeParameter = this.flowParseTypeParameter(defaultRequired);\n      node.params.push(typeParameter);\n\n      if (typeParameter.default) {\n        defaultRequired = true;\n      }\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    } while (!this.isRelational(\">\"));\n\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterDeclaration\");\n  }\n\n  flowParseTypeParameterInstantiation() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expectRelational(\"<\");\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n    this.state.noAnonFunctionType = false;\n\n    while (!this.isRelational(\">\")) {\n      node.params.push(this.flowParseType());\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    }\n\n    this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseTypeParameterInstantiationCallOrNew() {\n    const node = this.startNode();\n    const oldInType = this.state.inType;\n    node.params = [];\n    this.state.inType = true;\n    this.expectRelational(\"<\");\n\n    while (!this.isRelational(\">\")) {\n      node.params.push(this.flowParseTypeOrImplicitInstantiation());\n\n      if (!this.isRelational(\">\")) {\n        this.expect(types.comma);\n      }\n    }\n\n    this.expectRelational(\">\");\n    this.state.inType = oldInType;\n    return this.finishNode(node, \"TypeParameterInstantiation\");\n  }\n\n  flowParseInterfaceType() {\n    const node = this.startNode();\n    this.expectContextual(\"interface\");\n    node.extends = [];\n\n    if (this.eat(types._extends)) {\n      do {\n        node.extends.push(this.flowParseInterfaceExtends());\n      } while (this.eat(types.comma));\n    }\n\n    node.body = this.flowParseObjectType({\n      allowStatic: false,\n      allowExact: false,\n      allowSpread: false,\n      allowProto: false,\n      allowInexact: false\n    });\n    return this.finishNode(node, \"InterfaceTypeAnnotation\");\n  }\n\n  flowParseObjectPropertyKey() {\n    return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n  }\n\n  flowParseObjectTypeIndexer(node, isStatic, variance) {\n    node.static = isStatic;\n\n    if (this.lookahead().type === types.colon) {\n      node.id = this.flowParseObjectPropertyKey();\n      node.key = this.flowParseTypeInitialiser();\n    } else {\n      node.id = null;\n      node.key = this.flowParseType();\n    }\n\n    this.expect(types.bracketR);\n    node.value = this.flowParseTypeInitialiser();\n    node.variance = variance;\n    return this.finishNode(node, \"ObjectTypeIndexer\");\n  }\n\n  flowParseObjectTypeInternalSlot(node, isStatic) {\n    node.static = isStatic;\n    node.id = this.flowParseObjectPropertyKey();\n    this.expect(types.bracketR);\n    this.expect(types.bracketR);\n\n    if (this.isRelational(\"<\") || this.match(types.parenL)) {\n      node.method = true;\n      node.optional = false;\n      node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n    } else {\n      node.method = false;\n\n      if (this.eat(types.question)) {\n        node.optional = true;\n      }\n\n      node.value = this.flowParseTypeInitialiser();\n    }\n\n    return this.finishNode(node, \"ObjectTypeInternalSlot\");\n  }\n\n  flowParseObjectTypeMethodish(node) {\n    node.params = [];\n    node.rest = null;\n    node.typeParameters = null;\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    this.expect(types.parenL);\n\n    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n      node.params.push(this.flowParseFunctionTypeParam());\n\n      if (!this.match(types.parenR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    if (this.eat(types.ellipsis)) {\n      node.rest = this.flowParseFunctionTypeParam();\n    }\n\n    this.expect(types.parenR);\n    node.returnType = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"FunctionTypeAnnotation\");\n  }\n\n  flowParseObjectTypeCallProperty(node, isStatic) {\n    const valueNode = this.startNode();\n    node.static = isStatic;\n    node.value = this.flowParseObjectTypeMethodish(valueNode);\n    return this.finishNode(node, \"ObjectTypeCallProperty\");\n  }\n\n  flowParseObjectType({\n    allowStatic,\n    allowExact,\n    allowSpread,\n    allowProto,\n    allowInexact\n  }) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const nodeStart = this.startNode();\n    nodeStart.callProperties = [];\n    nodeStart.properties = [];\n    nodeStart.indexers = [];\n    nodeStart.internalSlots = [];\n    let endDelim;\n    let exact;\n    let inexact = false;\n\n    if (allowExact && this.match(types.braceBarL)) {\n      this.expect(types.braceBarL);\n      endDelim = types.braceBarR;\n      exact = true;\n    } else {\n      this.expect(types.braceL);\n      endDelim = types.braceR;\n      exact = false;\n    }\n\n    nodeStart.exact = exact;\n\n    while (!this.match(endDelim)) {\n      let isStatic = false;\n      let protoStart = null;\n      let inexactStart = null;\n      const node = this.startNode();\n\n      if (allowProto && this.isContextual(\"proto\")) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n          this.next();\n          protoStart = this.state.start;\n          allowStatic = false;\n        }\n      }\n\n      if (allowStatic && this.isContextual(\"static\")) {\n        const lookahead = this.lookahead();\n\n        if (lookahead.type !== types.colon && lookahead.type !== types.question) {\n          this.next();\n          isStatic = true;\n        }\n      }\n\n      const variance = this.flowParseVariance();\n\n      if (this.eat(types.bracketL)) {\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (this.eat(types.bracketL)) {\n          if (variance) {\n            this.unexpected(variance.start);\n          }\n\n          nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));\n        } else {\n          nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));\n        }\n      } else if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.unexpected(variance.start);\n        }\n\n        nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));\n      } else {\n        let kind = \"init\";\n\n        if (this.isContextual(\"get\") || this.isContextual(\"set\")) {\n          const lookahead = this.lookahead();\n\n          if (lookahead.type === types.name || lookahead.type === types.string || lookahead.type === types.num) {\n            kind = this.state.value;\n            this.next();\n          }\n        }\n\n        const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);\n\n        if (propOrInexact === null) {\n          inexact = true;\n          inexactStart = this.state.lastTokStart;\n        } else {\n          nodeStart.properties.push(propOrInexact);\n        }\n      }\n\n      this.flowObjectTypeSemicolon();\n\n      if (inexactStart && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n        this.raise(inexactStart, FlowErrors.UnexpectedExplicitInexactInObject);\n      }\n    }\n\n    this.expect(endDelim);\n\n    if (allowSpread) {\n      nodeStart.inexact = inexact;\n    }\n\n    const out = this.finishNode(nodeStart, \"ObjectTypeAnnotation\");\n    this.state.inType = oldInType;\n    return out;\n  }\n\n  flowParseObjectTypeProperty(node, isStatic, protoStart, variance, kind, allowSpread, allowInexact) {\n    if (this.eat(types.ellipsis)) {\n      const isInexactToken = this.match(types.comma) || this.match(types.semi) || this.match(types.braceR) || this.match(types.braceBarR);\n\n      if (isInexactToken) {\n        if (!allowSpread) {\n          this.raise(this.state.lastTokStart, FlowErrors.InexactInsideNonObject);\n        } else if (!allowInexact) {\n          this.raise(this.state.lastTokStart, FlowErrors.InexactInsideExact);\n        }\n\n        if (variance) {\n          this.raise(variance.start, FlowErrors.InexactVariance);\n        }\n\n        return null;\n      }\n\n      if (!allowSpread) {\n        this.raise(this.state.lastTokStart, FlowErrors.UnexpectedSpreadType);\n      }\n\n      if (protoStart != null) {\n        this.unexpected(protoStart);\n      }\n\n      if (variance) {\n        this.raise(variance.start, FlowErrors.SpreadVariance);\n      }\n\n      node.argument = this.flowParseType();\n      return this.finishNode(node, \"ObjectTypeSpreadProperty\");\n    } else {\n      node.key = this.flowParseObjectPropertyKey();\n      node.static = isStatic;\n      node.proto = protoStart != null;\n      node.kind = kind;\n      let optional = false;\n\n      if (this.isRelational(\"<\") || this.match(types.parenL)) {\n        node.method = true;\n\n        if (protoStart != null) {\n          this.unexpected(protoStart);\n        }\n\n        if (variance) {\n          this.unexpected(variance.start);\n        }\n\n        node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.start, node.loc.start));\n\n        if (kind === \"get\" || kind === \"set\") {\n          this.flowCheckGetterSetterParams(node);\n        }\n      } else {\n        if (kind !== \"init\") this.unexpected();\n        node.method = false;\n\n        if (this.eat(types.question)) {\n          optional = true;\n        }\n\n        node.value = this.flowParseTypeInitialiser();\n        node.variance = variance;\n      }\n\n      node.optional = optional;\n      return this.finishNode(node, \"ObjectTypeProperty\");\n    }\n  }\n\n  flowCheckGetterSetterParams(property) {\n    const paramCount = property.kind === \"get\" ? 0 : 1;\n    const start = property.start;\n    const length = property.value.params.length + (property.value.rest ? 1 : 0);\n\n    if (length !== paramCount) {\n      if (property.kind === \"get\") {\n        this.raise(start, Errors.BadGetterArity);\n      } else {\n        this.raise(start, Errors.BadSetterArity);\n      }\n    }\n\n    if (property.kind === \"set\" && property.value.rest) {\n      this.raise(start, Errors.BadSetterRestParameter);\n    }\n  }\n\n  flowObjectTypeSemicolon() {\n    if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {\n      this.unexpected();\n    }\n  }\n\n  flowParseQualifiedTypeIdentifier(startPos, startLoc, id) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    let node = id || this.flowParseRestrictedIdentifier(true);\n\n    while (this.eat(types.dot)) {\n      const node2 = this.startNodeAt(startPos, startLoc);\n      node2.qualification = node;\n      node2.id = this.flowParseRestrictedIdentifier(true);\n      node = this.finishNode(node2, \"QualifiedTypeIdentifier\");\n    }\n\n    return node;\n  }\n\n  flowParseGenericType(startPos, startLoc, id) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.typeParameters = null;\n    node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    return this.finishNode(node, \"GenericTypeAnnotation\");\n  }\n\n  flowParseTypeofType() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n    node.argument = this.flowParsePrimaryType();\n    return this.finishNode(node, \"TypeofTypeAnnotation\");\n  }\n\n  flowParseTupleType() {\n    const node = this.startNode();\n    node.types = [];\n    this.expect(types.bracketL);\n\n    while (this.state.pos < this.length && !this.match(types.bracketR)) {\n      node.types.push(this.flowParseType());\n      if (this.match(types.bracketR)) break;\n      this.expect(types.comma);\n    }\n\n    this.expect(types.bracketR);\n    return this.finishNode(node, \"TupleTypeAnnotation\");\n  }\n\n  flowParseFunctionTypeParam() {\n    let name = null;\n    let optional = false;\n    let typeAnnotation = null;\n    const node = this.startNode();\n    const lh = this.lookahead();\n\n    if (lh.type === types.colon || lh.type === types.question) {\n      name = this.parseIdentifier();\n\n      if (this.eat(types.question)) {\n        optional = true;\n      }\n\n      typeAnnotation = this.flowParseTypeInitialiser();\n    } else {\n      typeAnnotation = this.flowParseType();\n    }\n\n    node.name = name;\n    node.optional = optional;\n    node.typeAnnotation = typeAnnotation;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  reinterpretTypeAsFunctionTypeParam(type) {\n    const node = this.startNodeAt(type.start, type.loc.start);\n    node.name = null;\n    node.optional = false;\n    node.typeAnnotation = type;\n    return this.finishNode(node, \"FunctionTypeParam\");\n  }\n\n  flowParseFunctionTypeParams(params = []) {\n    let rest = null;\n\n    while (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n      params.push(this.flowParseFunctionTypeParam());\n\n      if (!this.match(types.parenR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    if (this.eat(types.ellipsis)) {\n      rest = this.flowParseFunctionTypeParam();\n    }\n\n    return {\n      params,\n      rest\n    };\n  }\n\n  flowIdentToTypeAnnotation(startPos, startLoc, node, id) {\n    switch (id.name) {\n      case \"any\":\n        return this.finishNode(node, \"AnyTypeAnnotation\");\n\n      case \"bool\":\n      case \"boolean\":\n        return this.finishNode(node, \"BooleanTypeAnnotation\");\n\n      case \"mixed\":\n        return this.finishNode(node, \"MixedTypeAnnotation\");\n\n      case \"empty\":\n        return this.finishNode(node, \"EmptyTypeAnnotation\");\n\n      case \"number\":\n        return this.finishNode(node, \"NumberTypeAnnotation\");\n\n      case \"string\":\n        return this.finishNode(node, \"StringTypeAnnotation\");\n\n      case \"symbol\":\n        return this.finishNode(node, \"SymbolTypeAnnotation\");\n\n      default:\n        this.checkNotUnderscore(id.name);\n        return this.flowParseGenericType(startPos, startLoc, id);\n    }\n  }\n\n  flowParsePrimaryType() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const node = this.startNode();\n    let tmp;\n    let type;\n    let isGroupedType = false;\n    const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n\n    switch (this.state.type) {\n      case types.name:\n        if (this.isContextual(\"interface\")) {\n          return this.flowParseInterfaceType();\n        }\n\n        return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());\n\n      case types.braceL:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: false,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: true\n        });\n\n      case types.braceBarL:\n        return this.flowParseObjectType({\n          allowStatic: false,\n          allowExact: true,\n          allowSpread: true,\n          allowProto: false,\n          allowInexact: false\n        });\n\n      case types.bracketL:\n        this.state.noAnonFunctionType = false;\n        type = this.flowParseTupleType();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        return type;\n\n      case types.relational:\n        if (this.state.value === \"<\") {\n          node.typeParameters = this.flowParseTypeParameterDeclaration();\n          this.expect(types.parenL);\n          tmp = this.flowParseFunctionTypeParams();\n          node.params = tmp.params;\n          node.rest = tmp.rest;\n          this.expect(types.parenR);\n          this.expect(types.arrow);\n          node.returnType = this.flowParseType();\n          return this.finishNode(node, \"FunctionTypeAnnotation\");\n        }\n\n        break;\n\n      case types.parenL:\n        this.next();\n\n        if (!this.match(types.parenR) && !this.match(types.ellipsis)) {\n          if (this.match(types.name)) {\n            const token = this.lookahead().type;\n            isGroupedType = token !== types.question && token !== types.colon;\n          } else {\n            isGroupedType = true;\n          }\n        }\n\n        if (isGroupedType) {\n          this.state.noAnonFunctionType = false;\n          type = this.flowParseType();\n          this.state.noAnonFunctionType = oldNoAnonFunctionType;\n\n          if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {\n            this.expect(types.parenR);\n            return type;\n          } else {\n            this.eat(types.comma);\n          }\n        }\n\n        if (type) {\n          tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);\n        } else {\n          tmp = this.flowParseFunctionTypeParams();\n        }\n\n        node.params = tmp.params;\n        node.rest = tmp.rest;\n        this.expect(types.parenR);\n        this.expect(types.arrow);\n        node.returnType = this.flowParseType();\n        node.typeParameters = null;\n        return this.finishNode(node, \"FunctionTypeAnnotation\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteralTypeAnnotation\");\n\n      case types._true:\n      case types._false:\n        node.value = this.match(types._true);\n        this.next();\n        return this.finishNode(node, \"BooleanLiteralTypeAnnotation\");\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          this.next();\n\n          if (this.match(types.num)) {\n            return this.parseLiteral(-this.state.value, \"NumberLiteralTypeAnnotation\", node.start, node.loc.start);\n          }\n\n          if (this.match(types.bigint)) {\n            return this.parseLiteral(-this.state.value, \"BigIntLiteralTypeAnnotation\", node.start, node.loc.start);\n          }\n\n          throw this.raise(this.state.start, FlowErrors.UnexpectedSubtractionOperand);\n        }\n\n        throw this.unexpected();\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumberLiteralTypeAnnotation\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteralTypeAnnotation\");\n\n      case types._void:\n        this.next();\n        return this.finishNode(node, \"VoidTypeAnnotation\");\n\n      case types._null:\n        this.next();\n        return this.finishNode(node, \"NullLiteralTypeAnnotation\");\n\n      case types._this:\n        this.next();\n        return this.finishNode(node, \"ThisTypeAnnotation\");\n\n      case types.star:\n        this.next();\n        return this.finishNode(node, \"ExistsTypeAnnotation\");\n\n      default:\n        if (this.state.type.keyword === \"typeof\") {\n          return this.flowParseTypeofType();\n        } else if (this.state.type.keyword) {\n          const label = this.state.type.label;\n          this.next();\n          return super.createIdentifier(node, label);\n        }\n\n    }\n\n    throw this.unexpected();\n  }\n\n  flowParsePostfixType() {\n    const startPos = this.state.start,\n          startLoc = this.state.startLoc;\n    let type = this.flowParsePrimaryType();\n\n    while (this.match(types.bracketL) && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.elementType = type;\n      this.expect(types.bracketL);\n      this.expect(types.bracketR);\n      type = this.finishNode(node, \"ArrayTypeAnnotation\");\n    }\n\n    return type;\n  }\n\n  flowParsePrefixType() {\n    const node = this.startNode();\n\n    if (this.eat(types.question)) {\n      node.typeAnnotation = this.flowParsePrefixType();\n      return this.finishNode(node, \"NullableTypeAnnotation\");\n    } else {\n      return this.flowParsePostfixType();\n    }\n  }\n\n  flowParseAnonFunctionWithoutParens() {\n    const param = this.flowParsePrefixType();\n\n    if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {\n      const node = this.startNodeAt(param.start, param.loc.start);\n      node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];\n      node.rest = null;\n      node.returnType = this.flowParseType();\n      node.typeParameters = null;\n      return this.finishNode(node, \"FunctionTypeAnnotation\");\n    }\n\n    return param;\n  }\n\n  flowParseIntersectionType() {\n    const node = this.startNode();\n    this.eat(types.bitwiseAND);\n    const type = this.flowParseAnonFunctionWithoutParens();\n    node.types = [type];\n\n    while (this.eat(types.bitwiseAND)) {\n      node.types.push(this.flowParseAnonFunctionWithoutParens());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"IntersectionTypeAnnotation\");\n  }\n\n  flowParseUnionType() {\n    const node = this.startNode();\n    this.eat(types.bitwiseOR);\n    const type = this.flowParseIntersectionType();\n    node.types = [type];\n\n    while (this.eat(types.bitwiseOR)) {\n      node.types.push(this.flowParseIntersectionType());\n    }\n\n    return node.types.length === 1 ? type : this.finishNode(node, \"UnionTypeAnnotation\");\n  }\n\n  flowParseType() {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n    const type = this.flowParseUnionType();\n    this.state.inType = oldInType;\n    this.state.exprAllowed = this.state.exprAllowed || this.state.noAnonFunctionType;\n    return type;\n  }\n\n  flowParseTypeOrImplicitInstantiation() {\n    if (this.state.type === types.name && this.state.value === \"_\") {\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      const node = this.parseIdentifier();\n      return this.flowParseGenericType(startPos, startLoc, node);\n    } else {\n      return this.flowParseType();\n    }\n  }\n\n  flowParseTypeAnnotation() {\n    const node = this.startNode();\n    node.typeAnnotation = this.flowParseTypeInitialiser();\n    return this.finishNode(node, \"TypeAnnotation\");\n  }\n\n  flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {\n    const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();\n\n    if (this.match(types.colon)) {\n      ident.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(ident);\n    }\n\n    return ident;\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  flowParseVariance() {\n    let variance = null;\n\n    if (this.match(types.plusMin)) {\n      variance = this.startNode();\n\n      if (this.state.value === \"+\") {\n        variance.kind = \"plus\";\n      } else {\n        variance.kind = \"minus\";\n      }\n\n      this.next();\n      this.finishNode(variance, \"Variance\");\n    }\n\n    return variance;\n  }\n\n  parseFunctionBody(node, allowExpressionBody, isMethod = false) {\n    if (allowExpressionBody) {\n      return this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));\n    }\n\n    return super.parseFunctionBody(node, false, isMethod);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      const typeNode = this.startNode();\n      [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n      node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, \"TypeAnnotation\") : null;\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.state.strict && this.match(types.name) && this.state.value === \"interface\") {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseInterface(node);\n    } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    } else {\n      const stmt = super.parseStatement(context, topLevel);\n\n      if (this.flowPragma === undefined && !this.isValidDirective(stmt)) {\n        this.flowPragma = null;\n      }\n\n      return stmt;\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type === \"Identifier\") {\n      if (expr.name === \"declare\") {\n        if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var) || this.match(types._export)) {\n          return this.flowParseDeclare(node);\n        }\n      } else if (this.match(types.name)) {\n        if (expr.name === \"interface\") {\n          return this.flowParseInterface(node);\n        } else if (expr.name === \"type\") {\n          return this.flowParseTypeAlias(node);\n        } else if (expr.name === \"opaque\") {\n          return this.flowParseOpaqueType(node, false);\n        }\n      }\n    }\n\n    return super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    return this.isContextual(\"type\") || this.isContextual(\"interface\") || this.isContextual(\"opaque\") || this.shouldParseEnums() && this.isContextual(\"enum\") || super.shouldParseExportDeclaration();\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name) && (this.state.value === \"type\" || this.state.value === \"interface\" || this.state.value === \"opaque\" || this.shouldParseEnums() && this.state.value === \"enum\")) {\n      return false;\n    }\n\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseExportDefaultExpression() {\n    if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      const node = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(node);\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (!this.match(types.question)) return expr;\n\n    if (refNeedsArrowPos) {\n      const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));\n\n      if (!result.node) {\n        refNeedsArrowPos.start = result.error.pos || this.state.start;\n        return expr;\n      }\n\n      if (result.error) this.state = result.failState;\n      return result.node;\n    }\n\n    this.expect(types.question);\n    const state = this.state.clone();\n    const originalNoArrowAt = this.state.noArrowAt;\n    const node = this.startNodeAt(startPos, startLoc);\n    let {\n      consequent,\n      failed\n    } = this.tryParseConditionalConsequent();\n    let [valid, invalid] = this.getArrowLikeExpressions(consequent);\n\n    if (failed || invalid.length > 0) {\n      const noArrowAt = [...originalNoArrowAt];\n\n      if (invalid.length > 0) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt;\n\n        for (let i = 0; i < invalid.length; i++) {\n          noArrowAt.push(invalid[i].start);\n        }\n\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n        [valid, invalid] = this.getArrowLikeExpressions(consequent);\n      }\n\n      if (failed && valid.length > 1) {\n        this.raise(state.start, FlowErrors.AmbiguousConditionalArrow);\n      }\n\n      if (failed && valid.length === 1) {\n        this.state = state;\n        this.state.noArrowAt = noArrowAt.concat(valid[0].start);\n        ({\n          consequent,\n          failed\n        } = this.tryParseConditionalConsequent());\n      }\n    }\n\n    this.getArrowLikeExpressions(consequent, true);\n    this.state.noArrowAt = originalNoArrowAt;\n    this.expect(types.colon);\n    node.test = expr;\n    node.consequent = consequent;\n    node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(noIn, undefined, undefined, undefined));\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n\n  tryParseConditionalConsequent() {\n    this.state.noArrowParamsConversionAt.push(this.state.start);\n    const consequent = this.parseMaybeAssign();\n    const failed = !this.match(types.colon);\n    this.state.noArrowParamsConversionAt.pop();\n    return {\n      consequent,\n      failed\n    };\n  }\n\n  getArrowLikeExpressions(node, disallowInvalid) {\n    const stack = [node];\n    const arrows = [];\n\n    while (stack.length !== 0) {\n      const node = stack.pop();\n\n      if (node.type === \"ArrowFunctionExpression\") {\n        if (node.typeParameters || !node.returnType) {\n          this.finishArrowValidation(node);\n        } else {\n          arrows.push(node);\n        }\n\n        stack.push(node.body);\n      } else if (node.type === \"ConditionalExpression\") {\n        stack.push(node.consequent);\n        stack.push(node.alternate);\n      }\n    }\n\n    if (disallowInvalid) {\n      arrows.forEach(node => this.finishArrowValidation(node));\n      return [arrows, []];\n    }\n\n    return partition(arrows, node => node.params.every(param => this.isAssignable(param, true)));\n  }\n\n  finishArrowValidation(node) {\n    var _node$extra;\n\n    this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingComma);\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    super.checkParams(node, false, true);\n    this.scope.exit();\n  }\n\n  forwardNoArrowParamsConversionAt(node, parse) {\n    let result;\n\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      this.state.noArrowParamsConversionAt.push(this.state.start);\n      result = parse();\n      this.state.noArrowParamsConversionAt.pop();\n    } else {\n      result = parse();\n    }\n\n    return result;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (node.type === \"ImportDeclaration\" && (node.importKind === \"type\" || node.importKind === \"typeof\") || node.type === \"ExportNamedDeclaration\" && node.exportKind === \"type\" || node.type === \"ExportAllDeclaration\" && node.exportKind === \"type\") {\n      return;\n    }\n\n    super.assertModuleNodeAllowed(node);\n  }\n\n  parseExport(node) {\n    const decl = super.parseExport(node);\n\n    if (decl.type === \"ExportNamedDeclaration\" || decl.type === \"ExportAllDeclaration\") {\n      decl.exportKind = decl.exportKind || \"value\";\n    }\n\n    return decl;\n  }\n\n  parseExportDeclaration(node) {\n    if (this.isContextual(\"type\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n\n      if (this.match(types.braceL)) {\n        node.specifiers = this.parseExportSpecifiers();\n        this.parseExportFrom(node);\n        return null;\n      } else {\n        return this.flowParseTypeAlias(declarationNode);\n      }\n    } else if (this.isContextual(\"opaque\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseOpaqueType(declarationNode, false);\n    } else if (this.isContextual(\"interface\")) {\n      node.exportKind = \"type\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseInterface(declarationNode);\n    } else if (this.shouldParseEnums() && this.isContextual(\"enum\")) {\n      node.exportKind = \"value\";\n      const declarationNode = this.startNode();\n      this.next();\n      return this.flowParseEnumDeclaration(declarationNode);\n    } else {\n      return super.parseExportDeclaration(node);\n    }\n  }\n\n  eatExportStar(node) {\n    if (super.eatExportStar(...arguments)) return true;\n\n    if (this.isContextual(\"type\") && this.lookahead().type === types.star) {\n      node.exportKind = \"type\";\n      this.next();\n      this.next();\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    const pos = this.state.start;\n    const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);\n\n    if (hasNamespace && node.exportKind === \"type\") {\n      this.unexpected(pos);\n    }\n\n    return hasNamespace;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    super.parseClassId(node, isStatement, optionalId);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n  }\n\n  parseClassMember(classBody, member, state, constructorAllowsSuper) {\n    const pos = this.state.start;\n\n    if (this.isContextual(\"declare\")) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        return;\n      }\n\n      member.declare = true;\n    }\n\n    super.parseClassMember(classBody, member, state, constructorAllowsSuper);\n\n    if (member.declare) {\n      if (member.type !== \"ClassProperty\" && member.type !== \"ClassPrivateProperty\") {\n        this.raise(pos, FlowErrors.DeclareClassElement);\n      } else if (member.value) {\n        this.raise(member.value.start, FlowErrors.DeclareClassFieldInitializer);\n      }\n    }\n  }\n\n  getTokenFromCode(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 123 && next === 124) {\n      return this.finishOp(types.braceBarL, 2);\n    } else if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else if (isIteratorStart(code, next)) {\n      this.state.isIterator = true;\n      return super.readWord();\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  isAssignable(node, isBinding) {\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        return true;\n\n      case \"ObjectExpression\":\n        {\n          const last = node.properties.length - 1;\n          return node.properties.every((prop, i) => {\n            return prop.type !== \"ObjectMethod\" && (i === last || prop.type === \"SpreadElement\") && this.isAssignable(prop);\n          });\n        }\n\n      case \"ObjectProperty\":\n        return this.isAssignable(node.value);\n\n      case \"SpreadElement\":\n        return this.isAssignable(node.argument);\n\n      case \"ArrayExpression\":\n        return node.elements.every(element => this.isAssignable(element));\n\n      case \"AssignmentExpression\":\n        return node.operator === \"=\";\n\n      case \"ParenthesizedExpression\":\n      case \"TypeCastExpression\":\n        return this.isAssignable(node.expression);\n\n      case \"MemberExpression\":\n      case \"OptionalMemberExpression\":\n        return !isBinding;\n\n      default:\n        return false;\n    }\n  }\n\n  toAssignable(node) {\n    if (node.type === \"TypeCastExpression\") {\n      return super.toAssignable(this.typeCastToParameter(node));\n    } else {\n      return super.toAssignable(node);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\") {\n        exprList[i] = this.typeCastToParameter(expr);\n      }\n    }\n\n    return super.toAssignableList(exprList, trailingCommaPos);\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TypeCastExpression\" && (!expr.extra || !expr.extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {\n        this.raise(expr.typeAnnotation.start, FlowErrors.TypeCastInPattern);\n      }\n    }\n\n    return exprList;\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {\n    if (expr.type !== \"TypeCastExpression\") {\n      return super.checkLVal(expr, bindingType, checkClashes, contextDescription);\n    }\n  }\n\n  parseClassProperty(node) {\n    if (this.match(types.colon)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (this.match(types.colon)) {\n      node.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    return super.parseClassPrivateProperty(node);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.colon) || super.isClassProperty();\n  }\n\n  isNonstaticConstructor(method) {\n    return !this.match(types.colon) && super.isNonstaticConstructor(method);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    if (method.variance) {\n      this.unexpected(method.variance.start);\n    }\n\n    delete method.variance;\n\n    if (this.isRelational(\"<\")) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    if (method.variance) {\n      this.unexpected(method.variance.start);\n    }\n\n    delete method.variance;\n\n    if (this.isRelational(\"<\")) {\n      method.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.flowParseTypeParameterInstantiation();\n    }\n\n    if (this.isContextual(\"implements\")) {\n      this.next();\n      const implemented = node.implements = [];\n\n      do {\n        const node = this.startNode();\n        node.id = this.flowParseRestrictedIdentifier(true);\n\n        if (this.isRelational(\"<\")) {\n          node.typeParameters = this.flowParseTypeParameterInstantiation();\n        } else {\n          node.typeParameters = null;\n        }\n\n        implemented.push(this.finishNode(node, \"ClassImplements\"));\n      } while (this.eat(types.comma));\n    }\n  }\n\n  parsePropertyName(node, isPrivateNameAllowed) {\n    const variance = this.flowParseVariance();\n    const key = super.parsePropertyName(node, isPrivateNameAllowed);\n    node.variance = variance;\n    return key;\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {\n    if (prop.variance) {\n      this.unexpected(prop.variance.start);\n    }\n\n    delete prop.variance;\n    let typeParameters;\n\n    if (this.isRelational(\"<\")) {\n      typeParameters = this.flowParseTypeParameterDeclaration();\n      if (!this.match(types.parenL)) this.unexpected();\n    }\n\n    super.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);\n\n    if (typeParameters) {\n      (prop.value || prop).typeParameters = typeParameters;\n    }\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(param.start, FlowErrors.OptionalBindingPattern);\n      }\n\n      param.optional = true;\n    }\n\n    if (this.match(types.colon)) {\n      param.typeAnnotation = this.flowParseTypeAnnotation();\n    }\n\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    const node = super.parseMaybeDefault(startPos, startLoc, left);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, FlowErrors.TypeBeforeInitializer);\n    }\n\n    return node;\n  }\n\n  shouldParseDefaultImport(node) {\n    if (!hasTypeImportKind(node)) {\n      return super.shouldParseDefaultImport(node);\n    }\n\n    return isMaybeDefaultImport(this.state);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    node.importKind = \"value\";\n    let kind = null;\n\n    if (this.match(types._typeof)) {\n      kind = \"typeof\";\n    } else if (this.isContextual(\"type\")) {\n      kind = \"type\";\n    }\n\n    if (kind) {\n      const lh = this.lookahead();\n\n      if (kind === \"type\" && lh.type === types.star) {\n        this.unexpected(lh.start);\n      }\n\n      if (isMaybeDefaultImport(lh) || lh.type === types.braceL || lh.type === types.star) {\n        this.next();\n        node.importKind = kind;\n      }\n    }\n\n    return super.maybeParseDefaultImportSpecifier(node);\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    const firstIdentLoc = this.state.start;\n    const firstIdent = this.parseIdentifier(true);\n    let specifierTypeKind = null;\n\n    if (firstIdent.name === \"type\") {\n      specifierTypeKind = \"type\";\n    } else if (firstIdent.name === \"typeof\") {\n      specifierTypeKind = \"typeof\";\n    }\n\n    let isBinding = false;\n\n    if (this.isContextual(\"as\") && !this.isLookaheadContextual(\"as\")) {\n      const as_ident = this.parseIdentifier(true);\n\n      if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {\n        specifier.imported = as_ident;\n        specifier.importKind = specifierTypeKind;\n        specifier.local = as_ident.__clone();\n      } else {\n        specifier.imported = firstIdent;\n        specifier.importKind = null;\n        specifier.local = this.parseIdentifier();\n      }\n    } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {\n      specifier.imported = this.parseIdentifier(true);\n      specifier.importKind = specifierTypeKind;\n\n      if (this.eatContextual(\"as\")) {\n        specifier.local = this.parseIdentifier();\n      } else {\n        isBinding = true;\n        specifier.local = specifier.imported.__clone();\n      }\n    } else {\n      isBinding = true;\n      specifier.imported = firstIdent;\n      specifier.importKind = null;\n      specifier.local = specifier.imported.__clone();\n    }\n\n    const nodeIsTypeImport = hasTypeImportKind(node);\n    const specifierIsTypeImport = hasTypeImportKind(specifier);\n\n    if (nodeIsTypeImport && specifierIsTypeImport) {\n      this.raise(firstIdentLoc, FlowErrors.ImportTypeShorthandOnlyInPureImport);\n    }\n\n    if (nodeIsTypeImport || specifierIsTypeImport) {\n      this.checkReservedType(specifier.local.name, specifier.local.start, true);\n    }\n\n    if (isBinding && !nodeIsTypeImport && !specifierIsTypeImport) {\n      this.checkReservedWord(specifier.local.name, specifier.start, true, true);\n    }\n\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, \"import specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const kind = node.kind;\n\n    if (kind !== \"get\" && kind !== \"set\" && this.isRelational(\"<\")) {\n      node.typeParameters = this.flowParseTypeParameterDeclaration();\n    }\n\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (this.match(types.colon)) {\n      decl.id.typeAnnotation = this.flowParseTypeAnnotation();\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n      this.state.noAnonFunctionType = true;\n      node.returnType = this.flowParseTypeAnnotation();\n      this.state.noAnonFunctionType = oldNoAnonFunctionType;\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    let state = null;\n    let jsx;\n\n    if (this.hasPlugin(\"jsx\") && (this.match(types.jsxTagStart) || this.isRelational(\"<\"))) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (jsx && jsx.error || this.isRelational(\"<\")) {\n      state = state || this.state.clone();\n      let typeParameters;\n      const arrow = this.tryParse(() => {\n        typeParameters = this.flowParseTypeParameterDeclaration();\n        const arrowExpression = this.forwardNoArrowParamsConversionAt(typeParameters, () => super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos));\n        arrowExpression.typeParameters = typeParameters;\n        this.resetStartLocationFromNode(arrowExpression, typeParameters);\n        return arrowExpression;\n      }, state);\n      const arrowExpression = arrow.node && arrow.node.type === \"ArrowFunctionExpression\" ? arrow.node : null;\n      if (!arrow.error && arrowExpression) return arrowExpression;\n\n      if (jsx && jsx.node) {\n        this.state = jsx.failState;\n        return jsx.node;\n      }\n\n      if (arrowExpression) {\n        this.state = arrow.failState;\n        return arrowExpression;\n      }\n\n      if (jsx && jsx.thrown) throw jsx.error;\n      if (arrow.thrown) throw arrow.error;\n      throw this.raise(typeParameters.start, FlowErrors.UnexpectedTokenAfterTypeParameter);\n    }\n\n    return super.parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos);\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(() => {\n        const oldNoAnonFunctionType = this.state.noAnonFunctionType;\n        this.state.noAnonFunctionType = true;\n        const typeNode = this.startNode();\n        [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();\n        this.state.noAnonFunctionType = oldNoAnonFunctionType;\n        if (this.canInsertSemicolon()) this.unexpected();\n        if (!this.match(types.arrow)) this.unexpected();\n        return typeNode;\n      });\n      if (result.thrown) return null;\n      if (result.error) this.state = result.failState;\n      node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, \"TypeAnnotation\") : null;\n    }\n\n    return super.parseArrow(node);\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  setArrowFunctionParameters(node, params) {\n    if (this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      node.params = params;\n    } else {\n      super.setArrowFunctionParameters(node, params);\n    }\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction) {\n    if (isArrowFunction && this.state.noArrowParamsConversionAt.indexOf(node.start) !== -1) {\n      return;\n    }\n\n    return super.checkParams(...arguments);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    return super.parseParenAndDistinguishExpression(canBeArrow && this.state.noArrowAt.indexOf(this.state.start) === -1);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    if (base.type === \"Identifier\" && base.name === \"async\" && this.state.noArrowAt.indexOf(startPos) !== -1) {\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      base = this.finishNode(node, \"CallExpression\");\n    } else if (base.type === \"Identifier\" && base.name === \"async\" && this.isRelational(\"<\")) {\n      const state = this.state.clone();\n      const arrow = this.tryParse(abort => this.parseAsyncArrowWithTypeParameters(startPos, startLoc) || abort(), state);\n      if (!arrow.error && !arrow.aborted) return arrow.node;\n      const result = this.tryParse(() => super.parseSubscripts(base, startPos, startLoc, noCalls), state);\n      if (result.node && !result.error) return result.node;\n\n      if (arrow.node) {\n        this.state = arrow.failState;\n        return arrow.node;\n      }\n\n      if (result.node) {\n        this.state = result.failState;\n        return result.node;\n      }\n\n      throw arrow.error || result.error;\n    }\n\n    return super.parseSubscripts(base, startPos, startLoc, noCalls);\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, subscriptState) {\n    if (this.match(types.questionDot) && this.isLookaheadRelational(\"<\")) {\n      subscriptState.optionalChainMember = true;\n\n      if (noCalls) {\n        subscriptState.stop = true;\n        return base;\n      }\n\n      this.next();\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      node.typeArguments = this.flowParseTypeParameterInstantiation();\n      this.expect(types.parenL);\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      node.optional = true;\n      return this.finishCallExpression(node, true);\n    } else if (!noCalls && this.shouldParseTypes() && this.isRelational(\"<\")) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n      const result = this.tryParse(() => {\n        node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();\n        this.expect(types.parenL);\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n        if (subscriptState.optionalChainMember) node.optional = false;\n        return this.finishCallExpression(node, subscriptState.optionalChainMember);\n      });\n\n      if (result.node) {\n        if (result.error) this.state = result.failState;\n        return result.node;\n      }\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, subscriptState);\n  }\n\n  parseNewArguments(node) {\n    let targs = null;\n\n    if (this.shouldParseTypes() && this.isRelational(\"<\")) {\n      targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;\n    }\n\n    node.typeArguments = targs;\n    super.parseNewArguments(node);\n  }\n\n  parseAsyncArrowWithTypeParameters(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    this.parseFunctionParams(node);\n    if (!this.parseArrow(node)) return;\n    return this.parseArrowExpression(node, undefined, true);\n  }\n\n  readToken_mult_modulo(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 42 && next === 47 && this.state.hasFlowComment) {\n      this.state.hasFlowComment = false;\n      this.state.pos += 2;\n      this.nextToken();\n      return;\n    }\n\n    super.readToken_mult_modulo(code);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (code === 124 && next === 125) {\n      this.finishOp(types.braceBarR, 2);\n      return;\n    }\n\n    super.readToken_pipe_amp(code);\n  }\n\n  parseTopLevel(file, program) {\n    const fileNode = super.parseTopLevel(file, program);\n\n    if (this.state.hasFlowComment) {\n      this.raise(this.state.pos, FlowErrors.UnterminatedFlowComment);\n    }\n\n    return fileNode;\n  }\n\n  skipBlockComment() {\n    if (this.hasPlugin(\"flowComments\") && this.skipFlowComment()) {\n      if (this.state.hasFlowComment) {\n        this.unexpected(null, FlowErrors.NestedFlowComment);\n      }\n\n      this.hasFlowCommentCompletion();\n      this.state.pos += this.skipFlowComment();\n      this.state.hasFlowComment = true;\n      return;\n    }\n\n    if (this.state.hasFlowComment) {\n      const end = this.input.indexOf(\"*-/\", this.state.pos += 2);\n\n      if (end === -1) {\n        throw this.raise(this.state.pos - 2, Errors.UnterminatedComment);\n      }\n\n      this.state.pos = end + 3;\n      return;\n    }\n\n    super.skipBlockComment();\n  }\n\n  skipFlowComment() {\n    const {\n      pos\n    } = this.state;\n    let shiftToFirstNonWhiteSpace = 2;\n\n    while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {\n      shiftToFirstNonWhiteSpace++;\n    }\n\n    const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);\n    const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);\n\n    if (ch2 === 58 && ch3 === 58) {\n      return shiftToFirstNonWhiteSpace + 2;\n    }\n\n    if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === \"flow-include\") {\n      return shiftToFirstNonWhiteSpace + 12;\n    }\n\n    if (ch2 === 58 && ch3 !== 58) {\n      return shiftToFirstNonWhiteSpace;\n    }\n\n    return false;\n  }\n\n  hasFlowCommentCompletion() {\n    const end = this.input.indexOf(\"*/\", this.state.pos);\n\n    if (end === -1) {\n      throw this.raise(this.state.pos, Errors.UnterminatedComment);\n    }\n  }\n\n  flowEnumErrorBooleanMemberNotInitialized(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumBooleanMemberNotInitialized, memberName, enumName);\n  }\n\n  flowEnumErrorInvalidMemberName(pos, {\n    enumName,\n    memberName\n  }) {\n    const suggestion = memberName[0].toUpperCase() + memberName.slice(1);\n    this.raise(pos, FlowErrors.EnumInvalidMemberName, memberName, suggestion, enumName);\n  }\n\n  flowEnumErrorDuplicateMemberName(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumDuplicateMemberName, memberName, enumName);\n  }\n\n  flowEnumErrorInconsistentMemberValues(pos, {\n    enumName\n  }) {\n    this.raise(pos, FlowErrors.EnumInconsistentMemberValues, enumName);\n  }\n\n  flowEnumErrorInvalidExplicitType(pos, {\n    enumName,\n    suppliedType\n  }) {\n    return this.raise(pos, suppliedType === null ? FlowErrors.EnumInvalidExplicitTypeUnknownSupplied : FlowErrors.EnumInvalidExplicitType, enumName, suppliedType);\n  }\n\n  flowEnumErrorInvalidMemberInitializer(pos, {\n    enumName,\n    explicitType,\n    memberName\n  }) {\n    let message = null;\n\n    switch (explicitType) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        message = FlowErrors.EnumInvalidMemberInitializerPrimaryType;\n        break;\n\n      case \"symbol\":\n        message = FlowErrors.EnumInvalidMemberInitializerSymbolType;\n        break;\n\n      default:\n        message = FlowErrors.EnumInvalidMemberInitializerUnknownType;\n    }\n\n    return this.raise(pos, message, enumName, memberName, explicitType);\n  }\n\n  flowEnumErrorNumberMemberNotInitialized(pos, {\n    enumName,\n    memberName\n  }) {\n    this.raise(pos, FlowErrors.EnumNumberMemberNotInitialized, enumName, memberName);\n  }\n\n  flowEnumErrorStringMemberInconsistentlyInitailized(pos, {\n    enumName\n  }) {\n    this.raise(pos, FlowErrors.EnumStringMemberInconsistentlyInitailized, enumName);\n  }\n\n  flowEnumMemberInit() {\n    const startPos = this.state.start;\n\n    const endOfInit = () => this.match(types.comma) || this.match(types.braceR);\n\n    switch (this.state.type) {\n      case types.num:\n        {\n          const literal = this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n          if (endOfInit()) {\n            return {\n              type: \"number\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      case types.string:\n        {\n          const literal = this.parseLiteral(this.state.value, \"StringLiteral\");\n\n          if (endOfInit()) {\n            return {\n              type: \"string\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      case types._true:\n      case types._false:\n        {\n          const literal = this.parseBooleanLiteral();\n\n          if (endOfInit()) {\n            return {\n              type: \"boolean\",\n              pos: literal.start,\n              value: literal\n            };\n          }\n\n          return {\n            type: \"invalid\",\n            pos: startPos\n          };\n        }\n\n      default:\n        return {\n          type: \"invalid\",\n          pos: startPos\n        };\n    }\n  }\n\n  flowEnumMemberRaw() {\n    const pos = this.state.start;\n    const id = this.parseIdentifier(true);\n    const init = this.eat(types.eq) ? this.flowEnumMemberInit() : {\n      type: \"none\",\n      pos\n    };\n    return {\n      id,\n      init\n    };\n  }\n\n  flowEnumCheckExplicitTypeMismatch(pos, context, expectedType) {\n    const {\n      explicitType\n    } = context;\n\n    if (explicitType === null) {\n      return;\n    }\n\n    if (explicitType !== expectedType) {\n      this.flowEnumErrorInvalidMemberInitializer(pos, context);\n    }\n  }\n\n  flowEnumMembers({\n    enumName,\n    explicitType\n  }) {\n    const seenNames = new Set();\n    const members = {\n      booleanMembers: [],\n      numberMembers: [],\n      stringMembers: [],\n      defaultedMembers: []\n    };\n\n    while (!this.match(types.braceR)) {\n      const memberNode = this.startNode();\n      const {\n        id,\n        init\n      } = this.flowEnumMemberRaw();\n      const memberName = id.name;\n\n      if (memberName === \"\") {\n        continue;\n      }\n\n      if (/^[a-z]/.test(memberName)) {\n        this.flowEnumErrorInvalidMemberName(id.start, {\n          enumName,\n          memberName\n        });\n      }\n\n      if (seenNames.has(memberName)) {\n        this.flowEnumErrorDuplicateMemberName(id.start, {\n          enumName,\n          memberName\n        });\n      }\n\n      seenNames.add(memberName);\n      const context = {\n        enumName,\n        explicitType,\n        memberName\n      };\n      memberNode.id = id;\n\n      switch (init.type) {\n        case \"boolean\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"boolean\");\n            memberNode.init = init.value;\n            members.booleanMembers.push(this.finishNode(memberNode, \"EnumBooleanMember\"));\n            break;\n          }\n\n        case \"number\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"number\");\n            memberNode.init = init.value;\n            members.numberMembers.push(this.finishNode(memberNode, \"EnumNumberMember\"));\n            break;\n          }\n\n        case \"string\":\n          {\n            this.flowEnumCheckExplicitTypeMismatch(init.pos, context, \"string\");\n            memberNode.init = init.value;\n            members.stringMembers.push(this.finishNode(memberNode, \"EnumStringMember\"));\n            break;\n          }\n\n        case \"invalid\":\n          {\n            throw this.flowEnumErrorInvalidMemberInitializer(init.pos, context);\n          }\n\n        case \"none\":\n          {\n            switch (explicitType) {\n              case \"boolean\":\n                this.flowEnumErrorBooleanMemberNotInitialized(init.pos, context);\n                break;\n\n              case \"number\":\n                this.flowEnumErrorNumberMemberNotInitialized(init.pos, context);\n                break;\n\n              default:\n                members.defaultedMembers.push(this.finishNode(memberNode, \"EnumDefaultedMember\"));\n            }\n          }\n      }\n\n      if (!this.match(types.braceR)) {\n        this.expect(types.comma);\n      }\n    }\n\n    return members;\n  }\n\n  flowEnumStringMembers(initializedMembers, defaultedMembers, {\n    enumName\n  }) {\n    if (initializedMembers.length === 0) {\n      return defaultedMembers;\n    } else if (defaultedMembers.length === 0) {\n      return initializedMembers;\n    } else if (defaultedMembers.length > initializedMembers.length) {\n      for (let _i = 0; _i < initializedMembers.length; _i++) {\n        const member = initializedMembers[_i];\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n          enumName\n        });\n      }\n\n      return defaultedMembers;\n    } else {\n      for (let _i2 = 0; _i2 < defaultedMembers.length; _i2++) {\n        const member = defaultedMembers[_i2];\n        this.flowEnumErrorStringMemberInconsistentlyInitailized(member.start, {\n          enumName\n        });\n      }\n\n      return initializedMembers;\n    }\n  }\n\n  flowEnumParseExplicitType({\n    enumName\n  }) {\n    if (this.eatContextual(\"of\")) {\n      if (!this.match(types.name)) {\n        throw this.flowEnumErrorInvalidExplicitType(this.state.start, {\n          enumName,\n          suppliedType: null\n        });\n      }\n\n      const {\n        value\n      } = this.state;\n      this.next();\n\n      if (value !== \"boolean\" && value !== \"number\" && value !== \"string\" && value !== \"symbol\") {\n        this.flowEnumErrorInvalidExplicitType(this.state.start, {\n          enumName,\n          suppliedType: value\n        });\n      }\n\n      return value;\n    }\n\n    return null;\n  }\n\n  flowEnumBody(node, {\n    enumName,\n    nameLoc\n  }) {\n    const explicitType = this.flowEnumParseExplicitType({\n      enumName\n    });\n    this.expect(types.braceL);\n    const members = this.flowEnumMembers({\n      enumName,\n      explicitType\n    });\n\n    switch (explicitType) {\n      case \"boolean\":\n        node.explicitType = true;\n        node.members = members.booleanMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumBooleanBody\");\n\n      case \"number\":\n        node.explicitType = true;\n        node.members = members.numberMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumNumberBody\");\n\n      case \"string\":\n        node.explicitType = true;\n        node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n          enumName\n        });\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumStringBody\");\n\n      case \"symbol\":\n        node.members = members.defaultedMembers;\n        this.expect(types.braceR);\n        return this.finishNode(node, \"EnumSymbolBody\");\n\n      default:\n        {\n          const empty = () => {\n            node.members = [];\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          };\n\n          node.explicitType = false;\n          const boolsLen = members.booleanMembers.length;\n          const numsLen = members.numberMembers.length;\n          const strsLen = members.stringMembers.length;\n          const defaultedLen = members.defaultedMembers.length;\n\n          if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {\n            return empty();\n          } else if (!boolsLen && !numsLen) {\n            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {\n              enumName\n            });\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumStringBody\");\n          } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {\n            for (let _i3 = 0, _members$defaultedMem = members.defaultedMembers; _i3 < _members$defaultedMem.length; _i3++) {\n              const member = _members$defaultedMem[_i3];\n              this.flowEnumErrorBooleanMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.booleanMembers;\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumBooleanBody\");\n          } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {\n            for (let _i4 = 0, _members$defaultedMem2 = members.defaultedMembers; _i4 < _members$defaultedMem2.length; _i4++) {\n              const member = _members$defaultedMem2[_i4];\n              this.flowEnumErrorNumberMemberNotInitialized(member.start, {\n                enumName,\n                memberName: member.id.name\n              });\n            }\n\n            node.members = members.numberMembers;\n            this.expect(types.braceR);\n            return this.finishNode(node, \"EnumNumberBody\");\n          } else {\n            this.flowEnumErrorInconsistentMemberValues(nameLoc, {\n              enumName\n            });\n            return empty();\n          }\n        }\n    }\n  }\n\n  flowParseEnumDeclaration(node) {\n    const id = this.parseIdentifier();\n    node.id = id;\n    node.body = this.flowEnumBody(this.startNode(), {\n      enumName: id.name,\n      nameLoc: id.start\n    });\n    return this.finishNode(node, \"EnumDeclaration\");\n  }\n\n  updateContext(prevType) {\n    if (this.match(types.name) && this.state.value === \"of\" && prevType === types.name && this.input.slice(this.state.lastTokStart, this.state.lastTokEnd) === \"interface\") {\n      this.state.exprAllowed = false;\n    } else {\n      super.updateContext(prevType);\n    }\n  }\n\n});\n\nconst entities = {\n  quot: \"\\u0022\",\n  amp: \"&\",\n  apos: \"\\u0027\",\n  lt: \"<\",\n  gt: \">\",\n  nbsp: \"\\u00A0\",\n  iexcl: \"\\u00A1\",\n  cent: \"\\u00A2\",\n  pound: \"\\u00A3\",\n  curren: \"\\u00A4\",\n  yen: \"\\u00A5\",\n  brvbar: \"\\u00A6\",\n  sect: \"\\u00A7\",\n  uml: \"\\u00A8\",\n  copy: \"\\u00A9\",\n  ordf: \"\\u00AA\",\n  laquo: \"\\u00AB\",\n  not: \"\\u00AC\",\n  shy: \"\\u00AD\",\n  reg: \"\\u00AE\",\n  macr: \"\\u00AF\",\n  deg: \"\\u00B0\",\n  plusmn: \"\\u00B1\",\n  sup2: \"\\u00B2\",\n  sup3: \"\\u00B3\",\n  acute: \"\\u00B4\",\n  micro: \"\\u00B5\",\n  para: \"\\u00B6\",\n  middot: \"\\u00B7\",\n  cedil: \"\\u00B8\",\n  sup1: \"\\u00B9\",\n  ordm: \"\\u00BA\",\n  raquo: \"\\u00BB\",\n  frac14: \"\\u00BC\",\n  frac12: \"\\u00BD\",\n  frac34: \"\\u00BE\",\n  iquest: \"\\u00BF\",\n  Agrave: \"\\u00C0\",\n  Aacute: \"\\u00C1\",\n  Acirc: \"\\u00C2\",\n  Atilde: \"\\u00C3\",\n  Auml: \"\\u00C4\",\n  Aring: \"\\u00C5\",\n  AElig: \"\\u00C6\",\n  Ccedil: \"\\u00C7\",\n  Egrave: \"\\u00C8\",\n  Eacute: \"\\u00C9\",\n  Ecirc: \"\\u00CA\",\n  Euml: \"\\u00CB\",\n  Igrave: \"\\u00CC\",\n  Iacute: \"\\u00CD\",\n  Icirc: \"\\u00CE\",\n  Iuml: \"\\u00CF\",\n  ETH: \"\\u00D0\",\n  Ntilde: \"\\u00D1\",\n  Ograve: \"\\u00D2\",\n  Oacute: \"\\u00D3\",\n  Ocirc: \"\\u00D4\",\n  Otilde: \"\\u00D5\",\n  Ouml: \"\\u00D6\",\n  times: \"\\u00D7\",\n  Oslash: \"\\u00D8\",\n  Ugrave: \"\\u00D9\",\n  Uacute: \"\\u00DA\",\n  Ucirc: \"\\u00DB\",\n  Uuml: \"\\u00DC\",\n  Yacute: \"\\u00DD\",\n  THORN: \"\\u00DE\",\n  szlig: \"\\u00DF\",\n  agrave: \"\\u00E0\",\n  aacute: \"\\u00E1\",\n  acirc: \"\\u00E2\",\n  atilde: \"\\u00E3\",\n  auml: \"\\u00E4\",\n  aring: \"\\u00E5\",\n  aelig: \"\\u00E6\",\n  ccedil: \"\\u00E7\",\n  egrave: \"\\u00E8\",\n  eacute: \"\\u00E9\",\n  ecirc: \"\\u00EA\",\n  euml: \"\\u00EB\",\n  igrave: \"\\u00EC\",\n  iacute: \"\\u00ED\",\n  icirc: \"\\u00EE\",\n  iuml: \"\\u00EF\",\n  eth: \"\\u00F0\",\n  ntilde: \"\\u00F1\",\n  ograve: \"\\u00F2\",\n  oacute: \"\\u00F3\",\n  ocirc: \"\\u00F4\",\n  otilde: \"\\u00F5\",\n  ouml: \"\\u00F6\",\n  divide: \"\\u00F7\",\n  oslash: \"\\u00F8\",\n  ugrave: \"\\u00F9\",\n  uacute: \"\\u00FA\",\n  ucirc: \"\\u00FB\",\n  uuml: \"\\u00FC\",\n  yacute: \"\\u00FD\",\n  thorn: \"\\u00FE\",\n  yuml: \"\\u00FF\",\n  OElig: \"\\u0152\",\n  oelig: \"\\u0153\",\n  Scaron: \"\\u0160\",\n  scaron: \"\\u0161\",\n  Yuml: \"\\u0178\",\n  fnof: \"\\u0192\",\n  circ: \"\\u02C6\",\n  tilde: \"\\u02DC\",\n  Alpha: \"\\u0391\",\n  Beta: \"\\u0392\",\n  Gamma: \"\\u0393\",\n  Delta: \"\\u0394\",\n  Epsilon: \"\\u0395\",\n  Zeta: \"\\u0396\",\n  Eta: \"\\u0397\",\n  Theta: \"\\u0398\",\n  Iota: \"\\u0399\",\n  Kappa: \"\\u039A\",\n  Lambda: \"\\u039B\",\n  Mu: \"\\u039C\",\n  Nu: \"\\u039D\",\n  Xi: \"\\u039E\",\n  Omicron: \"\\u039F\",\n  Pi: \"\\u03A0\",\n  Rho: \"\\u03A1\",\n  Sigma: \"\\u03A3\",\n  Tau: \"\\u03A4\",\n  Upsilon: \"\\u03A5\",\n  Phi: \"\\u03A6\",\n  Chi: \"\\u03A7\",\n  Psi: \"\\u03A8\",\n  Omega: \"\\u03A9\",\n  alpha: \"\\u03B1\",\n  beta: \"\\u03B2\",\n  gamma: \"\\u03B3\",\n  delta: \"\\u03B4\",\n  epsilon: \"\\u03B5\",\n  zeta: \"\\u03B6\",\n  eta: \"\\u03B7\",\n  theta: \"\\u03B8\",\n  iota: \"\\u03B9\",\n  kappa: \"\\u03BA\",\n  lambda: \"\\u03BB\",\n  mu: \"\\u03BC\",\n  nu: \"\\u03BD\",\n  xi: \"\\u03BE\",\n  omicron: \"\\u03BF\",\n  pi: \"\\u03C0\",\n  rho: \"\\u03C1\",\n  sigmaf: \"\\u03C2\",\n  sigma: \"\\u03C3\",\n  tau: \"\\u03C4\",\n  upsilon: \"\\u03C5\",\n  phi: \"\\u03C6\",\n  chi: \"\\u03C7\",\n  psi: \"\\u03C8\",\n  omega: \"\\u03C9\",\n  thetasym: \"\\u03D1\",\n  upsih: \"\\u03D2\",\n  piv: \"\\u03D6\",\n  ensp: \"\\u2002\",\n  emsp: \"\\u2003\",\n  thinsp: \"\\u2009\",\n  zwnj: \"\\u200C\",\n  zwj: \"\\u200D\",\n  lrm: \"\\u200E\",\n  rlm: \"\\u200F\",\n  ndash: \"\\u2013\",\n  mdash: \"\\u2014\",\n  lsquo: \"\\u2018\",\n  rsquo: \"\\u2019\",\n  sbquo: \"\\u201A\",\n  ldquo: \"\\u201C\",\n  rdquo: \"\\u201D\",\n  bdquo: \"\\u201E\",\n  dagger: \"\\u2020\",\n  Dagger: \"\\u2021\",\n  bull: \"\\u2022\",\n  hellip: \"\\u2026\",\n  permil: \"\\u2030\",\n  prime: \"\\u2032\",\n  Prime: \"\\u2033\",\n  lsaquo: \"\\u2039\",\n  rsaquo: \"\\u203A\",\n  oline: \"\\u203E\",\n  frasl: \"\\u2044\",\n  euro: \"\\u20AC\",\n  image: \"\\u2111\",\n  weierp: \"\\u2118\",\n  real: \"\\u211C\",\n  trade: \"\\u2122\",\n  alefsym: \"\\u2135\",\n  larr: \"\\u2190\",\n  uarr: \"\\u2191\",\n  rarr: \"\\u2192\",\n  darr: \"\\u2193\",\n  harr: \"\\u2194\",\n  crarr: \"\\u21B5\",\n  lArr: \"\\u21D0\",\n  uArr: \"\\u21D1\",\n  rArr: \"\\u21D2\",\n  dArr: \"\\u21D3\",\n  hArr: \"\\u21D4\",\n  forall: \"\\u2200\",\n  part: \"\\u2202\",\n  exist: \"\\u2203\",\n  empty: \"\\u2205\",\n  nabla: \"\\u2207\",\n  isin: \"\\u2208\",\n  notin: \"\\u2209\",\n  ni: \"\\u220B\",\n  prod: \"\\u220F\",\n  sum: \"\\u2211\",\n  minus: \"\\u2212\",\n  lowast: \"\\u2217\",\n  radic: \"\\u221A\",\n  prop: \"\\u221D\",\n  infin: \"\\u221E\",\n  ang: \"\\u2220\",\n  and: \"\\u2227\",\n  or: \"\\u2228\",\n  cap: \"\\u2229\",\n  cup: \"\\u222A\",\n  int: \"\\u222B\",\n  there4: \"\\u2234\",\n  sim: \"\\u223C\",\n  cong: \"\\u2245\",\n  asymp: \"\\u2248\",\n  ne: \"\\u2260\",\n  equiv: \"\\u2261\",\n  le: \"\\u2264\",\n  ge: \"\\u2265\",\n  sub: \"\\u2282\",\n  sup: \"\\u2283\",\n  nsub: \"\\u2284\",\n  sube: \"\\u2286\",\n  supe: \"\\u2287\",\n  oplus: \"\\u2295\",\n  otimes: \"\\u2297\",\n  perp: \"\\u22A5\",\n  sdot: \"\\u22C5\",\n  lceil: \"\\u2308\",\n  rceil: \"\\u2309\",\n  lfloor: \"\\u230A\",\n  rfloor: \"\\u230B\",\n  lang: \"\\u2329\",\n  rang: \"\\u232A\",\n  loz: \"\\u25CA\",\n  spades: \"\\u2660\",\n  clubs: \"\\u2663\",\n  hearts: \"\\u2665\",\n  diams: \"\\u2666\"\n};\n\nconst HEX_NUMBER = /^[\\da-fA-F]+$/;\nconst DECIMAL_NUMBER = /^\\d+$/;\nconst JsxErrors = Object.freeze({\n  AttributeIsEmpty: \"JSX attributes must only be assigned a non-empty expression\",\n  MissingClosingTagFragment: \"Expected corresponding JSX closing tag for <>\",\n  MissingClosingTagElement: \"Expected corresponding JSX closing tag for <%0>\",\n  UnsupportedJsxValue: \"JSX value should be either an expression or a quoted JSX text\",\n  UnterminatedJsxContent: \"Unterminated JSX contents\",\n  UnwrappedAdjacentJSXElements: \"Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?\"\n});\ntypes$1.j_oTag = new TokContext(\"<tag\", false);\ntypes$1.j_cTag = new TokContext(\"</tag\", false);\ntypes$1.j_expr = new TokContext(\"<tag>...</tag>\", true, true);\ntypes.jsxName = new TokenType(\"jsxName\");\ntypes.jsxText = new TokenType(\"jsxText\", {\n  beforeExpr: true\n});\ntypes.jsxTagStart = new TokenType(\"jsxTagStart\", {\n  startsExpr: true\n});\ntypes.jsxTagEnd = new TokenType(\"jsxTagEnd\");\n\ntypes.jsxTagStart.updateContext = function () {\n  this.state.context.push(types$1.j_expr);\n  this.state.context.push(types$1.j_oTag);\n  this.state.exprAllowed = false;\n};\n\ntypes.jsxTagEnd.updateContext = function (prevType) {\n  const out = this.state.context.pop();\n\n  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {\n    this.state.context.pop();\n    this.state.exprAllowed = this.curContext() === types$1.j_expr;\n  } else {\n    this.state.exprAllowed = true;\n  }\n};\n\nfunction isFragment(object) {\n  return object ? object.type === \"JSXOpeningFragment\" || object.type === \"JSXClosingFragment\" : false;\n}\n\nfunction getQualifiedJSXName(object) {\n  if (object.type === \"JSXIdentifier\") {\n    return object.name;\n  }\n\n  if (object.type === \"JSXNamespacedName\") {\n    return object.namespace.name + \":\" + object.name.name;\n  }\n\n  if (object.type === \"JSXMemberExpression\") {\n    return getQualifiedJSXName(object.object) + \".\" + getQualifiedJSXName(object.property);\n  }\n\n  throw new Error(\"Node had unexpected type: \" + object.type);\n}\n\nvar jsx = (superClass => class extends superClass {\n  jsxReadToken() {\n    let out = \"\";\n    let chunkStart = this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, JsxErrors.UnterminatedJsxContent);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 60:\n        case 123:\n          if (this.state.pos === this.state.start) {\n            if (ch === 60 && this.state.exprAllowed) {\n              ++this.state.pos;\n              return this.finishToken(types.jsxTagStart);\n            }\n\n            return super.getTokenFromCode(ch);\n          }\n\n          out += this.input.slice(chunkStart, this.state.pos);\n          return this.finishToken(types.jsxText, out);\n\n        case 38:\n          out += this.input.slice(chunkStart, this.state.pos);\n          out += this.jsxReadEntity();\n          chunkStart = this.state.pos;\n          break;\n\n        default:\n          if (isNewLine(ch)) {\n            out += this.input.slice(chunkStart, this.state.pos);\n            out += this.jsxReadNewLine(true);\n            chunkStart = this.state.pos;\n          } else {\n            ++this.state.pos;\n          }\n\n      }\n    }\n  }\n\n  jsxReadNewLine(normalizeCRLF) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let out;\n    ++this.state.pos;\n\n    if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {\n      ++this.state.pos;\n      out = normalizeCRLF ? \"\\n\" : \"\\r\\n\";\n    } else {\n      out = String.fromCharCode(ch);\n    }\n\n    ++this.state.curLine;\n    this.state.lineStart = this.state.pos;\n    return out;\n  }\n\n  jsxReadString(quote) {\n    let out = \"\";\n    let chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 38) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadEntity();\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.jsxReadNewLine(false);\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    return this.finishToken(types.string, out);\n  }\n\n  jsxReadEntity() {\n    let str = \"\";\n    let count = 0;\n    let entity;\n    let ch = this.input[this.state.pos];\n    const startPos = ++this.state.pos;\n\n    while (this.state.pos < this.length && count++ < 10) {\n      ch = this.input[this.state.pos++];\n\n      if (ch === \";\") {\n        if (str[0] === \"#\") {\n          if (str[1] === \"x\") {\n            str = str.substr(2);\n\n            if (HEX_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 16));\n            }\n          } else {\n            str = str.substr(1);\n\n            if (DECIMAL_NUMBER.test(str)) {\n              entity = String.fromCodePoint(parseInt(str, 10));\n            }\n          }\n        } else {\n          entity = entities[str];\n        }\n\n        break;\n      }\n\n      str += ch;\n    }\n\n    if (!entity) {\n      this.state.pos = startPos;\n      return \"&\";\n    }\n\n    return entity;\n  }\n\n  jsxReadWord() {\n    let ch;\n    const start = this.state.pos;\n\n    do {\n      ch = this.input.charCodeAt(++this.state.pos);\n    } while (isIdentifierChar(ch) || ch === 45);\n\n    return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));\n  }\n\n  jsxParseIdentifier() {\n    const node = this.startNode();\n\n    if (this.match(types.jsxName)) {\n      node.name = this.state.value;\n    } else if (this.state.type.keyword) {\n      node.name = this.state.type.keyword;\n    } else {\n      this.unexpected();\n    }\n\n    this.next();\n    return this.finishNode(node, \"JSXIdentifier\");\n  }\n\n  jsxParseNamespacedName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const name = this.jsxParseIdentifier();\n    if (!this.eat(types.colon)) return name;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.namespace = name;\n    node.name = this.jsxParseIdentifier();\n    return this.finishNode(node, \"JSXNamespacedName\");\n  }\n\n  jsxParseElementName() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let node = this.jsxParseNamespacedName();\n\n    if (node.type === \"JSXNamespacedName\") {\n      return node;\n    }\n\n    while (this.eat(types.dot)) {\n      const newNode = this.startNodeAt(startPos, startLoc);\n      newNode.object = node;\n      newNode.property = this.jsxParseIdentifier();\n      node = this.finishNode(newNode, \"JSXMemberExpression\");\n    }\n\n    return node;\n  }\n\n  jsxParseAttributeValue() {\n    let node;\n\n    switch (this.state.type) {\n      case types.braceL:\n        node = this.startNode();\n        this.next();\n        node = this.jsxParseExpressionContainer(node);\n\n        if (node.expression.type === \"JSXEmptyExpression\") {\n          this.raise(node.start, JsxErrors.AttributeIsEmpty);\n        }\n\n        return node;\n\n      case types.jsxTagStart:\n      case types.string:\n        return this.parseExprAtom();\n\n      default:\n        throw this.raise(this.state.start, JsxErrors.UnsupportedJsxValue);\n    }\n  }\n\n  jsxParseEmptyExpression() {\n    const node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);\n    return this.finishNodeAt(node, \"JSXEmptyExpression\", this.state.start, this.state.startLoc);\n  }\n\n  jsxParseSpreadChild(node) {\n    this.next();\n    node.expression = this.parseExpression();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXSpreadChild\");\n  }\n\n  jsxParseExpressionContainer(node) {\n    if (this.match(types.braceR)) {\n      node.expression = this.jsxParseEmptyExpression();\n    } else {\n      node.expression = this.parseExpression();\n    }\n\n    this.expect(types.braceR);\n    return this.finishNode(node, \"JSXExpressionContainer\");\n  }\n\n  jsxParseAttribute() {\n    const node = this.startNode();\n\n    if (this.eat(types.braceL)) {\n      this.expect(types.ellipsis);\n      node.argument = this.parseMaybeAssign();\n      this.expect(types.braceR);\n      return this.finishNode(node, \"JSXSpreadAttribute\");\n    }\n\n    node.name = this.jsxParseNamespacedName();\n    node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;\n    return this.finishNode(node, \"JSXAttribute\");\n  }\n\n  jsxParseOpeningElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXOpeningFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    return this.jsxParseOpeningElementAfterName(node);\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    const attributes = [];\n\n    while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {\n      attributes.push(this.jsxParseAttribute());\n    }\n\n    node.attributes = attributes;\n    node.selfClosing = this.eat(types.slash);\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXOpeningElement\");\n  }\n\n  jsxParseClosingElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n\n    if (this.match(types.jsxTagEnd)) {\n      this.expect(types.jsxTagEnd);\n      return this.finishNode(node, \"JSXClosingFragment\");\n    }\n\n    node.name = this.jsxParseElementName();\n    this.expect(types.jsxTagEnd);\n    return this.finishNode(node, \"JSXClosingElement\");\n  }\n\n  jsxParseElementAt(startPos, startLoc) {\n    const node = this.startNodeAt(startPos, startLoc);\n    const children = [];\n    const openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);\n    let closingElement = null;\n\n    if (!openingElement.selfClosing) {\n      contents: for (;;) {\n        switch (this.state.type) {\n          case types.jsxTagStart:\n            startPos = this.state.start;\n            startLoc = this.state.startLoc;\n            this.next();\n\n            if (this.eat(types.slash)) {\n              closingElement = this.jsxParseClosingElementAt(startPos, startLoc);\n              break contents;\n            }\n\n            children.push(this.jsxParseElementAt(startPos, startLoc));\n            break;\n\n          case types.jsxText:\n            children.push(this.parseExprAtom());\n            break;\n\n          case types.braceL:\n            {\n              const node = this.startNode();\n              this.next();\n\n              if (this.match(types.ellipsis)) {\n                children.push(this.jsxParseSpreadChild(node));\n              } else {\n                children.push(this.jsxParseExpressionContainer(node));\n              }\n\n              break;\n            }\n\n          default:\n            throw this.unexpected();\n        }\n      }\n\n      if (isFragment(openingElement) && !isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagFragment);\n      } else if (!isFragment(openingElement) && isFragment(closingElement)) {\n        this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n      } else if (!isFragment(openingElement) && !isFragment(closingElement)) {\n        if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {\n          this.raise(closingElement.start, JsxErrors.MissingClosingTagElement, getQualifiedJSXName(openingElement.name));\n        }\n      }\n    }\n\n    if (isFragment(openingElement)) {\n      node.openingFragment = openingElement;\n      node.closingFragment = closingElement;\n    } else {\n      node.openingElement = openingElement;\n      node.closingElement = closingElement;\n    }\n\n    node.children = children;\n\n    if (this.isRelational(\"<\")) {\n      throw this.raise(this.state.start, JsxErrors.UnwrappedAdjacentJSXElements);\n    }\n\n    return isFragment(openingElement) ? this.finishNode(node, \"JSXFragment\") : this.finishNode(node, \"JSXElement\");\n  }\n\n  jsxParseElement() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.next();\n    return this.jsxParseElementAt(startPos, startLoc);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.match(types.jsxText)) {\n      return this.parseLiteral(this.state.value, \"JSXText\");\n    } else if (this.match(types.jsxTagStart)) {\n      return this.jsxParseElement();\n    } else if (this.isRelational(\"<\") && this.input.charCodeAt(this.state.pos) !== 33) {\n      this.finishToken(types.jsxTagStart);\n      return this.jsxParseElement();\n    } else {\n      return super.parseExprAtom(refExpressionErrors);\n    }\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inPropertyName) return super.getTokenFromCode(code);\n    const context = this.curContext();\n\n    if (context === types$1.j_expr) {\n      return this.jsxReadToken();\n    }\n\n    if (context === types$1.j_oTag || context === types$1.j_cTag) {\n      if (isIdentifierStart(code)) {\n        return this.jsxReadWord();\n      }\n\n      if (code === 62) {\n        ++this.state.pos;\n        return this.finishToken(types.jsxTagEnd);\n      }\n\n      if ((code === 34 || code === 39) && context === types$1.j_oTag) {\n        return this.jsxReadString(code);\n      }\n    }\n\n    if (code === 60 && this.state.exprAllowed && this.input.charCodeAt(this.state.pos + 1) !== 33) {\n      ++this.state.pos;\n      return this.finishToken(types.jsxTagStart);\n    }\n\n    return super.getTokenFromCode(code);\n  }\n\n  updateContext(prevType) {\n    if (this.match(types.braceL)) {\n      const curContext = this.curContext();\n\n      if (curContext === types$1.j_oTag) {\n        this.state.context.push(types$1.braceExpression);\n      } else if (curContext === types$1.j_expr) {\n        this.state.context.push(types$1.templateQuasi);\n      } else {\n        super.updateContext(prevType);\n      }\n\n      this.state.exprAllowed = true;\n    } else if (this.match(types.slash) && prevType === types.jsxTagStart) {\n      this.state.context.length -= 2;\n      this.state.context.push(types$1.j_cTag);\n      this.state.exprAllowed = false;\n    } else {\n      return super.updateContext(prevType);\n    }\n  }\n\n});\n\nclass Scope {\n  constructor(flags) {\n    this.var = [];\n    this.lexical = [];\n    this.functions = [];\n    this.flags = flags;\n  }\n\n}\nclass ScopeHandler {\n  constructor(raise, inModule) {\n    this.scopeStack = [];\n    this.undefinedExports = new Map();\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n    this.inModule = inModule;\n  }\n\n  get inFunction() {\n    return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get allowSuper() {\n    return (this.currentThisScope().flags & SCOPE_SUPER) > 0;\n  }\n\n  get allowDirectSuper() {\n    return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;\n  }\n\n  get inClass() {\n    return (this.currentThisScope().flags & SCOPE_CLASS) > 0;\n  }\n\n  get inNonArrowFunction() {\n    return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0;\n  }\n\n  get treatFunctionsAsVar() {\n    return this.treatFunctionsAsVarInScope(this.currentScope());\n  }\n\n  createScope(flags) {\n    return new Scope(flags);\n  }\n\n  enter(flags) {\n    this.scopeStack.push(this.createScope(flags));\n  }\n\n  exit() {\n    this.scopeStack.pop();\n  }\n\n  treatFunctionsAsVarInScope(scope) {\n    return !!(scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_PROGRAM);\n  }\n\n  declareName(name, bindingType, pos) {\n    let scope = this.currentScope();\n\n    if (bindingType & BIND_SCOPE_LEXICAL || bindingType & BIND_SCOPE_FUNCTION) {\n      this.checkRedeclarationInScope(scope, name, bindingType, pos);\n\n      if (bindingType & BIND_SCOPE_FUNCTION) {\n        scope.functions.push(name);\n      } else {\n        scope.lexical.push(name);\n      }\n\n      if (bindingType & BIND_SCOPE_LEXICAL) {\n        this.maybeExportDefined(scope, name);\n      }\n    } else if (bindingType & BIND_SCOPE_VAR) {\n      for (let i = this.scopeStack.length - 1; i >= 0; --i) {\n        scope = this.scopeStack[i];\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        scope.var.push(name);\n        this.maybeExportDefined(scope, name);\n        if (scope.flags & SCOPE_VAR) break;\n      }\n    }\n\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  maybeExportDefined(scope, name) {\n    if (this.inModule && scope.flags & SCOPE_PROGRAM) {\n      this.undefinedExports.delete(name);\n    }\n  }\n\n  checkRedeclarationInScope(scope, name, bindingType, pos) {\n    if (this.isRedeclaredInScope(scope, name, bindingType)) {\n      this.raise(pos, Errors.VarRedeclaration, name);\n    }\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (!(bindingType & BIND_KIND_VALUE)) return false;\n\n    if (bindingType & BIND_SCOPE_LEXICAL) {\n      return scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n    }\n\n    if (bindingType & BIND_SCOPE_FUNCTION) {\n      return scope.lexical.indexOf(name) > -1 || !this.treatFunctionsAsVarInScope(scope) && scope.var.indexOf(name) > -1;\n    }\n\n    return scope.lexical.indexOf(name) > -1 && !(scope.flags & SCOPE_SIMPLE_CATCH && scope.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope) && scope.functions.indexOf(name) > -1;\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1 && this.scopeStack[0].functions.indexOf(id.name) === -1) {\n      this.undefinedExports.set(id.name, id.start);\n    }\n  }\n\n  currentScope() {\n    return this.scopeStack[this.scopeStack.length - 1];\n  }\n\n  currentVarScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if (scope.flags & SCOPE_VAR) {\n        return scope;\n      }\n    }\n  }\n\n  currentThisScope() {\n    for (let i = this.scopeStack.length - 1;; i--) {\n      const scope = this.scopeStack[i];\n\n      if ((scope.flags & SCOPE_VAR || scope.flags & SCOPE_CLASS) && !(scope.flags & SCOPE_ARROW)) {\n        return scope;\n      }\n    }\n  }\n\n}\n\nclass TypeScriptScope extends Scope {\n  constructor(...args) {\n    super(...args);\n    this.types = [];\n    this.enums = [];\n    this.constEnums = [];\n    this.classes = [];\n    this.exportOnlyBindings = [];\n  }\n\n}\n\nclass TypeScriptScopeHandler extends ScopeHandler {\n  createScope(flags) {\n    return new TypeScriptScope(flags);\n  }\n\n  declareName(name, bindingType, pos) {\n    const scope = this.currentScope();\n\n    if (bindingType & BIND_FLAGS_TS_EXPORT_ONLY) {\n      this.maybeExportDefined(scope, name);\n      scope.exportOnlyBindings.push(name);\n      return;\n    }\n\n    super.declareName(...arguments);\n\n    if (bindingType & BIND_KIND_TYPE) {\n      if (!(bindingType & BIND_KIND_VALUE)) {\n        this.checkRedeclarationInScope(scope, name, bindingType, pos);\n        this.maybeExportDefined(scope, name);\n      }\n\n      scope.types.push(name);\n    }\n\n    if (bindingType & BIND_FLAGS_TS_ENUM) scope.enums.push(name);\n    if (bindingType & BIND_FLAGS_TS_CONST_ENUM) scope.constEnums.push(name);\n    if (bindingType & BIND_FLAGS_CLASS) scope.classes.push(name);\n  }\n\n  isRedeclaredInScope(scope, name, bindingType) {\n    if (scope.enums.indexOf(name) > -1) {\n      if (bindingType & BIND_FLAGS_TS_ENUM) {\n        const isConst = !!(bindingType & BIND_FLAGS_TS_CONST_ENUM);\n        const wasConst = scope.constEnums.indexOf(name) > -1;\n        return isConst !== wasConst;\n      }\n\n      return true;\n    }\n\n    if (bindingType & BIND_FLAGS_CLASS && scope.classes.indexOf(name) > -1) {\n      if (scope.lexical.indexOf(name) > -1) {\n        return !!(bindingType & BIND_KIND_VALUE);\n      } else {\n        return false;\n      }\n    }\n\n    if (bindingType & BIND_KIND_TYPE && scope.types.indexOf(name) > -1) {\n      return true;\n    }\n\n    return super.isRedeclaredInScope(...arguments);\n  }\n\n  checkLocalExport(id) {\n    if (this.scopeStack[0].types.indexOf(id.name) === -1 && this.scopeStack[0].exportOnlyBindings.indexOf(id.name) === -1) {\n      super.checkLocalExport(id);\n    }\n  }\n\n}\n\nconst PARAM = 0b000,\n      PARAM_YIELD = 0b001,\n      PARAM_AWAIT = 0b010,\n      PARAM_RETURN = 0b100;\nclass ProductionParameterHandler {\n  constructor() {\n    this.stacks = [];\n  }\n\n  enter(flags) {\n    this.stacks.push(flags);\n  }\n\n  exit() {\n    this.stacks.pop();\n  }\n\n  currentFlags() {\n    return this.stacks[this.stacks.length - 1];\n  }\n\n  get hasAwait() {\n    return (this.currentFlags() & PARAM_AWAIT) > 0;\n  }\n\n  get hasYield() {\n    return (this.currentFlags() & PARAM_YIELD) > 0;\n  }\n\n  get hasReturn() {\n    return (this.currentFlags() & PARAM_RETURN) > 0;\n  }\n\n}\nfunction functionFlags(isAsync, isGenerator) {\n  return (isAsync ? PARAM_AWAIT : 0) | (isGenerator ? PARAM_YIELD : 0);\n}\n\nfunction nonNull(x) {\n  if (x == null) {\n    throw new Error(`Unexpected ${x} value.`);\n  }\n\n  return x;\n}\n\nfunction assert(x) {\n  if (!x) {\n    throw new Error(\"Assert fail\");\n  }\n}\n\nconst TSErrors = Object.freeze({\n  ClassMethodHasDeclare: \"Class methods cannot have the 'declare' modifier\",\n  ClassMethodHasReadonly: \"Class methods cannot have the 'readonly' modifier\",\n  DeclareClassFieldHasInitializer: \"'declare' class fields cannot have an initializer\",\n  DuplicateModifier: \"Duplicate modifier: '%0'\",\n  EmptyHeritageClauseType: \"'%0' list cannot be empty.\",\n  IndexSignatureHasAbstract: \"Index signatures cannot have the 'abstract' modifier\",\n  IndexSignatureHasAccessibility: \"Index signatures cannot have an accessibility modifier ('%0')\",\n  IndexSignatureHasStatic: \"Index signatures cannot have the 'static' modifier\",\n  OptionalTypeBeforeRequired: \"A required element cannot follow an optional element.\",\n  PatternIsOptional: \"A binding pattern parameter cannot be optional in an implementation signature.\",\n  PrivateElementHasAbstract: \"Private elements cannot have the 'abstract' modifier.\",\n  PrivateElementHasAccessibility: \"Private elements cannot have an accessibility modifier ('%0')\",\n  TemplateTypeHasSubstitution: \"Template literal types cannot have any substitution\",\n  TypeAnnotationAfterAssign: \"Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`\",\n  UnexpectedReadonly: \"'readonly' type modifier is only permitted on array and tuple literal types.\",\n  UnexpectedTypeAnnotation: \"Did not expect a type annotation here.\",\n  UnexpectedTypeCastInParameter: \"Unexpected type cast in parameter position.\",\n  UnsupportedImportTypeArgument: \"Argument in a type import must be a string literal\",\n  UnsupportedParameterPropertyKind: \"A parameter property may not be declared using a binding pattern.\",\n  UnsupportedSignatureParameterKind: \"Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got %0\"\n});\n\nfunction keywordTypeFromName(value) {\n  switch (value) {\n    case \"any\":\n      return \"TSAnyKeyword\";\n\n    case \"boolean\":\n      return \"TSBooleanKeyword\";\n\n    case \"bigint\":\n      return \"TSBigIntKeyword\";\n\n    case \"never\":\n      return \"TSNeverKeyword\";\n\n    case \"number\":\n      return \"TSNumberKeyword\";\n\n    case \"object\":\n      return \"TSObjectKeyword\";\n\n    case \"string\":\n      return \"TSStringKeyword\";\n\n    case \"symbol\":\n      return \"TSSymbolKeyword\";\n\n    case \"undefined\":\n      return \"TSUndefinedKeyword\";\n\n    case \"unknown\":\n      return \"TSUnknownKeyword\";\n\n    default:\n      return undefined;\n  }\n}\n\nvar typescript = (superClass => class extends superClass {\n  getScopeHandler() {\n    return TypeScriptScopeHandler;\n  }\n\n  tsIsIdentifier() {\n    return this.match(types.name);\n  }\n\n  tsNextTokenCanFollowModifier() {\n    this.next();\n    return !this.hasPrecedingLineBreak() && !this.match(types.parenL) && !this.match(types.parenR) && !this.match(types.colon) && !this.match(types.eq) && !this.match(types.question) && !this.match(types.bang);\n  }\n\n  tsParseModifier(allowedModifiers) {\n    if (!this.match(types.name)) {\n      return undefined;\n    }\n\n    const modifier = this.state.value;\n\n    if (allowedModifiers.indexOf(modifier) !== -1 && this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {\n      return modifier;\n    }\n\n    return undefined;\n  }\n\n  tsParseModifiers(modified, allowedModifiers) {\n    for (;;) {\n      const startPos = this.state.start;\n      const modifier = this.tsParseModifier(allowedModifiers);\n      if (!modifier) break;\n\n      if (Object.hasOwnProperty.call(modified, modifier)) {\n        this.raise(startPos, TSErrors.DuplicateModifier, modifier);\n      }\n\n      modified[modifier] = true;\n    }\n  }\n\n  tsIsListTerminator(kind) {\n    switch (kind) {\n      case \"EnumMembers\":\n      case \"TypeMembers\":\n        return this.match(types.braceR);\n\n      case \"HeritageClauseElement\":\n        return this.match(types.braceL);\n\n      case \"TupleElementTypes\":\n        return this.match(types.bracketR);\n\n      case \"TypeParametersOrArguments\":\n        return this.isRelational(\">\");\n    }\n\n    throw new Error(\"Unreachable\");\n  }\n\n  tsParseList(kind, parseElement) {\n    const result = [];\n\n    while (!this.tsIsListTerminator(kind)) {\n      result.push(parseElement());\n    }\n\n    return result;\n  }\n\n  tsParseDelimitedList(kind, parseElement) {\n    return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true));\n  }\n\n  tsParseDelimitedListWorker(kind, parseElement, expectSuccess) {\n    const result = [];\n\n    for (;;) {\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      const element = parseElement();\n\n      if (element == null) {\n        return undefined;\n      }\n\n      result.push(element);\n\n      if (this.eat(types.comma)) {\n        continue;\n      }\n\n      if (this.tsIsListTerminator(kind)) {\n        break;\n      }\n\n      if (expectSuccess) {\n        this.expect(types.comma);\n      }\n\n      return undefined;\n    }\n\n    return result;\n  }\n\n  tsParseBracketedList(kind, parseElement, bracket, skipFirstToken) {\n    if (!skipFirstToken) {\n      if (bracket) {\n        this.expect(types.bracketL);\n      } else {\n        this.expectRelational(\"<\");\n      }\n    }\n\n    const result = this.tsParseDelimitedList(kind, parseElement);\n\n    if (bracket) {\n      this.expect(types.bracketR);\n    } else {\n      this.expectRelational(\">\");\n    }\n\n    return result;\n  }\n\n  tsParseImportType() {\n    const node = this.startNode();\n    this.expect(types._import);\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      this.raise(this.state.start, TSErrors.UnsupportedImportTypeArgument);\n    }\n\n    node.argument = this.parseExprAtom();\n    this.expect(types.parenR);\n\n    if (this.eat(types.dot)) {\n      node.qualifier = this.tsParseEntityName(true);\n    }\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSImportType\");\n  }\n\n  tsParseEntityName(allowReservedWords) {\n    let entity = this.parseIdentifier();\n\n    while (this.eat(types.dot)) {\n      const node = this.startNodeAtNode(entity);\n      node.left = entity;\n      node.right = this.parseIdentifier(allowReservedWords);\n      entity = this.finishNode(node, \"TSQualifiedName\");\n    }\n\n    return entity;\n  }\n\n  tsParseTypeReference() {\n    const node = this.startNode();\n    node.typeName = this.tsParseEntityName(false);\n\n    if (!this.hasPrecedingLineBreak() && this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSTypeReference\");\n  }\n\n  tsParseThisTypePredicate(lhs) {\n    this.next();\n    const node = this.startNodeAtNode(lhs);\n    node.parameterName = lhs;\n    node.typeAnnotation = this.tsParseTypeAnnotation(false);\n    return this.finishNode(node, \"TSTypePredicate\");\n  }\n\n  tsParseThisTypeNode() {\n    const node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"TSThisType\");\n  }\n\n  tsParseTypeQuery() {\n    const node = this.startNode();\n    this.expect(types._typeof);\n\n    if (this.match(types._import)) {\n      node.exprName = this.tsParseImportType();\n    } else {\n      node.exprName = this.tsParseEntityName(true);\n    }\n\n    return this.finishNode(node, \"TSTypeQuery\");\n  }\n\n  tsParseTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsEatThenParseType(types._extends);\n    node.default = this.tsEatThenParseType(types.eq);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsTryParseTypeParameters() {\n    if (this.isRelational(\"<\")) {\n      return this.tsParseTypeParameters();\n    }\n  }\n\n  tsParseTypeParameters() {\n    const node = this.startNode();\n\n    if (this.isRelational(\"<\") || this.match(types.jsxTagStart)) {\n      this.next();\n    } else {\n      this.unexpected();\n    }\n\n    node.params = this.tsParseBracketedList(\"TypeParametersOrArguments\", this.tsParseTypeParameter.bind(this), false, true);\n    return this.finishNode(node, \"TSTypeParameterDeclaration\");\n  }\n\n  tsTryNextParseConstantContext() {\n    if (this.lookahead().type === types._const) {\n      this.next();\n      return this.tsParseTypeReference();\n    }\n\n    return null;\n  }\n\n  tsFillSignature(returnToken, signature) {\n    const returnTokenRequired = returnToken === types.arrow;\n    signature.typeParameters = this.tsTryParseTypeParameters();\n    this.expect(types.parenL);\n    signature.parameters = this.tsParseBindingListForSignature();\n\n    if (returnTokenRequired) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    } else if (this.match(returnToken)) {\n      signature.typeAnnotation = this.tsParseTypeOrTypePredicateAnnotation(returnToken);\n    }\n  }\n\n  tsParseBindingListForSignature() {\n    return this.parseBindingList(types.parenR, 41).map(pattern => {\n      if (pattern.type !== \"Identifier\" && pattern.type !== \"RestElement\" && pattern.type !== \"ObjectPattern\" && pattern.type !== \"ArrayPattern\") {\n        this.raise(pattern.start, TSErrors.UnsupportedSignatureParameterKind, pattern.type);\n      }\n\n      return pattern;\n    });\n  }\n\n  tsParseTypeMemberSemicolon() {\n    if (!this.eat(types.comma)) {\n      this.semicolon();\n    }\n  }\n\n  tsParseSignatureMember(kind, node) {\n    this.tsFillSignature(types.colon, node);\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, kind);\n  }\n\n  tsIsUnambiguouslyIndexSignature() {\n    this.next();\n    return this.eat(types.name) && this.match(types.colon);\n  }\n\n  tsTryParseIndexSignature(node) {\n    if (!(this.match(types.bracketL) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {\n      return undefined;\n    }\n\n    this.expect(types.bracketL);\n    const id = this.parseIdentifier();\n    id.typeAnnotation = this.tsParseTypeAnnotation();\n    this.resetEndLocation(id);\n    this.expect(types.bracketR);\n    node.parameters = [id];\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n    this.tsParseTypeMemberSemicolon();\n    return this.finishNode(node, \"TSIndexSignature\");\n  }\n\n  tsParsePropertyOrMethodSignature(node, readonly) {\n    if (this.eat(types.question)) node.optional = true;\n    const nodeAny = node;\n\n    if (!readonly && (this.match(types.parenL) || this.isRelational(\"<\"))) {\n      const method = nodeAny;\n      this.tsFillSignature(types.colon, method);\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(method, \"TSMethodSignature\");\n    } else {\n      const property = nodeAny;\n      if (readonly) property.readonly = true;\n      const type = this.tsTryParseTypeAnnotation();\n      if (type) property.typeAnnotation = type;\n      this.tsParseTypeMemberSemicolon();\n      return this.finishNode(property, \"TSPropertySignature\");\n    }\n  }\n\n  tsParseTypeMember() {\n    const node = this.startNode();\n\n    if (this.match(types.parenL) || this.isRelational(\"<\")) {\n      return this.tsParseSignatureMember(\"TSCallSignatureDeclaration\", node);\n    }\n\n    if (this.match(types._new)) {\n      const id = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL) || this.isRelational(\"<\")) {\n        return this.tsParseSignatureMember(\"TSConstructSignatureDeclaration\", node);\n      } else {\n        node.key = this.createIdentifier(id, \"new\");\n        return this.tsParsePropertyOrMethodSignature(node, false);\n      }\n    }\n\n    const readonly = !!this.tsParseModifier([\"readonly\"]);\n    const idx = this.tsTryParseIndexSignature(node);\n\n    if (idx) {\n      if (readonly) node.readonly = true;\n      return idx;\n    }\n\n    this.parsePropertyName(node, false);\n    return this.tsParsePropertyOrMethodSignature(node, readonly);\n  }\n\n  tsParseTypeLiteral() {\n    const node = this.startNode();\n    node.members = this.tsParseObjectTypeMembers();\n    return this.finishNode(node, \"TSTypeLiteral\");\n  }\n\n  tsParseObjectTypeMembers() {\n    this.expect(types.braceL);\n    const members = this.tsParseList(\"TypeMembers\", this.tsParseTypeMember.bind(this));\n    this.expect(types.braceR);\n    return members;\n  }\n\n  tsIsStartOfMappedType() {\n    this.next();\n\n    if (this.eat(types.plusMin)) {\n      return this.isContextual(\"readonly\");\n    }\n\n    if (this.isContextual(\"readonly\")) {\n      this.next();\n    }\n\n    if (!this.match(types.bracketL)) {\n      return false;\n    }\n\n    this.next();\n\n    if (!this.tsIsIdentifier()) {\n      return false;\n    }\n\n    this.next();\n    return this.match(types._in);\n  }\n\n  tsParseMappedTypeParameter() {\n    const node = this.startNode();\n    node.name = this.parseIdentifierName(node.start);\n    node.constraint = this.tsExpectThenParseType(types._in);\n    return this.finishNode(node, \"TSTypeParameter\");\n  }\n\n  tsParseMappedType() {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (this.match(types.plusMin)) {\n      node.readonly = this.state.value;\n      this.next();\n      this.expectContextual(\"readonly\");\n    } else if (this.eatContextual(\"readonly\")) {\n      node.readonly = true;\n    }\n\n    this.expect(types.bracketL);\n    node.typeParameter = this.tsParseMappedTypeParameter();\n    this.expect(types.bracketR);\n\n    if (this.match(types.plusMin)) {\n      node.optional = this.state.value;\n      this.next();\n      this.expect(types.question);\n    } else if (this.eat(types.question)) {\n      node.optional = true;\n    }\n\n    node.typeAnnotation = this.tsTryParseType();\n    this.semicolon();\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSMappedType\");\n  }\n\n  tsParseTupleType() {\n    const node = this.startNode();\n    node.elementTypes = this.tsParseBracketedList(\"TupleElementTypes\", this.tsParseTupleElementType.bind(this), true, false);\n    let seenOptionalElement = false;\n    node.elementTypes.forEach(elementNode => {\n      if (elementNode.type === \"TSOptionalType\") {\n        seenOptionalElement = true;\n      } else if (seenOptionalElement && elementNode.type !== \"TSRestType\") {\n        this.raise(elementNode.start, TSErrors.OptionalTypeBeforeRequired);\n      }\n    });\n    return this.finishNode(node, \"TSTupleType\");\n  }\n\n  tsParseTupleElementType() {\n    if (this.match(types.ellipsis)) {\n      const restNode = this.startNode();\n      this.next();\n      restNode.typeAnnotation = this.tsParseType();\n\n      if (this.match(types.comma) && this.lookaheadCharCode() !== 93) {\n        this.raiseRestNotLast(this.state.start);\n      }\n\n      return this.finishNode(restNode, \"TSRestType\");\n    }\n\n    const type = this.tsParseType();\n\n    if (this.eat(types.question)) {\n      const optionalTypeNode = this.startNodeAtNode(type);\n      optionalTypeNode.typeAnnotation = type;\n      return this.finishNode(optionalTypeNode, \"TSOptionalType\");\n    }\n\n    return type;\n  }\n\n  tsParseParenthesizedType() {\n    const node = this.startNode();\n    this.expect(types.parenL);\n    node.typeAnnotation = this.tsParseType();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSParenthesizedType\");\n  }\n\n  tsParseFunctionOrConstructorType(type) {\n    const node = this.startNode();\n\n    if (type === \"TSConstructorType\") {\n      this.expect(types._new);\n    }\n\n    this.tsFillSignature(types.arrow, node);\n    return this.finishNode(node, type);\n  }\n\n  tsParseLiteralTypeNode() {\n    const node = this.startNode();\n\n    node.literal = (() => {\n      switch (this.state.type) {\n        case types.num:\n        case types.string:\n        case types._true:\n        case types._false:\n          return this.parseExprAtom();\n\n        default:\n          throw this.unexpected();\n      }\n    })();\n\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseTemplateLiteralType() {\n    const node = this.startNode();\n    const templateNode = this.parseTemplate(false);\n\n    if (templateNode.expressions.length > 0) {\n      this.raise(templateNode.expressions[0].start, TSErrors.TemplateTypeHasSubstitution);\n    }\n\n    node.literal = templateNode;\n    return this.finishNode(node, \"TSLiteralType\");\n  }\n\n  tsParseThisTypeOrThisTypePredicate() {\n    const thisKeyword = this.tsParseThisTypeNode();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      return this.tsParseThisTypePredicate(thisKeyword);\n    } else {\n      return thisKeyword;\n    }\n  }\n\n  tsParseNonArrayType() {\n    switch (this.state.type) {\n      case types.name:\n      case types._void:\n      case types._null:\n        {\n          const type = this.match(types._void) ? \"TSVoidKeyword\" : this.match(types._null) ? \"TSNullKeyword\" : keywordTypeFromName(this.state.value);\n\n          if (type !== undefined && this.lookaheadCharCode() !== 46) {\n            const node = this.startNode();\n            this.next();\n            return this.finishNode(node, type);\n          }\n\n          return this.tsParseTypeReference();\n        }\n\n      case types.string:\n      case types.num:\n      case types._true:\n      case types._false:\n        return this.tsParseLiteralTypeNode();\n\n      case types.plusMin:\n        if (this.state.value === \"-\") {\n          const node = this.startNode();\n\n          if (this.lookahead().type !== types.num) {\n            throw this.unexpected();\n          }\n\n          node.literal = this.parseMaybeUnary();\n          return this.finishNode(node, \"TSLiteralType\");\n        }\n\n        break;\n\n      case types._this:\n        return this.tsParseThisTypeOrThisTypePredicate();\n\n      case types._typeof:\n        return this.tsParseTypeQuery();\n\n      case types._import:\n        return this.tsParseImportType();\n\n      case types.braceL:\n        return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();\n\n      case types.bracketL:\n        return this.tsParseTupleType();\n\n      case types.parenL:\n        return this.tsParseParenthesizedType();\n\n      case types.backQuote:\n        return this.tsParseTemplateLiteralType();\n    }\n\n    throw this.unexpected();\n  }\n\n  tsParseArrayTypeOrHigher() {\n    let type = this.tsParseNonArrayType();\n\n    while (!this.hasPrecedingLineBreak() && this.eat(types.bracketL)) {\n      if (this.match(types.bracketR)) {\n        const node = this.startNodeAtNode(type);\n        node.elementType = type;\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSArrayType\");\n      } else {\n        const node = this.startNodeAtNode(type);\n        node.objectType = type;\n        node.indexType = this.tsParseType();\n        this.expect(types.bracketR);\n        type = this.finishNode(node, \"TSIndexedAccessType\");\n      }\n    }\n\n    return type;\n  }\n\n  tsParseTypeOperator(operator) {\n    const node = this.startNode();\n    this.expectContextual(operator);\n    node.operator = operator;\n    node.typeAnnotation = this.tsParseTypeOperatorOrHigher();\n\n    if (operator === \"readonly\") {\n      this.tsCheckTypeAnnotationForReadOnly(node);\n    }\n\n    return this.finishNode(node, \"TSTypeOperator\");\n  }\n\n  tsCheckTypeAnnotationForReadOnly(node) {\n    switch (node.typeAnnotation.type) {\n      case \"TSTupleType\":\n      case \"TSArrayType\":\n        return;\n\n      default:\n        this.raise(node.start, TSErrors.UnexpectedReadonly);\n    }\n  }\n\n  tsParseInferType() {\n    const node = this.startNode();\n    this.expectContextual(\"infer\");\n    const typeParameter = this.startNode();\n    typeParameter.name = this.parseIdentifierName(typeParameter.start);\n    node.typeParameter = this.finishNode(typeParameter, \"TSTypeParameter\");\n    return this.finishNode(node, \"TSInferType\");\n  }\n\n  tsParseTypeOperatorOrHigher() {\n    const operator = [\"keyof\", \"unique\", \"readonly\"].find(kw => this.isContextual(kw));\n    return operator ? this.tsParseTypeOperator(operator) : this.isContextual(\"infer\") ? this.tsParseInferType() : this.tsParseArrayTypeOrHigher();\n  }\n\n  tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {\n    this.eat(operator);\n    let type = parseConstituentType();\n\n    if (this.match(operator)) {\n      const types = [type];\n\n      while (this.eat(operator)) {\n        types.push(parseConstituentType());\n      }\n\n      const node = this.startNodeAtNode(type);\n      node.types = types;\n      type = this.finishNode(node, kind);\n    }\n\n    return type;\n  }\n\n  tsParseIntersectionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSIntersectionType\", this.tsParseTypeOperatorOrHigher.bind(this), types.bitwiseAND);\n  }\n\n  tsParseUnionTypeOrHigher() {\n    return this.tsParseUnionOrIntersectionType(\"TSUnionType\", this.tsParseIntersectionTypeOrHigher.bind(this), types.bitwiseOR);\n  }\n\n  tsIsStartOfFunctionType() {\n    if (this.isRelational(\"<\")) {\n      return true;\n    }\n\n    return this.match(types.parenL) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));\n  }\n\n  tsSkipParameterStart() {\n    if (this.match(types.name) || this.match(types._this)) {\n      this.next();\n      return true;\n    }\n\n    if (this.match(types.braceL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.braceL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.braceR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    if (this.match(types.bracketL)) {\n      let braceStackCounter = 1;\n      this.next();\n\n      while (braceStackCounter > 0) {\n        if (this.match(types.bracketL)) {\n          ++braceStackCounter;\n        } else if (this.match(types.bracketR)) {\n          --braceStackCounter;\n        }\n\n        this.next();\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  tsIsUnambiguouslyStartOfFunctionType() {\n    this.next();\n\n    if (this.match(types.parenR) || this.match(types.ellipsis)) {\n      return true;\n    }\n\n    if (this.tsSkipParameterStart()) {\n      if (this.match(types.colon) || this.match(types.comma) || this.match(types.question) || this.match(types.eq)) {\n        return true;\n      }\n\n      if (this.match(types.parenR)) {\n        this.next();\n\n        if (this.match(types.arrow)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  tsParseTypeOrTypePredicateAnnotation(returnToken) {\n    return this.tsInType(() => {\n      const t = this.startNode();\n      this.expect(returnToken);\n      const asserts = this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));\n\n      if (asserts && this.match(types._this)) {\n        let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();\n\n        if (thisTypePredicate.type === \"TSThisType\") {\n          const node = this.startNodeAtNode(t);\n          node.parameterName = thisTypePredicate;\n          node.asserts = true;\n          thisTypePredicate = this.finishNode(node, \"TSTypePredicate\");\n        } else {\n          thisTypePredicate.asserts = true;\n        }\n\n        t.typeAnnotation = thisTypePredicate;\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));\n\n      if (!typePredicateVariable) {\n        if (!asserts) {\n          return this.tsParseTypeAnnotation(false, t);\n        }\n\n        const node = this.startNodeAtNode(t);\n        node.parameterName = this.parseIdentifier();\n        node.asserts = asserts;\n        t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n        return this.finishNode(t, \"TSTypeAnnotation\");\n      }\n\n      const type = this.tsParseTypeAnnotation(false);\n      const node = this.startNodeAtNode(t);\n      node.parameterName = typePredicateVariable;\n      node.typeAnnotation = type;\n      node.asserts = asserts;\n      t.typeAnnotation = this.finishNode(node, \"TSTypePredicate\");\n      return this.finishNode(t, \"TSTypeAnnotation\");\n    });\n  }\n\n  tsTryParseTypeOrTypePredicateAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeOrTypePredicateAnnotation(types.colon) : undefined;\n  }\n\n  tsTryParseTypeAnnotation() {\n    return this.match(types.colon) ? this.tsParseTypeAnnotation() : undefined;\n  }\n\n  tsTryParseType() {\n    return this.tsEatThenParseType(types.colon);\n  }\n\n  tsParseTypePredicatePrefix() {\n    const id = this.parseIdentifier();\n\n    if (this.isContextual(\"is\") && !this.hasPrecedingLineBreak()) {\n      this.next();\n      return id;\n    }\n  }\n\n  tsParseTypePredicateAsserts() {\n    if (!this.match(types.name) || this.state.value !== \"asserts\" || this.hasPrecedingLineBreak()) {\n      return false;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.next();\n\n    if (!this.match(types.name) && !this.match(types._this)) {\n      return false;\n    }\n\n    if (containsEsc) {\n      this.raise(this.state.lastTokStart, Errors.InvalidEscapedReservedWord, \"asserts\");\n    }\n\n    return true;\n  }\n\n  tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {\n    this.tsInType(() => {\n      if (eatColon) this.expect(types.colon);\n      t.typeAnnotation = this.tsParseType();\n    });\n    return this.finishNode(t, \"TSTypeAnnotation\");\n  }\n\n  tsParseType() {\n    assert(this.state.inType);\n    const type = this.tsParseNonConditionalType();\n\n    if (this.hasPrecedingLineBreak() || !this.eat(types._extends)) {\n      return type;\n    }\n\n    const node = this.startNodeAtNode(type);\n    node.checkType = type;\n    node.extendsType = this.tsParseNonConditionalType();\n    this.expect(types.question);\n    node.trueType = this.tsParseType();\n    this.expect(types.colon);\n    node.falseType = this.tsParseType();\n    return this.finishNode(node, \"TSConditionalType\");\n  }\n\n  tsParseNonConditionalType() {\n    if (this.tsIsStartOfFunctionType()) {\n      return this.tsParseFunctionOrConstructorType(\"TSFunctionType\");\n    }\n\n    if (this.match(types._new)) {\n      return this.tsParseFunctionOrConstructorType(\"TSConstructorType\");\n    }\n\n    return this.tsParseUnionTypeOrHigher();\n  }\n\n  tsParseTypeAssertion() {\n    const node = this.startNode();\n\n    const _const = this.tsTryNextParseConstantContext();\n\n    node.typeAnnotation = _const || this.tsNextThenParseType();\n    this.expectRelational(\">\");\n    node.expression = this.parseMaybeUnary();\n    return this.finishNode(node, \"TSTypeAssertion\");\n  }\n\n  tsParseHeritageClause(descriptor) {\n    const originalStart = this.state.start;\n    const delimitedList = this.tsParseDelimitedList(\"HeritageClauseElement\", this.tsParseExpressionWithTypeArguments.bind(this));\n\n    if (!delimitedList.length) {\n      this.raise(originalStart, TSErrors.EmptyHeritageClauseType, descriptor);\n    }\n\n    return delimitedList;\n  }\n\n  tsParseExpressionWithTypeArguments() {\n    const node = this.startNode();\n    node.expression = this.tsParseEntityName(false);\n\n    if (this.isRelational(\"<\")) {\n      node.typeParameters = this.tsParseTypeArguments();\n    }\n\n    return this.finishNode(node, \"TSExpressionWithTypeArguments\");\n  }\n\n  tsParseInterfaceDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_TS_INTERFACE, undefined, \"typescript interface declaration\");\n    node.typeParameters = this.tsTryParseTypeParameters();\n\n    if (this.eat(types._extends)) {\n      node.extends = this.tsParseHeritageClause(\"extends\");\n    }\n\n    const body = this.startNode();\n    body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));\n    node.body = this.finishNode(body, \"TSInterfaceBody\");\n    return this.finishNode(node, \"TSInterfaceDeclaration\");\n  }\n\n  tsParseTypeAliasDeclaration(node) {\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_TS_TYPE, undefined, \"typescript type alias\");\n    node.typeParameters = this.tsTryParseTypeParameters();\n    node.typeAnnotation = this.tsExpectThenParseType(types.eq);\n    this.semicolon();\n    return this.finishNode(node, \"TSTypeAliasDeclaration\");\n  }\n\n  tsInNoContext(cb) {\n    const oldContext = this.state.context;\n    this.state.context = [oldContext[0]];\n\n    try {\n      return cb();\n    } finally {\n      this.state.context = oldContext;\n    }\n  }\n\n  tsInType(cb) {\n    const oldInType = this.state.inType;\n    this.state.inType = true;\n\n    try {\n      return cb();\n    } finally {\n      this.state.inType = oldInType;\n    }\n  }\n\n  tsEatThenParseType(token) {\n    return !this.match(token) ? undefined : this.tsNextThenParseType();\n  }\n\n  tsExpectThenParseType(token) {\n    return this.tsDoThenParseType(() => this.expect(token));\n  }\n\n  tsNextThenParseType() {\n    return this.tsDoThenParseType(() => this.next());\n  }\n\n  tsDoThenParseType(cb) {\n    return this.tsInType(() => {\n      cb();\n      return this.tsParseType();\n    });\n  }\n\n  tsParseEnumMember() {\n    const node = this.startNode();\n    node.id = this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);\n\n    if (this.eat(types.eq)) {\n      node.initializer = this.parseMaybeAssign();\n    }\n\n    return this.finishNode(node, \"TSEnumMember\");\n  }\n\n  tsParseEnumDeclaration(node, isConst) {\n    if (isConst) node.const = true;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, isConst ? BIND_TS_CONST_ENUM : BIND_TS_ENUM, undefined, \"typescript enum declaration\");\n    this.expect(types.braceL);\n    node.members = this.tsParseDelimitedList(\"EnumMembers\", this.tsParseEnumMember.bind(this));\n    this.expect(types.braceR);\n    return this.finishNode(node, \"TSEnumDeclaration\");\n  }\n\n  tsParseModuleBlock() {\n    const node = this.startNode();\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.braceL);\n    this.parseBlockOrModuleBlockBody(node.body = [], undefined, true, types.braceR);\n    this.scope.exit();\n    return this.finishNode(node, \"TSModuleBlock\");\n  }\n\n  tsParseModuleOrNamespaceDeclaration(node, nested = false) {\n    node.id = this.parseIdentifier();\n\n    if (!nested) {\n      this.checkLVal(node.id, BIND_TS_NAMESPACE, null, \"module or namespace declaration\");\n    }\n\n    if (this.eat(types.dot)) {\n      const inner = this.startNode();\n      this.tsParseModuleOrNamespaceDeclaration(inner, true);\n      node.body = inner;\n    } else {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseAmbientExternalModuleDeclaration(node) {\n    if (this.isContextual(\"global\")) {\n      node.global = true;\n      node.id = this.parseIdentifier();\n    } else if (this.match(types.string)) {\n      node.id = this.parseExprAtom();\n    } else {\n      this.unexpected();\n    }\n\n    if (this.match(types.braceL)) {\n      this.scope.enter(SCOPE_TS_MODULE);\n      this.prodParam.enter(PARAM);\n      node.body = this.tsParseModuleBlock();\n      this.prodParam.exit();\n      this.scope.exit();\n    } else {\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"TSModuleDeclaration\");\n  }\n\n  tsParseImportEqualsDeclaration(node, isExport) {\n    node.isExport = isExport || false;\n    node.id = this.parseIdentifier();\n    this.checkLVal(node.id, BIND_LEXICAL, undefined, \"import equals declaration\");\n    this.expect(types.eq);\n    node.moduleReference = this.tsParseModuleReference();\n    this.semicolon();\n    return this.finishNode(node, \"TSImportEqualsDeclaration\");\n  }\n\n  tsIsExternalModuleReference() {\n    return this.isContextual(\"require\") && this.lookaheadCharCode() === 40;\n  }\n\n  tsParseModuleReference() {\n    return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);\n  }\n\n  tsParseExternalModuleReference() {\n    const node = this.startNode();\n    this.expectContextual(\"require\");\n    this.expect(types.parenL);\n\n    if (!this.match(types.string)) {\n      throw this.unexpected();\n    }\n\n    node.expression = this.parseExprAtom();\n    this.expect(types.parenR);\n    return this.finishNode(node, \"TSExternalModuleReference\");\n  }\n\n  tsLookAhead(f) {\n    const state = this.state.clone();\n    const res = f();\n    this.state = state;\n    return res;\n  }\n\n  tsTryParseAndCatch(f) {\n    const result = this.tryParse(abort => f() || abort());\n    if (result.aborted || !result.node) return undefined;\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  tsTryParse(f) {\n    const state = this.state.clone();\n    const result = f();\n\n    if (result !== undefined && result !== false) {\n      return result;\n    } else {\n      this.state = state;\n      return undefined;\n    }\n  }\n\n  tsTryParseDeclare(nany) {\n    if (this.isLineTerminator()) {\n      return;\n    }\n\n    let starttype = this.state.type;\n    let kind;\n\n    if (this.isContextual(\"let\")) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._function:\n        return this.parseFunctionStatement(nany, false, true);\n\n      case types._class:\n        nany.declare = true;\n        return this.parseClass(nany, true, false);\n\n      case types._const:\n        if (this.match(types._const) && this.isLookaheadContextual(\"enum\")) {\n          this.expect(types._const);\n          this.expectContextual(\"enum\");\n          return this.tsParseEnumDeclaration(nany, true);\n        }\n\n      case types._var:\n        kind = kind || this.state.value;\n        return this.parseVarStatement(nany, kind);\n\n      case types.name:\n        {\n          const value = this.state.value;\n\n          if (value === \"global\") {\n            return this.tsParseAmbientExternalModuleDeclaration(nany);\n          } else {\n            return this.tsParseDeclaration(nany, value, true);\n          }\n        }\n    }\n  }\n\n  tsTryParseExportDeclaration() {\n    return this.tsParseDeclaration(this.startNode(), this.state.value, true);\n  }\n\n  tsParseExpressionStatement(node, expr) {\n    switch (expr.name) {\n      case \"declare\":\n        {\n          const declaration = this.tsTryParseDeclare(node);\n\n          if (declaration) {\n            declaration.declare = true;\n            return declaration;\n          }\n\n          break;\n        }\n\n      case \"global\":\n        if (this.match(types.braceL)) {\n          this.scope.enter(SCOPE_TS_MODULE);\n          this.prodParam.enter(PARAM);\n          const mod = node;\n          mod.global = true;\n          mod.id = expr;\n          mod.body = this.tsParseModuleBlock();\n          this.scope.exit();\n          this.prodParam.exit();\n          return this.finishNode(mod, \"TSModuleDeclaration\");\n        }\n\n        break;\n\n      default:\n        return this.tsParseDeclaration(node, expr.name, false);\n    }\n  }\n\n  tsParseDeclaration(node, value, next) {\n    switch (value) {\n      case \"abstract\":\n        if (this.tsCheckLineTerminatorAndMatch(types._class, next)) {\n          const cls = node;\n          cls.abstract = true;\n\n          if (next) {\n            this.next();\n\n            if (!this.match(types._class)) {\n              this.unexpected(null, types._class);\n            }\n          }\n\n          return this.parseClass(cls, true, false);\n        }\n\n        break;\n\n      case \"enum\":\n        if (next || this.match(types.name)) {\n          if (next) this.next();\n          return this.tsParseEnumDeclaration(node, false);\n        }\n\n        break;\n\n      case \"interface\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseInterfaceDeclaration(node);\n        }\n\n        break;\n\n      case \"module\":\n        if (next) this.next();\n\n        if (this.match(types.string)) {\n          return this.tsParseAmbientExternalModuleDeclaration(node);\n        } else if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"namespace\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseModuleOrNamespaceDeclaration(node);\n        }\n\n        break;\n\n      case \"type\":\n        if (this.tsCheckLineTerminatorAndMatch(types.name, next)) {\n          if (next) this.next();\n          return this.tsParseTypeAliasDeclaration(node);\n        }\n\n        break;\n    }\n  }\n\n  tsCheckLineTerminatorAndMatch(tokenType, next) {\n    return (next || this.match(tokenType)) && !this.isLineTerminator();\n  }\n\n  tsTryParseGenericAsyncArrowFunction(startPos, startLoc) {\n    if (!this.isRelational(\"<\")) {\n      return undefined;\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.maybeInArrowParameters = true;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    const res = this.tsTryParseAndCatch(() => {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.typeParameters = this.tsParseTypeParameters();\n      super.parseFunctionParams(node);\n      node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();\n      this.expect(types.arrow);\n      return node;\n    });\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n\n    if (!res) {\n      return undefined;\n    }\n\n    return this.parseArrowExpression(res, null, true);\n  }\n\n  tsParseTypeArguments() {\n    const node = this.startNode();\n    node.params = this.tsInType(() => this.tsInNoContext(() => {\n      this.expectRelational(\"<\");\n      return this.tsParseDelimitedList(\"TypeParametersOrArguments\", this.tsParseType.bind(this));\n    }));\n    this.state.exprAllowed = false;\n    this.expectRelational(\">\");\n    return this.finishNode(node, \"TSTypeParameterInstantiation\");\n  }\n\n  tsIsDeclarationStart() {\n    if (this.match(types.name)) {\n      switch (this.state.value) {\n        case \"abstract\":\n        case \"declare\":\n        case \"enum\":\n        case \"interface\":\n        case \"module\":\n        case \"namespace\":\n        case \"type\":\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.tsIsDeclarationStart()) return false;\n    return super.isExportDefaultSpecifier();\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let accessibility;\n    let readonly = false;\n\n    if (allowModifiers) {\n      accessibility = this.parseAccessModifier();\n      readonly = !!this.tsParseModifier([\"readonly\"]);\n    }\n\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (accessibility || readonly) {\n      const pp = this.startNodeAt(startPos, startLoc);\n\n      if (decorators.length) {\n        pp.decorators = decorators;\n      }\n\n      if (accessibility) pp.accessibility = accessibility;\n      if (readonly) pp.readonly = readonly;\n\n      if (elt.type !== \"Identifier\" && elt.type !== \"AssignmentPattern\") {\n        this.raise(pp.start, TSErrors.UnsupportedParameterPropertyKind);\n      }\n\n      pp.parameter = elt;\n      return this.finishNode(pp, \"TSParameterProperty\");\n    }\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n    }\n\n    const bodilessType = type === \"FunctionDeclaration\" ? \"TSDeclareFunction\" : type === \"ClassMethod\" ? \"TSDeclareMethod\" : undefined;\n\n    if (bodilessType && !this.match(types.braceL) && this.isLineTerminator()) {\n      this.finishNode(node, bodilessType);\n      return;\n    }\n\n    super.parseFunctionBodyAndFinish(node, type, isMethod);\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.body && node.id) {\n      this.checkLVal(node.id, BIND_TS_AMBIENT, null, \"function name\");\n    } else {\n      super.registerFunctionStatementId(...arguments);\n    }\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!this.hasPrecedingLineBreak() && this.match(types.bang)) {\n      this.state.exprAllowed = false;\n      this.next();\n      const nonNullExpression = this.startNodeAt(startPos, startLoc);\n      nonNullExpression.expression = base;\n      return this.finishNode(nonNullExpression, \"TSNonNullExpression\");\n    }\n\n    if (this.isRelational(\"<\")) {\n      const result = this.tsTryParseAndCatch(() => {\n        if (!noCalls && this.atPossibleAsyncArrow(base)) {\n          const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startPos, startLoc);\n\n          if (asyncArrowFn) {\n            return asyncArrowFn;\n          }\n        }\n\n        const node = this.startNodeAt(startPos, startLoc);\n        node.callee = base;\n        const typeArguments = this.tsParseTypeArguments();\n\n        if (typeArguments) {\n          if (!noCalls && this.eat(types.parenL)) {\n            node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n            node.typeParameters = typeArguments;\n            return this.finishCallExpression(node, state.optionalChainMember);\n          } else if (this.match(types.backQuote)) {\n            return this.parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments);\n          }\n        }\n\n        this.unexpected();\n      });\n      if (result) return result;\n    }\n\n    return super.parseSubscript(base, startPos, startLoc, noCalls, state);\n  }\n\n  parseNewArguments(node) {\n    if (this.isRelational(\"<\")) {\n      const typeParameters = this.tsTryParseAndCatch(() => {\n        const args = this.tsParseTypeArguments();\n        if (!this.match(types.parenL)) this.unexpected();\n        return args;\n      });\n\n      if (typeParameters) {\n        node.typeParameters = typeParameters;\n      }\n    }\n\n    super.parseNewArguments(node);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    if (nonNull(types._in.binop) > minPrec && !this.hasPrecedingLineBreak() && this.isContextual(\"as\")) {\n      const node = this.startNodeAt(leftStartPos, leftStartLoc);\n      node.expression = left;\n\n      const _const = this.tsTryNextParseConstantContext();\n\n      if (_const) {\n        node.typeAnnotation = _const;\n      } else {\n        node.typeAnnotation = this.tsNextThenParseType();\n      }\n\n      this.finishNode(node, \"TSAsExpression\");\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n\n    return super.parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn);\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {}\n\n  checkDuplicateExports() {}\n\n  parseImport(node) {\n    if (this.match(types.name) || this.match(types.star) || this.match(types.braceL)) {\n      const ahead = this.lookahead();\n\n      if (this.match(types.name) && ahead.type === types.eq) {\n        return this.tsParseImportEqualsDeclaration(node);\n      }\n\n      if (this.isContextual(\"type\") && ahead.type !== types.comma && !(ahead.type === types.name && ahead.value === \"from\")) {\n        node.importKind = \"type\";\n        this.next();\n      } else {\n        node.importKind = \"value\";\n      }\n    }\n\n    const importNode = super.parseImport(node);\n\n    if (importNode.importKind === \"type\" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === \"ImportDefaultSpecifier\") {\n      this.raise(importNode.start, \"A type-only import can specify a default import or named bindings, but not both.\");\n    }\n\n    return importNode;\n  }\n\n  parseExport(node) {\n    if (this.match(types._import)) {\n      this.expect(types._import);\n      return this.tsParseImportEqualsDeclaration(node, true);\n    } else if (this.eat(types.eq)) {\n      const assign = node;\n      assign.expression = this.parseExpression();\n      this.semicolon();\n      return this.finishNode(assign, \"TSExportAssignment\");\n    } else if (this.eatContextual(\"as\")) {\n      const decl = node;\n      this.expectContextual(\"namespace\");\n      decl.id = this.parseIdentifier();\n      this.semicolon();\n      return this.finishNode(decl, \"TSNamespaceExportDeclaration\");\n    } else {\n      if (this.isContextual(\"type\") && this.lookahead().type === types.braceL) {\n        this.next();\n        node.exportKind = \"type\";\n      } else {\n        node.exportKind = \"value\";\n      }\n\n      return super.parseExport(node);\n    }\n  }\n\n  isAbstractClass() {\n    return this.isContextual(\"abstract\") && this.lookahead().type === types._class;\n  }\n\n  parseExportDefaultExpression() {\n    if (this.isAbstractClass()) {\n      const cls = this.startNode();\n      this.next();\n      this.parseClass(cls, true, true);\n      cls.abstract = true;\n      return cls;\n    }\n\n    if (this.state.value === \"interface\") {\n      const result = this.tsParseDeclaration(this.startNode(), this.state.value, true);\n      if (result) return result;\n    }\n\n    return super.parseExportDefaultExpression();\n  }\n\n  parseStatementContent(context, topLevel) {\n    if (this.state.type === types._const) {\n      const ahead = this.lookahead();\n\n      if (ahead.type === types.name && ahead.value === \"enum\") {\n        const node = this.startNode();\n        this.expect(types._const);\n        this.expectContextual(\"enum\");\n        return this.tsParseEnumDeclaration(node, true);\n      }\n    }\n\n    return super.parseStatementContent(context, topLevel);\n  }\n\n  parseAccessModifier() {\n    return this.tsParseModifier([\"public\", \"protected\", \"private\"]);\n  }\n\n  parseClassMember(classBody, member, state, constructorAllowsSuper) {\n    this.tsParseModifiers(member, [\"declare\"]);\n    const accessibility = this.parseAccessModifier();\n    if (accessibility) member.accessibility = accessibility;\n    this.tsParseModifiers(member, [\"declare\"]);\n    super.parseClassMember(classBody, member, state, constructorAllowsSuper);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {\n    this.tsParseModifiers(member, [\"abstract\", \"readonly\", \"declare\"]);\n    const idx = this.tsTryParseIndexSignature(member);\n\n    if (idx) {\n      classBody.body.push(idx);\n\n      if (member.abstract) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAbstract);\n      }\n\n      if (isStatic) {\n        this.raise(member.start, TSErrors.IndexSignatureHasStatic);\n      }\n\n      if (member.accessibility) {\n        this.raise(member.start, TSErrors.IndexSignatureHasAccessibility, member.accessibility);\n      }\n\n      return;\n    }\n\n    super.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {\n    const optional = this.eat(types.question);\n    if (optional) methodOrProp.optional = true;\n\n    if (methodOrProp.readonly && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasReadonly);\n    }\n\n    if (methodOrProp.declare && this.match(types.parenL)) {\n      this.raise(methodOrProp.start, TSErrors.ClassMethodHasDeclare);\n    }\n  }\n\n  parseExpressionStatement(node, expr) {\n    const decl = expr.type === \"Identifier\" ? this.tsParseExpressionStatement(node, expr) : undefined;\n    return decl || super.parseExpressionStatement(node, expr);\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.tsIsDeclarationStart()) return true;\n    return super.shouldParseExportDeclaration();\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (!refNeedsArrowPos || !this.match(types.question)) {\n      return super.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n    }\n\n    const result = this.tryParse(() => super.parseConditional(expr, noIn, startPos, startLoc));\n\n    if (!result.node) {\n      refNeedsArrowPos.start = result.error.pos || this.state.start;\n      return expr;\n    }\n\n    if (result.error) this.state = result.failState;\n    return result.node;\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    node = super.parseParenItem(node, startPos, startLoc);\n\n    if (this.eat(types.question)) {\n      node.optional = true;\n      this.resetEndLocation(node);\n    }\n\n    if (this.match(types.colon)) {\n      const typeCastNode = this.startNodeAt(startPos, startLoc);\n      typeCastNode.expression = node;\n      typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();\n      return this.finishNode(typeCastNode, \"TSTypeCastExpression\");\n    }\n\n    return node;\n  }\n\n  parseExportDeclaration(node) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const isDeclare = this.eatContextual(\"declare\");\n    let declaration;\n\n    if (this.match(types.name)) {\n      declaration = this.tsTryParseExportDeclaration();\n    }\n\n    if (!declaration) {\n      declaration = super.parseExportDeclaration(node);\n    }\n\n    if (declaration && (declaration.type === \"TSInterfaceDeclaration\" || declaration.type === \"TSTypeAliasDeclaration\" || isDeclare)) {\n      node.exportKind = \"type\";\n    }\n\n    if (declaration && isDeclare) {\n      this.resetStartLocation(declaration, startPos, startLoc);\n      declaration.declare = true;\n    }\n\n    return declaration;\n  }\n\n  parseClassId(node, isStatement, optionalId) {\n    if ((!isStatement || optionalId) && this.isContextual(\"implements\")) {\n      return;\n    }\n\n    super.parseClassId(node, isStatement, optionalId, node.declare ? BIND_TS_AMBIENT : BIND_CLASS);\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n  }\n\n  parseClassPropertyAnnotation(node) {\n    if (!node.optional && this.eat(types.bang)) {\n      node.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) node.typeAnnotation = type;\n  }\n\n  parseClassProperty(node) {\n    this.parseClassPropertyAnnotation(node);\n\n    if (node.declare && this.match(types.equal)) {\n      this.raise(this.state.start, TSErrors.DeclareClassFieldHasInitializer);\n    }\n\n    return super.parseClassProperty(node);\n  }\n\n  parseClassPrivateProperty(node) {\n    if (node.abstract) {\n      this.raise(node.start, TSErrors.PrivateElementHasAbstract);\n    }\n\n    if (node.accessibility) {\n      this.raise(node.start, TSErrors.PrivateElementHasAccessibility, node.accessibility);\n    }\n\n    this.parseClassPropertyAnnotation(node);\n    return super.parseClassPrivateProperty(node);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) method.typeParameters = typeParameters;\n    super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);\n  }\n\n  parseClassSuper(node) {\n    super.parseClassSuper(node);\n\n    if (node.superClass && this.isRelational(\"<\")) {\n      node.superTypeParameters = this.tsParseTypeArguments();\n    }\n\n    if (this.eatContextual(\"implements\")) {\n      node.implements = this.tsParseHeritageClause(\"implements\");\n    }\n  }\n\n  parseObjPropValue(prop, ...args) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) prop.typeParameters = typeParameters;\n    super.parseObjPropValue(prop, ...args);\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const typeParameters = this.tsTryParseTypeParameters();\n    if (typeParameters) node.typeParameters = typeParameters;\n    super.parseFunctionParams(node, allowModifiers);\n  }\n\n  parseVarId(decl, kind) {\n    super.parseVarId(decl, kind);\n\n    if (decl.id.type === \"Identifier\" && this.eat(types.bang)) {\n      decl.definite = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n\n    if (type) {\n      decl.id.typeAnnotation = type;\n      this.resetEndLocation(decl.id);\n    }\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    if (this.match(types.colon)) {\n      node.returnType = this.tsParseTypeAnnotation();\n    }\n\n    return super.parseAsyncArrowFromCallExpression(node, call);\n  }\n\n  parseMaybeAssign(...args) {\n    let state;\n    let jsx;\n    let typeCast;\n\n    if (this.match(types.jsxTagStart)) {\n      state = this.state.clone();\n      jsx = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!jsx.error) return jsx.node;\n      const {\n        context\n      } = this.state;\n\n      if (context[context.length - 1] === types$1.j_oTag) {\n        context.length -= 2;\n      } else if (context[context.length - 1] === types$1.j_expr) {\n        context.length -= 1;\n      }\n    }\n\n    if (!(jsx && jsx.error) && !this.isRelational(\"<\")) {\n      return super.parseMaybeAssign(...args);\n    }\n\n    let typeParameters;\n    state = state || this.state.clone();\n    const arrow = this.tryParse(abort => {\n      typeParameters = this.tsParseTypeParameters();\n      const expr = super.parseMaybeAssign(...args);\n\n      if (expr.type !== \"ArrowFunctionExpression\" || expr.extra && expr.extra.parenthesized) {\n        abort();\n      }\n\n      if (typeParameters && typeParameters.params.length !== 0) {\n        this.resetStartLocationFromNode(expr, typeParameters);\n      }\n\n      expr.typeParameters = typeParameters;\n      return expr;\n    }, state);\n    if (!arrow.error && !arrow.aborted) return arrow.node;\n\n    if (!jsx) {\n      assert(!this.hasPlugin(\"jsx\"));\n      typeCast = this.tryParse(() => super.parseMaybeAssign(...args), state);\n      if (!typeCast.error) return typeCast.node;\n    }\n\n    if (jsx && jsx.node) {\n      this.state = jsx.failState;\n      return jsx.node;\n    }\n\n    if (arrow.node) {\n      this.state = arrow.failState;\n      return arrow.node;\n    }\n\n    if (typeCast && typeCast.node) {\n      this.state = typeCast.failState;\n      return typeCast.node;\n    }\n\n    if (jsx && jsx.thrown) throw jsx.error;\n    if (arrow.thrown) throw arrow.error;\n    if (typeCast && typeCast.thrown) throw typeCast.error;\n    throw jsx && jsx.error || arrow.error || typeCast && typeCast.error;\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (!this.hasPlugin(\"jsx\") && this.isRelational(\"<\")) {\n      return this.tsParseTypeAssertion();\n    } else {\n      return super.parseMaybeUnary(refExpressionErrors);\n    }\n  }\n\n  parseArrow(node) {\n    if (this.match(types.colon)) {\n      const result = this.tryParse(abort => {\n        const returnType = this.tsParseTypeOrTypePredicateAnnotation(types.colon);\n        if (this.canInsertSemicolon() || !this.match(types.arrow)) abort();\n        return returnType;\n      });\n      if (result.aborted) return;\n\n      if (!result.thrown) {\n        if (result.error) this.state = result.failState;\n        node.returnType = result.node;\n      }\n    }\n\n    return super.parseArrow(node);\n  }\n\n  parseAssignableListItemTypes(param) {\n    if (this.eat(types.question)) {\n      if (param.type !== \"Identifier\") {\n        this.raise(param.start, TSErrors.PatternIsOptional);\n      }\n\n      param.optional = true;\n    }\n\n    const type = this.tsTryParseTypeAnnotation();\n    if (type) param.typeAnnotation = type;\n    this.resetEndLocation(param);\n    return param;\n  }\n\n  toAssignable(node) {\n    switch (node.type) {\n      case \"TSTypeCastExpression\":\n        return super.toAssignable(this.typeCastToParameter(node));\n\n      case \"TSParameterProperty\":\n        return super.toAssignable(node);\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        node.expression = this.toAssignable(node.expression);\n        return node;\n\n      default:\n        return super.toAssignable(node);\n    }\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription) {\n    switch (expr.type) {\n      case \"TSTypeCastExpression\":\n        return;\n\n      case \"TSParameterProperty\":\n        this.checkLVal(expr.parameter, bindingType, checkClashes, \"parameter property\");\n        return;\n\n      case \"TSAsExpression\":\n      case \"TSNonNullExpression\":\n      case \"TSTypeAssertion\":\n        this.checkLVal(expr.expression, bindingType, checkClashes, contextDescription);\n        return;\n\n      default:\n        super.checkLVal(expr, bindingType, checkClashes, contextDescription);\n        return;\n    }\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types._this:\n        return this.parseIdentifier(true);\n\n      default:\n        return super.parseBindingAtom();\n    }\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsParseTypeArguments();\n\n      if (this.match(types.parenL)) {\n        const call = super.parseMaybeDecoratorArguments(expr);\n        call.typeParameters = typeArguments;\n        return call;\n      }\n\n      this.unexpected(this.state.start, types.parenL);\n    }\n\n    return super.parseMaybeDecoratorArguments(expr);\n  }\n\n  isClassMethod() {\n    return this.isRelational(\"<\") || super.isClassMethod();\n  }\n\n  isClassProperty() {\n    return this.match(types.bang) || this.match(types.colon) || super.isClassProperty();\n  }\n\n  parseMaybeDefault(...args) {\n    const node = super.parseMaybeDefault(...args);\n\n    if (node.type === \"AssignmentPattern\" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {\n      this.raise(node.typeAnnotation.start, TSErrors.TypeAnnotationAfterAssign);\n    }\n\n    return node;\n  }\n\n  getTokenFromCode(code) {\n    if (this.state.inType && (code === 62 || code === 60)) {\n      return this.finishOp(types.relational, 1);\n    } else {\n      return super.getTokenFromCode(code);\n    }\n  }\n\n  toAssignableList(exprList) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n      if (!expr) continue;\n\n      switch (expr.type) {\n        case \"TSTypeCastExpression\":\n          exprList[i] = this.typeCastToParameter(expr);\n          break;\n\n        case \"TSAsExpression\":\n        case \"TSTypeAssertion\":\n          if (!this.state.maybeInArrowParameters) {\n            exprList[i] = this.typeCastToParameter(expr);\n          } else {\n            this.raise(expr.start, TSErrors.UnexpectedTypeCastInParameter);\n          }\n\n          break;\n      }\n    }\n\n    return super.toAssignableList(...arguments);\n  }\n\n  typeCastToParameter(node) {\n    node.expression.typeAnnotation = node.typeAnnotation;\n    this.resetEndLocation(node.expression, node.typeAnnotation.end, node.typeAnnotation.loc.end);\n    return node.expression;\n  }\n\n  toReferencedList(exprList, isInParens) {\n    for (let i = 0; i < exprList.length; i++) {\n      const expr = exprList[i];\n\n      if (expr && expr.type === \"TSTypeCastExpression\") {\n        this.raise(expr.start, TSErrors.UnexpectedTypeAnnotation);\n      }\n    }\n\n    return exprList;\n  }\n\n  shouldParseArrow() {\n    return this.match(types.colon) || super.shouldParseArrow();\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.colon) || super.shouldParseAsyncArrow();\n  }\n\n  canHaveLeadingDecorator() {\n    return super.canHaveLeadingDecorator() || this.isAbstractClass();\n  }\n\n  jsxParseOpeningElementAfterName(node) {\n    if (this.isRelational(\"<\")) {\n      const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArguments());\n      if (typeArguments) node.typeParameters = typeArguments;\n    }\n\n    return super.jsxParseOpeningElementAfterName(node);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    const baseCount = super.getGetterSetterExpectedParamCount(method);\n    const firstParam = method.params[0];\n    const hasContextParam = firstParam && firstParam.type === \"Identifier\" && firstParam.name === \"this\";\n    return hasContextParam ? baseCount + 1 : baseCount;\n  }\n\n});\n\ntypes.placeholder = new TokenType(\"%%\", {\n  startsExpr: true\n});\nvar placeholders = (superClass => class extends superClass {\n  parsePlaceholder(expectedNode) {\n    if (this.match(types.placeholder)) {\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      node.name = super.parseIdentifier(true);\n      this.assertNoSpace(\"Unexpected space in placeholder.\");\n      this.expect(types.placeholder);\n      return this.finishPlaceholder(node, expectedNode);\n    }\n  }\n\n  finishPlaceholder(node, expectedNode) {\n    const isFinished = !!(node.expectedNode && node.type === \"Placeholder\");\n    node.expectedNode = expectedNode;\n    return isFinished ? node : this.finishNode(node, \"Placeholder\");\n  }\n\n  getTokenFromCode(code) {\n    if (code === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {\n      return this.finishOp(types.placeholder, 2);\n    }\n\n    return super.getTokenFromCode(...arguments);\n  }\n\n  parseExprAtom() {\n    return this.parsePlaceholder(\"Expression\") || super.parseExprAtom(...arguments);\n  }\n\n  parseIdentifier() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseIdentifier(...arguments);\n  }\n\n  checkReservedWord(word) {\n    if (word !== undefined) super.checkReservedWord(...arguments);\n  }\n\n  parseBindingAtom() {\n    return this.parsePlaceholder(\"Pattern\") || super.parseBindingAtom(...arguments);\n  }\n\n  checkLVal(expr) {\n    if (expr.type !== \"Placeholder\") super.checkLVal(...arguments);\n  }\n\n  toAssignable(node) {\n    if (node && node.type === \"Placeholder\" && node.expectedNode === \"Expression\") {\n      node.expectedNode = \"Pattern\";\n      return node;\n    }\n\n    return super.toAssignable(...arguments);\n  }\n\n  verifyBreakContinue(node) {\n    if (node.label && node.label.type === \"Placeholder\") return;\n    super.verifyBreakContinue(...arguments);\n  }\n\n  parseExpressionStatement(node, expr) {\n    if (expr.type !== \"Placeholder\" || expr.extra && expr.extra.parenthesized) {\n      return super.parseExpressionStatement(...arguments);\n    }\n\n    if (this.match(types.colon)) {\n      const stmt = node;\n      stmt.label = this.finishPlaceholder(expr, \"Identifier\");\n      this.next();\n      stmt.body = this.parseStatement(\"label\");\n      return this.finishNode(stmt, \"LabeledStatement\");\n    }\n\n    this.semicolon();\n    node.name = expr.name;\n    return this.finishPlaceholder(node, \"Statement\");\n  }\n\n  parseBlock() {\n    return this.parsePlaceholder(\"BlockStatement\") || super.parseBlock(...arguments);\n  }\n\n  parseFunctionId() {\n    return this.parsePlaceholder(\"Identifier\") || super.parseFunctionId(...arguments);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    const type = isStatement ? \"ClassDeclaration\" : \"ClassExpression\";\n    this.next();\n    this.takeDecorators(node);\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n\n    if (placeholder) {\n      if (this.match(types._extends) || this.match(types.placeholder) || this.match(types.braceL)) {\n        node.id = placeholder;\n      } else if (optionalId || !isStatement) {\n        node.id = null;\n        node.body = this.finishPlaceholder(placeholder, \"ClassBody\");\n        return this.finishNode(node, type);\n      } else {\n        this.unexpected(null, \"A class name is required\");\n      }\n    } else {\n      this.parseClassId(node, isStatement, optionalId);\n    }\n\n    this.parseClassSuper(node);\n    node.body = this.parsePlaceholder(\"ClassBody\") || this.parseClassBody(!!node.superClass);\n    return this.finishNode(node, type);\n  }\n\n  parseExport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseExport(...arguments);\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.finishPlaceholder(placeholder, \"Declaration\");\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    this.expectPlugin(\"exportDefaultFrom\");\n    const specifier = this.startNode();\n    specifier.exported = placeholder;\n    node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n    return super.parseExport(node);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (node.specifiers && node.specifiers.length > 0) {\n      return true;\n    }\n\n    return super.maybeParseExportDefaultSpecifier(...arguments);\n  }\n\n  checkExport(node) {\n    const {\n      specifiers\n    } = node;\n\n    if (specifiers && specifiers.length) {\n      node.specifiers = specifiers.filter(node => node.exported.type === \"Placeholder\");\n    }\n\n    super.checkExport(node);\n    node.specifiers = specifiers;\n  }\n\n  parseImport(node) {\n    const placeholder = this.parsePlaceholder(\"Identifier\");\n    if (!placeholder) return super.parseImport(...arguments);\n    node.specifiers = [];\n\n    if (!this.isContextual(\"from\") && !this.match(types.comma)) {\n      node.source = this.finishPlaceholder(placeholder, \"StringLiteral\");\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n\n    const specifier = this.startNodeAtNode(placeholder);\n    specifier.local = placeholder;\n    this.finishNode(specifier, \"ImportDefaultSpecifier\");\n    node.specifiers.push(specifier);\n\n    if (this.eat(types.comma)) {\n      const hasStarImport = this.maybeParseStarImportSpecifier(node);\n      if (!hasStarImport) this.parseNamedImportSpecifiers(node);\n    }\n\n    this.expectContextual(\"from\");\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    return this.parsePlaceholder(\"StringLiteral\") || super.parseImportSource(...arguments);\n  }\n\n});\n\nvar v8intrinsic = (superClass => class extends superClass {\n  parseV8Intrinsic() {\n    if (this.match(types.modulo)) {\n      const v8IntrinsicStart = this.state.start;\n      const node = this.startNode();\n      this.eat(types.modulo);\n\n      if (this.match(types.name)) {\n        const name = this.parseIdentifierName(this.state.start);\n        const identifier = this.createIdentifier(node, name);\n        identifier.type = \"V8IntrinsicIdentifier\";\n\n        if (this.match(types.parenL)) {\n          return identifier;\n        }\n      }\n\n      this.unexpected(v8IntrinsicStart);\n    }\n  }\n\n  parseExprAtom() {\n    return this.parseV8Intrinsic() || super.parseExprAtom(...arguments);\n  }\n\n});\n\nfunction hasPlugin(plugins, name) {\n  return plugins.some(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n}\nfunction getPluginOption(plugins, name, option) {\n  const plugin = plugins.find(plugin => {\n    if (Array.isArray(plugin)) {\n      return plugin[0] === name;\n    } else {\n      return plugin === name;\n    }\n  });\n\n  if (plugin && Array.isArray(plugin)) {\n    return plugin[1][option];\n  }\n\n  return null;\n}\nconst PIPELINE_PROPOSALS = [\"minimal\", \"smart\", \"fsharp\"];\nconst RECORD_AND_TUPLE_SYNTAX_TYPES = [\"hash\", \"bar\"];\nfunction validatePlugins(plugins) {\n  if (hasPlugin(plugins, \"decorators\")) {\n    if (hasPlugin(plugins, \"decorators-legacy\")) {\n      throw new Error(\"Cannot use the decorators and decorators-legacy plugin together\");\n    }\n\n    const decoratorsBeforeExport = getPluginOption(plugins, \"decorators\", \"decoratorsBeforeExport\");\n\n    if (decoratorsBeforeExport == null) {\n      throw new Error(\"The 'decorators' plugin requires a 'decoratorsBeforeExport' option,\" + \" whose value must be a boolean. If you are migrating from\" + \" Babylon/Babel 6 or want to use the old decorators proposal, you\" + \" should use the 'decorators-legacy' plugin instead of 'decorators'.\");\n    } else if (typeof decoratorsBeforeExport !== \"boolean\") {\n      throw new Error(\"'decoratorsBeforeExport' must be a boolean.\");\n    }\n  }\n\n  if (hasPlugin(plugins, \"flow\") && hasPlugin(plugins, \"typescript\")) {\n    throw new Error(\"Cannot combine flow and typescript plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"placeholders\") && hasPlugin(plugins, \"v8intrinsic\")) {\n    throw new Error(\"Cannot combine placeholders and v8intrinsic plugins.\");\n  }\n\n  if (hasPlugin(plugins, \"pipelineOperator\") && !PIPELINE_PROPOSALS.includes(getPluginOption(plugins, \"pipelineOperator\", \"proposal\"))) {\n    throw new Error(\"'pipelineOperator' requires 'proposal' option whose value should be one of: \" + PIPELINE_PROPOSALS.map(p => `'${p}'`).join(\", \"));\n  }\n\n  if (hasPlugin(plugins, \"recordAndTuple\") && !RECORD_AND_TUPLE_SYNTAX_TYPES.includes(getPluginOption(plugins, \"recordAndTuple\", \"syntaxType\"))) {\n    throw new Error(\"'recordAndTuple' requires 'syntaxType' option whose value should be one of: \" + RECORD_AND_TUPLE_SYNTAX_TYPES.map(p => `'${p}'`).join(\", \"));\n  }\n}\nconst mixinPlugins = {\n  estree,\n  jsx,\n  flow,\n  typescript,\n  v8intrinsic,\n  placeholders\n};\nconst mixinPluginNames = Object.keys(mixinPlugins);\n\nconst defaultOptions = {\n  sourceType: \"script\",\n  sourceFilename: undefined,\n  startLine: 1,\n  allowAwaitOutsideFunction: false,\n  allowReturnOutsideFunction: false,\n  allowImportExportEverywhere: false,\n  allowSuperOutsideMethod: false,\n  allowUndeclaredExports: false,\n  plugins: [],\n  strictMode: null,\n  ranges: false,\n  tokens: false,\n  createParenthesizedExpressions: false,\n  errorRecovery: false\n};\nfunction getOptions(opts) {\n  const options = {};\n\n  for (let _i = 0, _Object$keys = Object.keys(defaultOptions); _i < _Object$keys.length; _i++) {\n    const key = _Object$keys[_i];\n    options[key] = opts && opts[key] != null ? opts[key] : defaultOptions[key];\n  }\n\n  return options;\n}\n\nclass State {\n  constructor() {\n    this.errors = [];\n    this.potentialArrowAt = -1;\n    this.noArrowAt = [];\n    this.noArrowParamsConversionAt = [];\n    this.inParameters = false;\n    this.maybeInArrowParameters = false;\n    this.maybeInAsyncArrowHead = false;\n    this.inPipeline = false;\n    this.inType = false;\n    this.noAnonFunctionType = false;\n    this.inPropertyName = false;\n    this.hasFlowComment = false;\n    this.isIterator = false;\n    this.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n    this.soloAwait = false;\n    this.inFSharpPipelineDirectBody = false;\n    this.labels = [];\n    this.decoratorStack = [[]];\n    this.yieldPos = -1;\n    this.awaitPos = -1;\n    this.comments = [];\n    this.trailingComments = [];\n    this.leadingComments = [];\n    this.commentStack = [];\n    this.commentPreviousNode = null;\n    this.pos = 0;\n    this.lineStart = 0;\n    this.type = types.eof;\n    this.value = null;\n    this.start = 0;\n    this.end = 0;\n    this.lastTokEndLoc = null;\n    this.lastTokStartLoc = null;\n    this.lastTokStart = 0;\n    this.lastTokEnd = 0;\n    this.context = [types$1.braceStatement];\n    this.exprAllowed = true;\n    this.containsEsc = false;\n    this.octalPositions = [];\n    this.exportedIdentifiers = [];\n    this.tokensLength = 0;\n  }\n\n  init(options) {\n    this.strict = options.strictMode === false ? false : options.sourceType === \"module\";\n    this.curLine = options.startLine;\n    this.startLoc = this.endLoc = this.curPosition();\n  }\n\n  curPosition() {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n\n  clone(skipArrays) {\n    const state = new State();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      let val = this[key];\n\n      if (!skipArrays && Array.isArray(val)) {\n        val = val.slice();\n      }\n\n      state[key] = val;\n    }\n\n    return state;\n  }\n\n}\n\nvar _isDigit = function isDigit(code) {\n  return code >= 48 && code <= 57;\n};\nconst VALID_REGEX_FLAGS = new Set([\"g\", \"m\", \"s\", \"i\", \"y\", \"u\"]);\nconst forbiddenNumericSeparatorSiblings = {\n  decBinOct: [46, 66, 69, 79, 95, 98, 101, 111],\n  hex: [46, 88, 95, 120]\n};\nconst allowedNumericSeparatorSiblings = {};\nallowedNumericSeparatorSiblings.bin = [48, 49];\nallowedNumericSeparatorSiblings.oct = [...allowedNumericSeparatorSiblings.bin, 50, 51, 52, 53, 54, 55];\nallowedNumericSeparatorSiblings.dec = [...allowedNumericSeparatorSiblings.oct, 56, 57];\nallowedNumericSeparatorSiblings.hex = [...allowedNumericSeparatorSiblings.dec, 65, 66, 67, 68, 69, 70, 97, 98, 99, 100, 101, 102];\nclass Token {\n  constructor(state) {\n    this.type = state.type;\n    this.value = state.value;\n    this.start = state.start;\n    this.end = state.end;\n    this.loc = new SourceLocation(state.startLoc, state.endLoc);\n  }\n\n}\nclass Tokenizer extends LocationParser {\n  constructor(options, input) {\n    super();\n    this.tokens = [];\n    this.state = new State();\n    this.state.init(options);\n    this.input = input;\n    this.length = input.length;\n    this.isLookahead = false;\n  }\n\n  pushToken(token) {\n    this.tokens.length = this.state.tokensLength;\n    this.tokens.push(token);\n    ++this.state.tokensLength;\n  }\n\n  next() {\n    if (!this.isLookahead) {\n      this.checkKeywordEscapes();\n\n      if (this.options.tokens) {\n        this.pushToken(new Token(this.state));\n      }\n    }\n\n    this.state.lastTokEnd = this.state.end;\n    this.state.lastTokStart = this.state.start;\n    this.state.lastTokEndLoc = this.state.endLoc;\n    this.state.lastTokStartLoc = this.state.startLoc;\n    this.nextToken();\n  }\n\n  eat(type) {\n    if (this.match(type)) {\n      this.next();\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  match(type) {\n    return this.state.type === type;\n  }\n\n  lookahead() {\n    const old = this.state;\n    this.state = old.clone(true);\n    this.isLookahead = true;\n    this.next();\n    this.isLookahead = false;\n    const curr = this.state;\n    this.state = old;\n    return curr;\n  }\n\n  nextTokenStart() {\n    const thisTokEnd = this.state.pos;\n    skipWhiteSpace.lastIndex = thisTokEnd;\n    const skip = skipWhiteSpace.exec(this.input);\n    return thisTokEnd + skip[0].length;\n  }\n\n  lookaheadCharCode() {\n    return this.input.charCodeAt(this.nextTokenStart());\n  }\n\n  setStrict(strict) {\n    this.state.strict = strict;\n    if (!this.match(types.num) && !this.match(types.string)) return;\n    this.state.pos = this.state.start;\n\n    while (this.state.pos < this.state.lineStart) {\n      this.state.lineStart = this.input.lastIndexOf(\"\\n\", this.state.lineStart - 2) + 1;\n      --this.state.curLine;\n    }\n\n    this.nextToken();\n  }\n\n  curContext() {\n    return this.state.context[this.state.context.length - 1];\n  }\n\n  nextToken() {\n    const curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) this.skipSpace();\n    this.state.octalPositions = [];\n    this.state.start = this.state.pos;\n    this.state.startLoc = this.state.curPosition();\n\n    if (this.state.pos >= this.length) {\n      this.finishToken(types.eof);\n      return;\n    }\n\n    const override = curContext == null ? void 0 : curContext.override;\n\n    if (override) {\n      override(this);\n    } else {\n      this.getTokenFromCode(this.input.codePointAt(this.state.pos));\n    }\n  }\n\n  pushComment(block, text, start, end, startLoc, endLoc) {\n    const comment = {\n      type: block ? \"CommentBlock\" : \"CommentLine\",\n      value: text,\n      start: start,\n      end: end,\n      loc: new SourceLocation(startLoc, endLoc)\n    };\n    if (this.options.tokens) this.pushToken(comment);\n    this.state.comments.push(comment);\n    this.addComment(comment);\n  }\n\n  skipBlockComment() {\n    const startLoc = this.state.curPosition();\n    const start = this.state.pos;\n    const end = this.input.indexOf(\"*/\", this.state.pos + 2);\n    if (end === -1) throw this.raise(start, Errors.UnterminatedComment);\n    this.state.pos = end + 2;\n    lineBreakG.lastIndex = start;\n    let match;\n\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {\n      ++this.state.curLine;\n      this.state.lineStart = match.index + match[0].length;\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipLineComment(startSkip) {\n    const start = this.state.pos;\n    const startLoc = this.state.curPosition();\n    let ch = this.input.charCodeAt(this.state.pos += startSkip);\n\n    if (this.state.pos < this.length) {\n      while (!isNewLine(ch) && ++this.state.pos < this.length) {\n        ch = this.input.charCodeAt(this.state.pos);\n      }\n    }\n\n    if (this.isLookahead) return;\n    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());\n  }\n\n  skipSpace() {\n    loop: while (this.state.pos < this.length) {\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      switch (ch) {\n        case 32:\n        case 160:\n        case 9:\n          ++this.state.pos;\n          break;\n\n        case 13:\n          if (this.input.charCodeAt(this.state.pos + 1) === 10) {\n            ++this.state.pos;\n          }\n\n        case 10:\n        case 8232:\n        case 8233:\n          ++this.state.pos;\n          ++this.state.curLine;\n          this.state.lineStart = this.state.pos;\n          break;\n\n        case 47:\n          switch (this.input.charCodeAt(this.state.pos + 1)) {\n            case 42:\n              this.skipBlockComment();\n              break;\n\n            case 47:\n              this.skipLineComment(2);\n              break;\n\n            default:\n              break loop;\n          }\n\n          break;\n\n        default:\n          if (isWhitespace(ch)) {\n            ++this.state.pos;\n          } else {\n            break loop;\n          }\n\n      }\n    }\n  }\n\n  finishToken(type, val) {\n    this.state.end = this.state.pos;\n    this.state.endLoc = this.state.curPosition();\n    const prevType = this.state.type;\n    this.state.type = type;\n    this.state.value = val;\n    if (!this.isLookahead) this.updateContext(prevType);\n  }\n\n  readToken_numberSign() {\n    if (this.state.pos === 0 && this.readToken_interpreter()) {\n      return;\n    }\n\n    const nextPos = this.state.pos + 1;\n    const next = this.input.charCodeAt(nextPos);\n\n    if (next >= 48 && next <= 57) {\n      throw this.raise(this.state.pos, Errors.UnexpectedDigitAfterHash);\n    }\n\n    if (next === 123 || next === 91 && this.hasPlugin(\"recordAndTuple\")) {\n      this.expectPlugin(\"recordAndTuple\");\n\n      if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"hash\") {\n        throw this.raise(this.state.pos, next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType);\n      }\n\n      if (next === 123) {\n        this.finishToken(types.braceHashL);\n      } else {\n        this.finishToken(types.bracketHashL);\n      }\n\n      this.state.pos += 2;\n    } else {\n      this.finishOp(types.hash, 1);\n    }\n  }\n\n  readToken_dot() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next >= 48 && next <= 57) {\n      this.readNumber(true);\n      return;\n    }\n\n    if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {\n      this.state.pos += 3;\n      this.finishToken(types.ellipsis);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.dot);\n    }\n  }\n\n  readToken_slash() {\n    if (this.state.exprAllowed && !this.state.inType) {\n      ++this.state.pos;\n      this.readRegexp();\n      return;\n    }\n\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.slash, 1);\n    }\n  }\n\n  readToken_interpreter() {\n    if (this.state.pos !== 0 || this.length < 2) return false;\n    let ch = this.input.charCodeAt(this.state.pos + 1);\n    if (ch !== 33) return false;\n    const start = this.state.pos;\n    this.state.pos += 1;\n\n    while (!isNewLine(ch) && ++this.state.pos < this.length) {\n      ch = this.input.charCodeAt(this.state.pos);\n    }\n\n    const value = this.input.slice(start + 2, this.state.pos);\n    this.finishToken(types.interpreterDirective, value);\n    return true;\n  }\n\n  readToken_mult_modulo(code) {\n    let type = code === 42 ? types.star : types.modulo;\n    let width = 1;\n    let next = this.input.charCodeAt(this.state.pos + 1);\n    const exprAllowed = this.state.exprAllowed;\n\n    if (code === 42 && next === 42) {\n      width++;\n      next = this.input.charCodeAt(this.state.pos + 2);\n      type = types.exponent;\n    }\n\n    if (next === 61 && !exprAllowed) {\n      width++;\n      type = types.assign;\n    }\n\n    this.finishOp(type, width);\n  }\n\n  readToken_pipe_amp(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (this.input.charCodeAt(this.state.pos + 2) === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n      }\n\n      return;\n    }\n\n    if (code === 124) {\n      if (next === 62) {\n        this.finishOp(types.pipeline, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 125) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, Errors.RecordExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.braceBarR, 2);\n        return;\n      }\n\n      if (this.hasPlugin(\"recordAndTuple\") && next === 93) {\n        if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n          throw this.raise(this.state.pos, Errors.TupleExpressionBarIncorrectEndSyntaxType);\n        }\n\n        this.finishOp(types.bracketBarR, 2);\n        return;\n      }\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n      return;\n    }\n\n    this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n  }\n\n  readToken_caret() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.bitwiseXOR, 1);\n    }\n  }\n\n  readToken_plus_min(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 62 && (this.state.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos)))) {\n        this.skipLineComment(3);\n        this.skipSpace();\n        this.nextToken();\n        return;\n      }\n\n      this.finishOp(types.incDec, 2);\n      return;\n    }\n\n    if (next === 61) {\n      this.finishOp(types.assign, 2);\n    } else {\n      this.finishOp(types.plusMin, 1);\n    }\n  }\n\n  readToken_lt_gt(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    let size = 1;\n\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;\n\n      if (this.input.charCodeAt(this.state.pos + size) === 61) {\n        this.finishOp(types.assign, size + 1);\n        return;\n      }\n\n      this.finishOp(types.bitShift, size);\n      return;\n    }\n\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {\n      this.skipLineComment(4);\n      this.skipSpace();\n      this.nextToken();\n      return;\n    }\n\n    if (next === 61) {\n      size = 2;\n    }\n\n    this.finishOp(types.relational, size);\n  }\n\n  readToken_eq_excl(code) {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n\n    if (next === 61) {\n      this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);\n      return;\n    }\n\n    if (code === 61 && next === 62) {\n      this.state.pos += 2;\n      this.finishToken(types.arrow);\n      return;\n    }\n\n    this.finishOp(code === 61 ? types.eq : types.bang, 1);\n  }\n\n  readToken_question() {\n    const next = this.input.charCodeAt(this.state.pos + 1);\n    const next2 = this.input.charCodeAt(this.state.pos + 2);\n\n    if (next === 63 && !this.state.inType) {\n      if (next2 === 61) {\n        this.finishOp(types.assign, 3);\n      } else {\n        this.finishOp(types.nullishCoalescing, 2);\n      }\n    } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {\n      this.state.pos += 2;\n      this.finishToken(types.questionDot);\n    } else {\n      ++this.state.pos;\n      this.finishToken(types.question);\n    }\n  }\n\n  getTokenFromCode(code) {\n    switch (code) {\n      case 46:\n        this.readToken_dot();\n        return;\n\n      case 40:\n        ++this.state.pos;\n        this.finishToken(types.parenL);\n        return;\n\n      case 41:\n        ++this.state.pos;\n        this.finishToken(types.parenR);\n        return;\n\n      case 59:\n        ++this.state.pos;\n        this.finishToken(types.semi);\n        return;\n\n      case 44:\n        ++this.state.pos;\n        this.finishToken(types.comma);\n        return;\n\n      case 91:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, Errors.TupleExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.bracketBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.bracketL);\n        }\n\n        return;\n\n      case 93:\n        ++this.state.pos;\n        this.finishToken(types.bracketR);\n        return;\n\n      case 123:\n        if (this.hasPlugin(\"recordAndTuple\") && this.input.charCodeAt(this.state.pos + 1) === 124) {\n          if (this.getPluginOption(\"recordAndTuple\", \"syntaxType\") !== \"bar\") {\n            throw this.raise(this.state.pos, Errors.RecordExpressionBarIncorrectStartSyntaxType);\n          }\n\n          this.finishToken(types.braceBarL);\n          this.state.pos += 2;\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.braceL);\n        }\n\n        return;\n\n      case 125:\n        ++this.state.pos;\n        this.finishToken(types.braceR);\n        return;\n\n      case 58:\n        if (this.hasPlugin(\"functionBind\") && this.input.charCodeAt(this.state.pos + 1) === 58) {\n          this.finishOp(types.doubleColon, 2);\n        } else {\n          ++this.state.pos;\n          this.finishToken(types.colon);\n        }\n\n        return;\n\n      case 63:\n        this.readToken_question();\n        return;\n\n      case 96:\n        ++this.state.pos;\n        this.finishToken(types.backQuote);\n        return;\n\n      case 48:\n        {\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (next === 120 || next === 88) {\n            this.readRadixNumber(16);\n            return;\n          }\n\n          if (next === 111 || next === 79) {\n            this.readRadixNumber(8);\n            return;\n          }\n\n          if (next === 98 || next === 66) {\n            this.readRadixNumber(2);\n            return;\n          }\n        }\n\n      case 49:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 55:\n      case 56:\n      case 57:\n        this.readNumber(false);\n        return;\n\n      case 34:\n      case 39:\n        this.readString(code);\n        return;\n\n      case 47:\n        this.readToken_slash();\n        return;\n\n      case 37:\n      case 42:\n        this.readToken_mult_modulo(code);\n        return;\n\n      case 124:\n      case 38:\n        this.readToken_pipe_amp(code);\n        return;\n\n      case 94:\n        this.readToken_caret();\n        return;\n\n      case 43:\n      case 45:\n        this.readToken_plus_min(code);\n        return;\n\n      case 60:\n      case 62:\n        this.readToken_lt_gt(code);\n        return;\n\n      case 61:\n      case 33:\n        this.readToken_eq_excl(code);\n        return;\n\n      case 126:\n        this.finishOp(types.tilde, 1);\n        return;\n\n      case 64:\n        ++this.state.pos;\n        this.finishToken(types.at);\n        return;\n\n      case 35:\n        this.readToken_numberSign();\n        return;\n\n      case 92:\n        this.readWord();\n        return;\n\n      default:\n        if (isIdentifierStart(code)) {\n          this.readWord();\n          return;\n        }\n\n    }\n\n    throw this.raise(this.state.pos, Errors.InvalidOrUnexpectedToken, String.fromCodePoint(code));\n  }\n\n  finishOp(type, size) {\n    const str = this.input.slice(this.state.pos, this.state.pos + size);\n    this.state.pos += size;\n    this.finishToken(type, str);\n  }\n\n  readRegexp() {\n    const start = this.state.pos;\n    let escaped, inClass;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(start, Errors.UnterminatedRegExp);\n      }\n\n      const ch = this.input.charAt(this.state.pos);\n\n      if (lineBreak.test(ch)) {\n        throw this.raise(start, Errors.UnterminatedRegExp);\n      }\n\n      if (escaped) {\n        escaped = false;\n      } else {\n        if (ch === \"[\") {\n          inClass = true;\n        } else if (ch === \"]\" && inClass) {\n          inClass = false;\n        } else if (ch === \"/\" && !inClass) {\n          break;\n        }\n\n        escaped = ch === \"\\\\\";\n      }\n\n      ++this.state.pos;\n    }\n\n    const content = this.input.slice(start, this.state.pos);\n    ++this.state.pos;\n    let mods = \"\";\n\n    while (this.state.pos < this.length) {\n      const char = this.input[this.state.pos];\n      const charCode = this.input.codePointAt(this.state.pos);\n\n      if (VALID_REGEX_FLAGS.has(char)) {\n        if (mods.indexOf(char) > -1) {\n          this.raise(this.state.pos + 1, Errors.DuplicateRegExpFlags);\n        }\n      } else if (isIdentifierChar(charCode) || charCode === 92) {\n        this.raise(this.state.pos + 1, Errors.MalformedRegExpFlags);\n      } else {\n        break;\n      }\n\n      ++this.state.pos;\n      mods += char;\n    }\n\n    this.finishToken(types.regexp, {\n      pattern: content,\n      flags: mods\n    });\n  }\n\n  readInt(radix, len, forceLen, allowNumSeparator = true) {\n    const start = this.state.pos;\n    const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;\n    const allowedSiblings = radix === 16 ? allowedNumericSeparatorSiblings.hex : radix === 10 ? allowedNumericSeparatorSiblings.dec : radix === 8 ? allowedNumericSeparatorSiblings.oct : allowedNumericSeparatorSiblings.bin;\n    let invalid = false;\n    let total = 0;\n\n    for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      const code = this.input.charCodeAt(this.state.pos);\n      let val;\n\n      if (this.hasPlugin(\"numericSeparator\")) {\n        if (code === 95) {\n          const prev = this.input.charCodeAt(this.state.pos - 1);\n          const next = this.input.charCodeAt(this.state.pos + 1);\n\n          if (allowedSiblings.indexOf(next) === -1) {\n            this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);\n          } else if (forbiddenSiblings.indexOf(prev) > -1 || forbiddenSiblings.indexOf(next) > -1 || Number.isNaN(next)) {\n            this.raise(this.state.pos, Errors.UnexpectedNumericSeparator);\n          }\n\n          if (!allowNumSeparator) {\n            this.raise(this.state.pos, Errors.NumericSeparatorInEscapeSequence);\n          }\n\n          ++this.state.pos;\n          continue;\n        }\n      }\n\n      if (code >= 97) {\n        val = code - 97 + 10;\n      } else if (code >= 65) {\n        val = code - 65 + 10;\n      } else if (_isDigit(code)) {\n        val = code - 48;\n      } else {\n        val = Infinity;\n      }\n\n      if (val >= radix) {\n        if (this.options.errorRecovery && val <= 9) {\n          val = 0;\n          this.raise(this.state.start + i + 2, Errors.InvalidDigit, radix);\n        } else if (forceLen) {\n          val = 0;\n          invalid = true;\n        } else {\n          break;\n        }\n      }\n\n      ++this.state.pos;\n      total = total * radix + val;\n    }\n\n    if (this.state.pos === start || len != null && this.state.pos - start !== len || invalid) {\n      return null;\n    }\n\n    return total;\n  }\n\n  readRadixNumber(radix) {\n    const start = this.state.pos;\n    let isBigInt = false;\n    this.state.pos += 2;\n    const val = this.readInt(radix);\n\n    if (val == null) {\n      this.raise(this.state.start + 2, Errors.InvalidDigit, radix);\n    }\n\n    const next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 95) {\n      this.expectPlugin(\"numericSeparator\", this.state.pos);\n    }\n\n    if (next === 110) {\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, Errors.NumberIdentifier);\n    }\n\n    if (isBigInt) {\n      const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    this.finishToken(types.num, val);\n  }\n\n  readNumber(startsWithDot) {\n    const start = this.state.pos;\n    let isFloat = false;\n    let isBigInt = false;\n    let isNonOctalDecimalInt = false;\n\n    if (!startsWithDot && this.readInt(10) === null) {\n      this.raise(start, Errors.InvalidNumber);\n    }\n\n    let octal = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n\n    if (octal) {\n      if (this.state.strict) {\n        this.raise(start, Errors.StrictOctalLiteral);\n      }\n\n      if (/[89]/.test(this.input.slice(start, this.state.pos))) {\n        octal = false;\n        isNonOctalDecimalInt = true;\n      }\n    }\n\n    let next = this.input.charCodeAt(this.state.pos);\n\n    if (next === 46 && !octal) {\n      ++this.state.pos;\n      this.readInt(10);\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if ((next === 69 || next === 101) && !octal) {\n      next = this.input.charCodeAt(++this.state.pos);\n\n      if (next === 43 || next === 45) {\n        ++this.state.pos;\n      }\n\n      if (this.readInt(10) === null) this.raise(start, \"Invalid number\");\n      isFloat = true;\n      next = this.input.charCodeAt(this.state.pos);\n    }\n\n    if (this.hasPlugin(\"numericSeparator\") && (octal || isNonOctalDecimalInt)) {\n      const underscorePos = this.input.slice(start, this.state.pos).indexOf(\"_\");\n\n      if (underscorePos > 0) {\n        this.raise(underscorePos + start, Errors.ZeroDigitNumericSeparator);\n      }\n    }\n\n    if (next === 95) {\n      this.expectPlugin(\"numericSeparator\", this.state.pos);\n    }\n\n    if (next === 110) {\n      if (isFloat || octal || isNonOctalDecimalInt) {\n        this.raise(start, \"Invalid BigIntLiteral\");\n      }\n\n      ++this.state.pos;\n      isBigInt = true;\n    }\n\n    if (isIdentifierStart(this.input.codePointAt(this.state.pos))) {\n      throw this.raise(this.state.pos, Errors.NumberIdentifier);\n    }\n\n    const str = this.input.slice(start, this.state.pos).replace(/[_n]/g, \"\");\n\n    if (isBigInt) {\n      this.finishToken(types.bigint, str);\n      return;\n    }\n\n    const val = octal ? parseInt(str, 8) : parseFloat(str);\n    this.finishToken(types.num, val);\n  }\n\n  readCodePoint(throwOnInvalid) {\n    const ch = this.input.charCodeAt(this.state.pos);\n    let code;\n\n    if (ch === 123) {\n      const codePos = ++this.state.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.state.pos) - this.state.pos, true, throwOnInvalid);\n      ++this.state.pos;\n\n      if (code !== null && code > 0x10ffff) {\n        if (throwOnInvalid) {\n          this.raise(codePos, Errors.InvalidCodePoint);\n        } else {\n          return null;\n        }\n      }\n    } else {\n      code = this.readHexChar(4, false, throwOnInvalid);\n    }\n\n    return code;\n  }\n\n  readString(quote) {\n    let out = \"\",\n        chunkStart = ++this.state.pos;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n      if (ch === quote) break;\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.state.pos;\n      } else if (ch === 8232 || ch === 8233) {\n        ++this.state.pos;\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        throw this.raise(this.state.start, Errors.UnterminatedString);\n      } else {\n        ++this.state.pos;\n      }\n    }\n\n    out += this.input.slice(chunkStart, this.state.pos++);\n    this.finishToken(types.string, out);\n  }\n\n  readTmplToken() {\n    let out = \"\",\n        chunkStart = this.state.pos,\n        containsInvalid = false;\n\n    for (;;) {\n      if (this.state.pos >= this.length) {\n        throw this.raise(this.state.start, Errors.UnterminatedTemplate);\n      }\n\n      const ch = this.input.charCodeAt(this.state.pos);\n\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {\n        if (this.state.pos === this.state.start && this.match(types.template)) {\n          if (ch === 36) {\n            this.state.pos += 2;\n            this.finishToken(types.dollarBraceL);\n            return;\n          } else {\n            ++this.state.pos;\n            this.finishToken(types.backQuote);\n            return;\n          }\n        }\n\n        out += this.input.slice(chunkStart, this.state.pos);\n        this.finishToken(types.template, containsInvalid ? null : out);\n        return;\n      }\n\n      if (ch === 92) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        const escaped = this.readEscapedChar(true);\n\n        if (escaped === null) {\n          containsInvalid = true;\n        } else {\n          out += escaped;\n        }\n\n        chunkStart = this.state.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.state.pos);\n        ++this.state.pos;\n\n        switch (ch) {\n          case 13:\n            if (this.input.charCodeAt(this.state.pos) === 10) {\n              ++this.state.pos;\n            }\n\n          case 10:\n            out += \"\\n\";\n            break;\n\n          default:\n            out += String.fromCharCode(ch);\n            break;\n        }\n\n        ++this.state.curLine;\n        this.state.lineStart = this.state.pos;\n        chunkStart = this.state.pos;\n      } else {\n        ++this.state.pos;\n      }\n    }\n  }\n\n  readEscapedChar(inTemplate) {\n    const throwOnInvalid = !inTemplate;\n    const ch = this.input.charCodeAt(++this.state.pos);\n    ++this.state.pos;\n\n    switch (ch) {\n      case 110:\n        return \"\\n\";\n\n      case 114:\n        return \"\\r\";\n\n      case 120:\n        {\n          const code = this.readHexChar(2, false, throwOnInvalid);\n          return code === null ? null : String.fromCharCode(code);\n        }\n\n      case 117:\n        {\n          const code = this.readCodePoint(throwOnInvalid);\n          return code === null ? null : String.fromCodePoint(code);\n        }\n\n      case 116:\n        return \"\\t\";\n\n      case 98:\n        return \"\\b\";\n\n      case 118:\n        return \"\\u000b\";\n\n      case 102:\n        return \"\\f\";\n\n      case 13:\n        if (this.input.charCodeAt(this.state.pos) === 10) {\n          ++this.state.pos;\n        }\n\n      case 10:\n        this.state.lineStart = this.state.pos;\n        ++this.state.curLine;\n\n      case 8232:\n      case 8233:\n        return \"\";\n\n      case 56:\n      case 57:\n        if (inTemplate) {\n          return null;\n        }\n\n      default:\n        if (ch >= 48 && ch <= 55) {\n          const codePos = this.state.pos - 1;\n          let octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];\n          let octal = parseInt(octalStr, 8);\n\n          if (octal > 255) {\n            octalStr = octalStr.slice(0, -1);\n            octal = parseInt(octalStr, 8);\n          }\n\n          this.state.pos += octalStr.length - 1;\n          const next = this.input.charCodeAt(this.state.pos);\n\n          if (octalStr !== \"0\" || next === 56 || next === 57) {\n            if (inTemplate) {\n              return null;\n            } else if (this.state.strict) {\n              this.raise(codePos, Errors.StrictOctalLiteral);\n            } else {\n              this.state.octalPositions.push(codePos);\n            }\n          }\n\n          return String.fromCharCode(octal);\n        }\n\n        return String.fromCharCode(ch);\n    }\n  }\n\n  readHexChar(len, forceLen, throwOnInvalid) {\n    const codePos = this.state.pos;\n    const n = this.readInt(16, len, forceLen, false);\n\n    if (n === null) {\n      if (throwOnInvalid) {\n        this.raise(codePos, Errors.InvalidEscapeSequence);\n      } else {\n        this.state.pos = codePos - 1;\n      }\n    }\n\n    return n;\n  }\n\n  readWord1() {\n    let word = \"\";\n    this.state.containsEsc = false;\n    const start = this.state.pos;\n    let chunkStart = this.state.pos;\n\n    while (this.state.pos < this.length) {\n      const ch = this.input.codePointAt(this.state.pos);\n\n      if (isIdentifierChar(ch)) {\n        this.state.pos += ch <= 0xffff ? 1 : 2;\n      } else if (this.state.isIterator && ch === 64) {\n        ++this.state.pos;\n      } else if (ch === 92) {\n        this.state.containsEsc = true;\n        word += this.input.slice(chunkStart, this.state.pos);\n        const escStart = this.state.pos;\n        const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;\n\n        if (this.input.charCodeAt(++this.state.pos) !== 117) {\n          this.raise(this.state.pos, Errors.MissingUnicodeEscape);\n          continue;\n        }\n\n        ++this.state.pos;\n        const esc = this.readCodePoint(true);\n\n        if (esc !== null) {\n          if (!identifierCheck(esc)) {\n            this.raise(escStart, Errors.EscapedCharNotAnIdentifier);\n          }\n\n          word += String.fromCodePoint(esc);\n        }\n\n        chunkStart = this.state.pos;\n      } else {\n        break;\n      }\n    }\n\n    return word + this.input.slice(chunkStart, this.state.pos);\n  }\n\n  isIterator(word) {\n    return word === \"@@iterator\" || word === \"@@asyncIterator\";\n  }\n\n  readWord() {\n    const word = this.readWord1();\n    const type = keywords.get(word) || types.name;\n\n    if (this.state.isIterator && (!this.isIterator(word) || !this.state.inType)) {\n      this.raise(this.state.pos, Errors.InvalidIdentifier, word);\n    }\n\n    this.finishToken(type, word);\n  }\n\n  checkKeywordEscapes() {\n    const kw = this.state.type.keyword;\n\n    if (kw && this.state.containsEsc) {\n      this.raise(this.state.start, Errors.InvalidEscapedReservedWord, kw);\n    }\n  }\n\n  braceIsBlock(prevType) {\n    const parent = this.curContext();\n\n    if (parent === types$1.functionExpression || parent === types$1.functionStatement) {\n      return true;\n    }\n\n    if (prevType === types.colon && (parent === types$1.braceStatement || parent === types$1.braceExpression)) {\n      return !parent.isExpr;\n    }\n\n    if (prevType === types._return || prevType === types.name && this.state.exprAllowed) {\n      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n    }\n\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n      return true;\n    }\n\n    if (prevType === types.braceL) {\n      return parent === types$1.braceStatement;\n    }\n\n    if (prevType === types._var || prevType === types._const || prevType === types.name) {\n      return false;\n    }\n\n    if (prevType === types.relational) {\n      return true;\n    }\n\n    return !this.state.exprAllowed;\n  }\n\n  updateContext(prevType) {\n    const type = this.state.type;\n    let update;\n\n    if (type.keyword && (prevType === types.dot || prevType === types.questionDot)) {\n      this.state.exprAllowed = false;\n    } else if (update = type.updateContext) {\n      update.call(this, prevType);\n    } else {\n      this.state.exprAllowed = type.beforeExpr;\n    }\n  }\n\n}\n\nclass UtilParser extends Tokenizer {\n  addExtra(node, key, val) {\n    if (!node) return;\n    const extra = node.extra = node.extra || {};\n    extra[key] = val;\n  }\n\n  isRelational(op) {\n    return this.match(types.relational) && this.state.value === op;\n  }\n\n  isLookaheadRelational(op) {\n    const next = this.nextTokenStart();\n\n    if (this.input.charAt(next) === op) {\n      if (next + 1 === this.input.length) {\n        return true;\n      }\n\n      const afterNext = this.input.charCodeAt(next + 1);\n      return afterNext !== op.charCodeAt(0) && afterNext !== 61;\n    }\n\n    return false;\n  }\n\n  expectRelational(op) {\n    if (this.isRelational(op)) {\n      this.next();\n    } else {\n      this.unexpected(null, types.relational);\n    }\n  }\n\n  isContextual(name) {\n    return this.match(types.name) && this.state.value === name && !this.state.containsEsc;\n  }\n\n  isUnparsedContextual(nameStart, name) {\n    const nameEnd = nameStart + name.length;\n    return this.input.slice(nameStart, nameEnd) === name && (nameEnd === this.input.length || !isIdentifierChar(this.input.charCodeAt(nameEnd)));\n  }\n\n  isLookaheadContextual(name) {\n    const next = this.nextTokenStart();\n    return this.isUnparsedContextual(next, name);\n  }\n\n  eatContextual(name) {\n    return this.isContextual(name) && this.eat(types.name);\n  }\n\n  expectContextual(name, message) {\n    if (!this.eatContextual(name)) this.unexpected(null, message);\n  }\n\n  canInsertSemicolon() {\n    return this.match(types.eof) || this.match(types.braceR) || this.hasPrecedingLineBreak();\n  }\n\n  hasPrecedingLineBreak() {\n    return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));\n  }\n\n  isLineTerminator() {\n    return this.eat(types.semi) || this.canInsertSemicolon();\n  }\n\n  semicolon() {\n    if (!this.isLineTerminator()) this.unexpected(null, types.semi);\n  }\n\n  expect(type, pos) {\n    this.eat(type) || this.unexpected(pos, type);\n  }\n\n  assertNoSpace(message = \"Unexpected space.\") {\n    if (this.state.start > this.state.lastTokEnd) {\n      this.raise(this.state.lastTokEnd, message);\n    }\n  }\n\n  unexpected(pos, messageOrType = \"Unexpected token\") {\n    if (typeof messageOrType !== \"string\") {\n      messageOrType = `Unexpected token, expected \"${messageOrType.label}\"`;\n    }\n\n    throw this.raise(pos != null ? pos : this.state.start, messageOrType);\n  }\n\n  expectPlugin(name, pos) {\n    if (!this.hasPlugin(name)) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: [name]\n      }, `This experimental syntax requires enabling the parser plugin: '${name}'`);\n    }\n\n    return true;\n  }\n\n  expectOnePlugin(names, pos) {\n    if (!names.some(n => this.hasPlugin(n))) {\n      throw this.raiseWithData(pos != null ? pos : this.state.start, {\n        missingPlugin: names\n      }, `This experimental syntax requires enabling one of the following parser plugin(s): '${names.join(\", \")}'`);\n    }\n  }\n\n  checkYieldAwaitInDefaultParams() {\n    if (this.state.yieldPos !== -1 && (this.state.awaitPos === -1 || this.state.yieldPos < this.state.awaitPos)) {\n      this.raise(this.state.yieldPos, \"Yield cannot be used as name inside a generator function\");\n    }\n\n    if (this.state.awaitPos !== -1) {\n      this.raise(this.state.awaitPos, \"Await cannot be used as name inside an async function\");\n    }\n  }\n\n  tryParse(fn, oldState = this.state.clone()) {\n    const abortSignal = {\n      node: null\n    };\n\n    try {\n      const node = fn((node = null) => {\n        abortSignal.node = node;\n        throw abortSignal;\n      });\n\n      if (this.state.errors.length > oldState.errors.length) {\n        const failState = this.state;\n        this.state = oldState;\n        return {\n          node,\n          error: failState.errors[oldState.errors.length],\n          thrown: false,\n          aborted: false,\n          failState\n        };\n      }\n\n      return {\n        node,\n        error: null,\n        thrown: false,\n        aborted: false,\n        failState: null\n      };\n    } catch (error) {\n      const failState = this.state;\n      this.state = oldState;\n\n      if (error instanceof SyntaxError) {\n        return {\n          node: null,\n          error,\n          thrown: true,\n          aborted: false,\n          failState\n        };\n      }\n\n      if (error === abortSignal) {\n        return {\n          node: abortSignal.node,\n          error: null,\n          thrown: false,\n          aborted: true,\n          failState\n        };\n      }\n\n      throw error;\n    }\n  }\n\n  checkExpressionErrors(refExpressionErrors, andThrow) {\n    if (!refExpressionErrors) return false;\n    const {\n      shorthandAssign,\n      doubleProto\n    } = refExpressionErrors;\n    if (!andThrow) return shorthandAssign >= 0 || doubleProto >= 0;\n\n    if (shorthandAssign >= 0) {\n      this.unexpected(shorthandAssign);\n    }\n\n    if (doubleProto >= 0) {\n      this.raise(doubleProto, Errors.DuplicateProto);\n    }\n  }\n\n}\nclass ExpressionErrors {\n  constructor() {\n    this.shorthandAssign = -1;\n    this.doubleProto = -1;\n  }\n\n}\n\nclass Node {\n  constructor(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    this.loc = new SourceLocation(loc);\n    if (parser && parser.options.ranges) this.range = [pos, 0];\n    if (parser && parser.filename) this.loc.filename = parser.filename;\n  }\n\n  __clone() {\n    const newNode = new Node();\n    const keys = Object.keys(this);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n\n      if (key !== \"leadingComments\" && key !== \"trailingComments\" && key !== \"innerComments\") {\n        newNode[key] = this[key];\n      }\n    }\n\n    return newNode;\n  }\n\n}\n\nclass NodeUtils extends UtilParser {\n  startNode() {\n    return new Node(this, this.state.start, this.state.startLoc);\n  }\n\n  startNodeAt(pos, loc) {\n    return new Node(this, pos, loc);\n  }\n\n  startNodeAtNode(type) {\n    return this.startNodeAt(type.start, type.loc.start);\n  }\n\n  finishNode(node, type) {\n    return this.finishNodeAt(node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);\n  }\n\n  finishNodeAt(node, type, pos, loc) {\n\n    node.type = type;\n    node.end = pos;\n    node.loc.end = loc;\n    if (this.options.ranges) node.range[1] = pos;\n    this.processComment(node);\n    return node;\n  }\n\n  resetStartLocation(node, start, startLoc) {\n    node.start = start;\n    node.loc.start = startLoc;\n    if (this.options.ranges) node.range[0] = start;\n  }\n\n  resetEndLocation(node, end = this.state.lastTokEnd, endLoc = this.state.lastTokEndLoc) {\n    node.end = end;\n    node.loc.end = endLoc;\n    if (this.options.ranges) node.range[1] = end;\n  }\n\n  resetStartLocationFromNode(node, locationNode) {\n    this.resetStartLocation(node, locationNode.start, locationNode.loc.start);\n  }\n\n}\n\nconst unwrapParenthesizedExpression = node => {\n  return node.type === \"ParenthesizedExpression\" ? unwrapParenthesizedExpression(node.expression) : node;\n};\n\nclass LValParser extends NodeUtils {\n  toAssignable(node) {\n    var _node$extra, _node$extra3;\n\n    let parenthesized = undefined;\n\n    if (node.type === \"ParenthesizedExpression\" || ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized)) {\n      parenthesized = unwrapParenthesizedExpression(node);\n\n      if (parenthesized.type !== \"Identifier\" && parenthesized.type !== \"MemberExpression\") {\n        this.raise(node.start, Errors.InvalidParenthesizedAssignment);\n      }\n    }\n\n    switch (node.type) {\n      case \"Identifier\":\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"AssignmentPattern\":\n        break;\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n\n        for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {\n          var _node$extra2;\n\n          const prop = node.properties[i];\n          const isLast = i === last;\n          this.toAssignableObjectExpressionProp(prop, isLast);\n\n          if (isLast && prop.type === \"RestElement\" && ((_node$extra2 = node.extra) == null ? void 0 : _node$extra2.trailingComma)) {\n            this.raiseRestNotLast(node.extra.trailingComma);\n          }\n        }\n\n        break;\n\n      case \"ObjectProperty\":\n        this.toAssignable(node.value);\n        break;\n\n      case \"SpreadElement\":\n        {\n          this.checkToRestConversion(node);\n          node.type = \"RestElement\";\n          const arg = node.argument;\n          this.toAssignable(arg);\n          break;\n        }\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingComma);\n        break;\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, Errors.MissingEqInAssignment);\n        }\n\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left);\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(parenthesized);\n        break;\n    }\n\n    return node;\n  }\n\n  toAssignableObjectExpressionProp(prop, isLast) {\n    if (prop.type === \"ObjectMethod\") {\n      const error = prop.kind === \"get\" || prop.kind === \"set\" ? Errors.PatternHasAccessor : Errors.PatternHasMethod;\n      this.raise(prop.key.start, error);\n    } else if (prop.type === \"SpreadElement\" && !isLast) {\n      this.raiseRestNotLast(prop.start);\n    } else {\n      this.toAssignable(prop);\n    }\n  }\n\n  toAssignableList(exprList, trailingCommaPos) {\n    let end = exprList.length;\n\n    if (end) {\n      const last = exprList[end - 1];\n\n      if (last && last.type === \"RestElement\") {\n        --end;\n      } else if (last && last.type === \"SpreadElement\") {\n        last.type = \"RestElement\";\n        const arg = last.argument;\n        this.toAssignable(arg);\n\n        if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\" && arg.type !== \"ObjectPattern\") {\n          this.unexpected(arg.start);\n        }\n\n        if (trailingCommaPos) {\n          this.raiseTrailingCommaAfterRest(trailingCommaPos);\n        }\n\n        --end;\n      }\n    }\n\n    for (let i = 0; i < end; i++) {\n      const elt = exprList[i];\n\n      if (elt) {\n        this.toAssignable(elt);\n\n        if (elt.type === \"RestElement\") {\n          this.raiseRestNotLast(elt.start);\n        }\n      }\n    }\n\n    return exprList;\n  }\n\n  toReferencedList(exprList, isParenthesizedExpr) {\n    return exprList;\n  }\n\n  toReferencedListDeep(exprList, isParenthesizedExpr) {\n    this.toReferencedList(exprList, isParenthesizedExpr);\n\n    for (let _i = 0; _i < exprList.length; _i++) {\n      const expr = exprList[_i];\n\n      if (expr && expr.type === \"ArrayExpression\") {\n        this.toReferencedListDeep(expr.elements);\n      }\n    }\n  }\n\n  parseSpread(refExpressionErrors, refNeedsArrowPos) {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refExpressionErrors, undefined, refNeedsArrowPos);\n    return this.finishNode(node, \"SpreadElement\");\n  }\n\n  parseRestBinding() {\n    const node = this.startNode();\n    this.next();\n    node.argument = this.parseBindingAtom();\n    return this.finishNode(node, \"RestElement\");\n  }\n\n  parseBindingAtom() {\n    switch (this.state.type) {\n      case types.bracketL:\n        {\n          const node = this.startNode();\n          this.next();\n          node.elements = this.parseBindingList(types.bracketR, 93, true);\n          return this.finishNode(node, \"ArrayPattern\");\n        }\n\n      case types.braceL:\n        return this.parseObj(types.braceR, true);\n    }\n\n    return this.parseIdentifier();\n  }\n\n  parseBindingList(close, closeCharCode, allowEmpty, allowModifiers) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n      }\n\n      if (allowEmpty && this.match(types.comma)) {\n        elts.push(null);\n      } else if (this.eat(close)) {\n        break;\n      } else if (this.match(types.ellipsis)) {\n        elts.push(this.parseAssignableListItemTypes(this.parseRestBinding()));\n        this.checkCommaAfterRest(closeCharCode);\n        this.expect(close);\n        break;\n      } else {\n        const decorators = [];\n\n        if (this.match(types.at) && this.hasPlugin(\"decorators\")) {\n          this.raise(this.state.start, Errors.UnsupportedParameterDecorator);\n        }\n\n        while (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n        }\n\n        elts.push(this.parseAssignableListItem(allowModifiers, decorators));\n      }\n    }\n\n    return elts;\n  }\n\n  parseAssignableListItem(allowModifiers, decorators) {\n    const left = this.parseMaybeDefault();\n    this.parseAssignableListItemTypes(left);\n    const elt = this.parseMaybeDefault(left.start, left.loc.start, left);\n\n    if (decorators.length) {\n      left.decorators = decorators;\n    }\n\n    return elt;\n  }\n\n  parseAssignableListItemTypes(param) {\n    return param;\n  }\n\n  parseMaybeDefault(startPos, startLoc, left) {\n    startLoc = startLoc || this.state.startLoc;\n    startPos = startPos || this.state.start;\n    left = left || this.parseBindingAtom();\n    if (!this.eat(types.eq)) return left;\n    const node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\");\n  }\n\n  checkLVal(expr, bindingType = BIND_NONE, checkClashes, contextDescription, disallowLetBinding, strictModeChanged = false) {\n    switch (expr.type) {\n      case \"Identifier\":\n        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(expr.name, this.inModule) : isStrictBindOnlyReservedWord(expr.name))) {\n          this.raise(expr.start, bindingType === BIND_NONE ? Errors.StrictEvalArguments : Errors.StrictEvalArgumentsBinding, expr.name);\n        }\n\n        if (checkClashes) {\n          const key = `_${expr.name}`;\n\n          if (checkClashes[key]) {\n            this.raise(expr.start, Errors.ParamDupe);\n          } else {\n            checkClashes[key] = true;\n          }\n        }\n\n        if (disallowLetBinding && expr.name === \"let\") {\n          this.raise(expr.start, Errors.LetInLexicalBinding);\n        }\n\n        if (!(bindingType & BIND_NONE)) {\n          this.scope.declareName(expr.name, bindingType, expr.start);\n        }\n\n        break;\n\n      case \"MemberExpression\":\n        if (bindingType !== BIND_NONE) {\n          this.raise(expr.start, Errors.InvalidPropertyBindingPattern);\n        }\n\n        break;\n\n      case \"ObjectPattern\":\n        for (let _i2 = 0, _expr$properties = expr.properties; _i2 < _expr$properties.length; _i2++) {\n          let prop = _expr$properties[_i2];\n          if (prop.type === \"ObjectProperty\") prop = prop.value;else if (prop.type === \"ObjectMethod\") continue;\n          this.checkLVal(prop, bindingType, checkClashes, \"object destructuring pattern\", disallowLetBinding);\n        }\n\n        break;\n\n      case \"ArrayPattern\":\n        for (let _i3 = 0, _expr$elements = expr.elements; _i3 < _expr$elements.length; _i3++) {\n          const elem = _expr$elements[_i3];\n\n          if (elem) {\n            this.checkLVal(elem, bindingType, checkClashes, \"array destructuring pattern\", disallowLetBinding);\n          }\n        }\n\n        break;\n\n      case \"AssignmentPattern\":\n        this.checkLVal(expr.left, bindingType, checkClashes, \"assignment pattern\");\n        break;\n\n      case \"RestElement\":\n        this.checkLVal(expr.argument, bindingType, checkClashes, \"rest element\");\n        break;\n\n      case \"ParenthesizedExpression\":\n        this.checkLVal(expr.expression, bindingType, checkClashes, \"parenthesized expression\");\n        break;\n\n      default:\n        {\n          this.raise(expr.start, bindingType === BIND_NONE ? Errors.InvalidLhs : Errors.InvalidLhsBinding, contextDescription);\n        }\n    }\n  }\n\n  checkToRestConversion(node) {\n    if (node.argument.type !== \"Identifier\" && node.argument.type !== \"MemberExpression\") {\n      this.raise(node.argument.start, Errors.InvalidRestAssignmentPattern);\n    }\n  }\n\n  checkCommaAfterRest(close) {\n    if (this.match(types.comma)) {\n      if (this.lookaheadCharCode() === close) {\n        this.raiseTrailingCommaAfterRest(this.state.start);\n      } else {\n        this.raiseRestNotLast(this.state.start);\n      }\n    }\n  }\n\n  raiseRestNotLast(pos) {\n    throw this.raise(pos, Errors.ElementAfterRest);\n  }\n\n  raiseTrailingCommaAfterRest(pos) {\n    this.raise(pos, Errors.RestTrailingComma);\n  }\n\n}\n\nclass ExpressionParser extends LValParser {\n  checkDuplicatedProto(prop, protoRef, refExpressionErrors) {\n    if (prop.type === \"SpreadElement\" || prop.computed || prop.kind || prop.shorthand) {\n      return;\n    }\n\n    const key = prop.key;\n    const name = key.type === \"Identifier\" ? key.name : String(key.value);\n\n    if (name === \"__proto__\") {\n      if (protoRef.used) {\n        if (refExpressionErrors) {\n          if (refExpressionErrors.doubleProto === -1) {\n            refExpressionErrors.doubleProto = key.start;\n          }\n        } else {\n          this.raise(key.start, Errors.DuplicateProto);\n        }\n      }\n\n      protoRef.used = true;\n    }\n  }\n\n  getExpression() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    this.nextToken();\n    const expr = this.parseExpression();\n\n    if (!this.match(types.eof)) {\n      this.unexpected();\n    }\n\n    expr.comments = this.state.comments;\n    expr.errors = this.state.errors;\n    return expr;\n  }\n\n  parseExpression(noIn, refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const expr = this.parseMaybeAssign(noIn, refExpressionErrors);\n\n    if (this.match(types.comma)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n\n      while (this.eat(types.comma)) {\n        node.expressions.push(this.parseMaybeAssign(noIn, refExpressionErrors));\n      }\n\n      this.toReferencedList(node.expressions);\n      return this.finishNode(node, \"SequenceExpression\");\n    }\n\n    return expr;\n  }\n\n  parseMaybeAssign(noIn, refExpressionErrors, afterLeftParse, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    if (this.isContextual(\"yield\")) {\n      if (this.prodParam.hasYield) {\n        let left = this.parseYield(noIn);\n\n        if (afterLeftParse) {\n          left = afterLeftParse.call(this, left, startPos, startLoc);\n        }\n\n        return left;\n      } else {\n        this.state.exprAllowed = false;\n      }\n    }\n\n    let ownExpressionErrors;\n\n    if (refExpressionErrors) {\n      ownExpressionErrors = false;\n    } else {\n      refExpressionErrors = new ExpressionErrors();\n      ownExpressionErrors = true;\n    }\n\n    if (this.match(types.parenL) || this.match(types.name)) {\n      this.state.potentialArrowAt = this.state.start;\n    }\n\n    let left = this.parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos);\n\n    if (afterLeftParse) {\n      left = afterLeftParse.call(this, left, startPos, startLoc);\n    }\n\n    if (this.state.type.isAssign) {\n      const node = this.startNodeAt(startPos, startLoc);\n      const operator = this.state.value;\n      node.operator = operator;\n\n      if (operator === \"??=\") {\n        this.expectPlugin(\"logicalAssignment\");\n      }\n\n      if (operator === \"||=\" || operator === \"&&=\") {\n        this.expectPlugin(\"logicalAssignment\");\n      }\n\n      if (this.match(types.eq)) {\n        node.left = this.toAssignable(left);\n        refExpressionErrors.doubleProto = -1;\n      } else {\n        node.left = left;\n      }\n\n      if (refExpressionErrors.shorthandAssign >= node.left.start) {\n        refExpressionErrors.shorthandAssign = -1;\n      }\n\n      this.checkLVal(left, undefined, undefined, \"assignment expression\");\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\");\n    } else if (ownExpressionErrors) {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    return left;\n  }\n\n  parseMaybeConditional(noIn, refExpressionErrors, refNeedsArrowPos) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprOps(noIn, refExpressionErrors);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n    return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);\n  }\n\n  parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos) {\n    if (this.eat(types.question)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprOps(noIn, refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseMaybeUnary(refExpressionErrors);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    if (this.checkExpressionErrors(refExpressionErrors, false)) {\n      return expr;\n    }\n\n    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n  }\n\n  parseExprOp(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    let prec = this.state.type.binop;\n\n    if (prec != null && (!noIn || !this.match(types._in))) {\n      if (prec > minPrec) {\n        const operator = this.state.value;\n\n        if (operator === \"|>\" && this.state.inFSharpPipelineDirectBody) {\n          return left;\n        }\n\n        const node = this.startNodeAt(leftStartPos, leftStartLoc);\n        node.left = left;\n        node.operator = operator;\n\n        if (operator === \"**\" && left.type === \"UnaryExpression\" && (this.options.createParenthesizedExpressions || !(left.extra && left.extra.parenthesized))) {\n          this.raise(left.argument.start, Errors.UnexpectedTokenUnaryExponentiation);\n        }\n\n        const op = this.state.type;\n        const logical = op === types.logicalOR || op === types.logicalAND;\n        const coalesce = op === types.nullishCoalescing;\n\n        if (op === types.pipeline) {\n          this.expectPlugin(\"pipelineOperator\");\n          this.state.inPipeline = true;\n          this.checkPipelineAtInfixOperator(left, leftStartPos);\n        } else if (coalesce) {\n          prec = types.logicalAND.binop;\n        }\n\n        this.next();\n\n        if (op === types.pipeline && this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"minimal\") {\n          if (this.match(types.name) && this.state.value === \"await\" && this.prodParam.hasAwait) {\n            throw this.raise(this.state.start, Errors.UnexpectedAwaitAfterPipelineBody);\n          }\n        }\n\n        node.right = this.parseExprOpRightExpr(op, prec, noIn);\n        this.finishNode(node, logical || coalesce ? \"LogicalExpression\" : \"BinaryExpression\");\n        const nextOp = this.state.type;\n\n        if (coalesce && (nextOp === types.logicalOR || nextOp === types.logicalAND) || logical && nextOp === types.nullishCoalescing) {\n          throw this.raise(this.state.start, Errors.MixingCoalesceWithLogical);\n        }\n\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n      }\n    }\n\n    return left;\n  }\n\n  parseExprOpRightExpr(op, prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n\n    switch (op) {\n      case types.pipeline:\n        switch (this.getPluginOption(\"pipelineOperator\", \"proposal\")) {\n          case \"smart\":\n            return this.withTopicPermittingContext(() => {\n              return this.parseSmartPipelineBody(this.parseExprOpBaseRightExpr(op, prec, noIn), startPos, startLoc);\n            });\n\n          case \"fsharp\":\n            return this.withSoloAwaitPermittingContext(() => {\n              return this.parseFSharpPipelineBody(prec, noIn);\n            });\n        }\n\n      default:\n        return this.parseExprOpBaseRightExpr(op, prec, noIn);\n    }\n  }\n\n  parseExprOpBaseRightExpr(op, prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);\n  }\n\n  parseMaybeUnary(refExpressionErrors) {\n    if (this.isContextual(\"await\") && this.isAwaitAllowed()) {\n      return this.parseAwait();\n    } else if (this.state.type.prefix) {\n      const node = this.startNode();\n      const update = this.match(types.incDec);\n      node.operator = this.state.value;\n      node.prefix = true;\n\n      if (node.operator === \"throw\") {\n        this.expectPlugin(\"throwExpressions\");\n      }\n\n      this.next();\n      node.argument = this.parseMaybeUnary();\n      this.checkExpressionErrors(refExpressionErrors, true);\n\n      if (update) {\n        this.checkLVal(node.argument, undefined, undefined, \"prefix operation\");\n      } else if (this.state.strict && node.operator === \"delete\") {\n        const arg = node.argument;\n\n        if (arg.type === \"Identifier\") {\n          this.raise(node.start, Errors.StrictDelete);\n        } else if (arg.type === \"MemberExpression\" && arg.property.type === \"PrivateName\") {\n          this.raise(node.start, Errors.DeletePrivateField);\n        }\n      }\n\n      return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    }\n\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let expr = this.parseExprSubscripts(refExpressionErrors);\n    if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;\n\n    while (this.state.type.postfix && !this.canInsertSemicolon()) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.state.value;\n      node.prefix = false;\n      node.argument = expr;\n      this.checkLVal(expr, undefined, undefined, \"postfix operation\");\n      this.next();\n      expr = this.finishNode(node, \"UpdateExpression\");\n    }\n\n    return expr;\n  }\n\n  parseExprSubscripts(refExpressionErrors) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    const potentialArrowAt = this.state.potentialArrowAt;\n    const expr = this.parseExprAtom(refExpressionErrors);\n\n    if (expr.type === \"ArrowFunctionExpression\" && expr.start === potentialArrowAt) {\n      return expr;\n    }\n\n    return this.parseSubscripts(expr, startPos, startLoc);\n  }\n\n  parseSubscripts(base, startPos, startLoc, noCalls) {\n    const state = {\n      optionalChainMember: false,\n      maybeAsyncArrow: this.atPossibleAsyncArrow(base),\n      stop: false\n    };\n\n    do {\n      const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;\n\n      if (state.maybeAsyncArrow) {\n        this.state.maybeInAsyncArrowHead = true;\n      }\n\n      base = this.parseSubscript(base, startPos, startLoc, noCalls, state);\n      state.maybeAsyncArrow = false;\n      this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;\n    } while (!state.stop);\n\n    return base;\n  }\n\n  parseSubscript(base, startPos, startLoc, noCalls, state) {\n    if (!noCalls && this.eat(types.doubleColon)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.callee = this.parseNoCallExpr();\n      state.stop = true;\n      return this.parseSubscripts(this.finishNode(node, \"BindExpression\"), startPos, startLoc, noCalls);\n    }\n\n    let optional = false;\n\n    if (this.match(types.questionDot)) {\n      state.optionalChainMember = optional = true;\n\n      if (noCalls && this.lookaheadCharCode() === 40) {\n        state.stop = true;\n        return base;\n      }\n\n      this.next();\n    }\n\n    const computed = this.eat(types.bracketL);\n\n    if (optional && !this.match(types.parenL) && !this.match(types.backQuote) || computed || this.eat(types.dot)) {\n      const node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this.parseExpression() : optional ? this.parseIdentifier(true) : this.parseMaybePrivateName(true);\n      node.computed = computed;\n\n      if (node.property.type === \"PrivateName\") {\n        if (node.object.type === \"Super\") {\n          this.raise(startPos, Errors.SuperPrivateField);\n        }\n\n        this.classScope.usePrivateName(node.property.id.name, node.property.start);\n      }\n\n      if (computed) {\n        this.expect(types.bracketR);\n      }\n\n      if (state.optionalChainMember) {\n        node.optional = optional;\n        return this.finishNode(node, \"OptionalMemberExpression\");\n      } else {\n        return this.finishNode(node, \"MemberExpression\");\n      }\n    } else if (!noCalls && this.match(types.parenL)) {\n      const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n      const oldYieldPos = this.state.yieldPos;\n      const oldAwaitPos = this.state.awaitPos;\n      this.state.maybeInArrowParameters = true;\n      this.state.yieldPos = -1;\n      this.state.awaitPos = -1;\n      this.next();\n      let node = this.startNodeAt(startPos, startLoc);\n      node.callee = base;\n\n      if (optional) {\n        node.optional = true;\n        node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      } else {\n        node.arguments = this.parseCallExpressionArguments(types.parenR, state.maybeAsyncArrow, base.type === \"Import\", base.type !== \"Super\", node);\n      }\n\n      this.finishCallExpression(node, state.optionalChainMember);\n\n      if (state.maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {\n        state.stop = true;\n        node = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), node);\n        this.checkYieldAwaitInDefaultParams();\n        this.state.yieldPos = oldYieldPos;\n        this.state.awaitPos = oldAwaitPos;\n      } else {\n        this.toReferencedListDeep(node.arguments);\n        if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;\n\n        if (!this.isAwaitAllowed() && !oldMaybeInArrowParameters || oldAwaitPos !== -1) {\n          this.state.awaitPos = oldAwaitPos;\n        }\n      }\n\n      this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n      return node;\n    } else if (this.match(types.backQuote)) {\n      return this.parseTaggedTemplateExpression(startPos, startLoc, base, state);\n    } else {\n      state.stop = true;\n      return base;\n    }\n  }\n\n  parseTaggedTemplateExpression(startPos, startLoc, base, state, typeArguments) {\n    const node = this.startNodeAt(startPos, startLoc);\n    node.tag = base;\n    node.quasi = this.parseTemplate(true);\n    if (typeArguments) node.typeParameters = typeArguments;\n\n    if (state.optionalChainMember) {\n      this.raise(startPos, Errors.OptionalChainingNoTemplate);\n    }\n\n    return this.finishNode(node, \"TaggedTemplateExpression\");\n  }\n\n  atPossibleAsyncArrow(base) {\n    return base.type === \"Identifier\" && base.name === \"async\" && this.state.lastTokEnd === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;\n  }\n\n  finishCallExpression(node, optional) {\n    if (node.callee.type === \"Import\") {\n      if (node.arguments.length !== 1) {\n        this.raise(node.start, Errors.ImportCallArity);\n      } else {\n        const importArg = node.arguments[0];\n\n        if (importArg && importArg.type === \"SpreadElement\") {\n          this.raise(importArg.start, Errors.ImportCallSpreadArgument);\n        }\n      }\n    }\n\n    return this.finishNode(node, optional ? \"OptionalCallExpression\" : \"CallExpression\");\n  }\n\n  parseCallExpressionArguments(close, possibleAsyncArrow, dynamicImport, allowPlaceholder, nodeForExtra) {\n    const elts = [];\n    let innerParenStart;\n    let first = true;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = false;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (dynamicImport) {\n            this.raise(this.state.lastTokStart, Errors.ImportCallArgumentTrailingComma);\n          }\n\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      if (this.match(types.parenL) && !innerParenStart) {\n        innerParenStart = this.state.start;\n      }\n\n      elts.push(this.parseExprListItem(false, possibleAsyncArrow ? new ExpressionErrors() : undefined, possibleAsyncArrow ? {\n        start: 0\n      } : undefined, allowPlaceholder));\n    }\n\n    if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {\n      this.unexpected();\n    }\n\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return elts;\n  }\n\n  shouldParseAsyncArrow() {\n    return this.match(types.arrow) && !this.canInsertSemicolon();\n  }\n\n  parseAsyncArrowFromCallExpression(node, call) {\n    var _call$extra;\n\n    this.expect(types.arrow);\n    this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingComma);\n    return node;\n  }\n\n  parseNoCallExpr() {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  }\n\n  parseExprAtom(refExpressionErrors) {\n    if (this.state.type === types.slash) this.readRegexp();\n    const canBeArrow = this.state.potentialArrowAt === this.state.start;\n    let node;\n\n    switch (this.state.type) {\n      case types._super:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.parenL) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {\n          this.raise(node.start, Errors.SuperNotAllowed);\n        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {\n          this.raise(node.start, Errors.UnexpectedSuper);\n        }\n\n        if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {\n          this.raise(node.start, Errors.UnsupportedSuper);\n        }\n\n        return this.finishNode(node, \"Super\");\n\n      case types._import:\n        node = this.startNode();\n        this.next();\n\n        if (this.match(types.dot)) {\n          return this.parseImportMetaProperty(node);\n        }\n\n        if (!this.match(types.parenL)) {\n          this.raise(this.state.lastTokStart, Errors.UnsupportedImport);\n        }\n\n        return this.finishNode(node, \"Import\");\n\n      case types._this:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"ThisExpression\");\n\n      case types.name:\n        {\n          node = this.startNode();\n          const containsEsc = this.state.containsEsc;\n          const id = this.parseIdentifier();\n\n          if (!containsEsc && id.name === \"async\" && this.match(types._function) && !this.canInsertSemicolon()) {\n            const last = this.state.context.length - 1;\n\n            if (this.state.context[last] !== types$1.functionStatement) {\n              throw new Error(\"Internal error\");\n            }\n\n            this.state.context[last] = types$1.functionExpression;\n            this.next();\n            return this.parseFunction(node, undefined, true);\n          } else if (canBeArrow && !containsEsc && id.name === \"async\" && this.match(types.name) && !this.canInsertSemicolon()) {\n            const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n            const oldMaybeInAsyncArrowHead = this.state.maybeInAsyncArrowHead;\n            const oldYieldPos = this.state.yieldPos;\n            const oldAwaitPos = this.state.awaitPos;\n            this.state.maybeInArrowParameters = true;\n            this.state.maybeInAsyncArrowHead = true;\n            this.state.yieldPos = -1;\n            this.state.awaitPos = -1;\n            const params = [this.parseIdentifier()];\n            this.expect(types.arrow);\n            this.checkYieldAwaitInDefaultParams();\n            this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n            this.state.maybeInAsyncArrowHead = oldMaybeInAsyncArrowHead;\n            this.state.yieldPos = oldYieldPos;\n            this.state.awaitPos = oldAwaitPos;\n            this.parseArrowExpression(node, params, true);\n            return node;\n          }\n\n          if (canBeArrow && this.match(types.arrow) && !this.canInsertSemicolon()) {\n            this.next();\n            this.parseArrowExpression(node, [id], false);\n            return node;\n          }\n\n          return id;\n        }\n\n      case types._do:\n        {\n          this.expectPlugin(\"doExpressions\");\n          const node = this.startNode();\n          this.next();\n          const oldLabels = this.state.labels;\n          this.state.labels = [];\n          node.body = this.parseBlock();\n          this.state.labels = oldLabels;\n          return this.finishNode(node, \"DoExpression\");\n        }\n\n      case types.regexp:\n        {\n          const value = this.state.value;\n          node = this.parseLiteral(value.value, \"RegExpLiteral\");\n          node.pattern = value.pattern;\n          node.flags = value.flags;\n          return node;\n        }\n\n      case types.num:\n        return this.parseLiteral(this.state.value, \"NumericLiteral\");\n\n      case types.bigint:\n        return this.parseLiteral(this.state.value, \"BigIntLiteral\");\n\n      case types.string:\n        return this.parseLiteral(this.state.value, \"StringLiteral\");\n\n      case types._null:\n        node = this.startNode();\n        this.next();\n        return this.finishNode(node, \"NullLiteral\");\n\n      case types._true:\n      case types._false:\n        return this.parseBooleanLiteral();\n\n      case types.parenL:\n        return this.parseParenAndDistinguishExpression(canBeArrow);\n\n      case types.bracketBarL:\n      case types.bracketHashL:\n        {\n          this.expectPlugin(\"recordAndTuple\");\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          const close = this.state.type === types.bracketBarL ? types.bracketBarR : types.bracketR;\n          this.state.inFSharpPipelineDirectBody = false;\n          node = this.startNode();\n          this.next();\n          node.elements = this.parseExprList(close, true, refExpressionErrors, node);\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return this.finishNode(node, \"TupleExpression\");\n        }\n\n      case types.bracketL:\n        {\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          this.state.inFSharpPipelineDirectBody = false;\n          node = this.startNode();\n          this.next();\n          node.elements = this.parseExprList(types.bracketR, true, refExpressionErrors, node);\n\n          if (!this.state.maybeInArrowParameters) {\n            this.toReferencedList(node.elements);\n          }\n\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return this.finishNode(node, \"ArrayExpression\");\n        }\n\n      case types.braceBarL:\n      case types.braceHashL:\n        {\n          this.expectPlugin(\"recordAndTuple\");\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          const close = this.state.type === types.braceBarL ? types.braceBarR : types.braceR;\n          this.state.inFSharpPipelineDirectBody = false;\n          const ret = this.parseObj(close, false, true, refExpressionErrors);\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return ret;\n        }\n\n      case types.braceL:\n        {\n          const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n          this.state.inFSharpPipelineDirectBody = false;\n          const ret = this.parseObj(types.braceR, false, false, refExpressionErrors);\n          this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n          return ret;\n        }\n\n      case types._function:\n        return this.parseFunctionExpression();\n\n      case types.at:\n        this.parseDecorators();\n\n      case types._class:\n        node = this.startNode();\n        this.takeDecorators(node);\n        return this.parseClass(node, false);\n\n      case types._new:\n        return this.parseNew();\n\n      case types.backQuote:\n        return this.parseTemplate(false);\n\n      case types.doubleColon:\n        {\n          node = this.startNode();\n          this.next();\n          node.object = null;\n          const callee = node.callee = this.parseNoCallExpr();\n\n          if (callee.type === \"MemberExpression\") {\n            return this.finishNode(node, \"BindExpression\");\n          } else {\n            throw this.raise(callee.start, Errors.UnsupportedBind);\n          }\n        }\n\n      case types.hash:\n        {\n          if (this.state.inPipeline) {\n            node = this.startNode();\n\n            if (this.getPluginOption(\"pipelineOperator\", \"proposal\") !== \"smart\") {\n              this.raise(node.start, Errors.PrimaryTopicRequiresSmartPipeline);\n            }\n\n            this.next();\n\n            if (!this.primaryTopicReferenceIsAllowedInCurrentTopicContext()) {\n              this.raise(node.start, Errors.PrimaryTopicNotAllowed);\n            }\n\n            this.registerTopicReference();\n            return this.finishNode(node, \"PipelinePrimaryTopicReference\");\n          }\n        }\n\n      default:\n        throw this.unexpected();\n    }\n  }\n\n  parseBooleanLiteral() {\n    const node = this.startNode();\n    node.value = this.match(types._true);\n    this.next();\n    return this.finishNode(node, \"BooleanLiteral\");\n  }\n\n  parseMaybePrivateName(isPrivateNameAllowed) {\n    const isPrivate = this.match(types.hash);\n\n    if (isPrivate) {\n      this.expectOnePlugin([\"classPrivateProperties\", \"classPrivateMethods\"]);\n\n      if (!isPrivateNameAllowed) {\n        this.raise(this.state.pos, Errors.UnexpectedPrivateField);\n      }\n\n      const node = this.startNode();\n      this.next();\n      this.assertNoSpace(\"Unexpected space between # and identifier\");\n      node.id = this.parseIdentifier(true);\n      return this.finishNode(node, \"PrivateName\");\n    } else {\n      return this.parseIdentifier(true);\n    }\n  }\n\n  parseFunctionExpression() {\n    const node = this.startNode();\n    let meta = this.startNode();\n    this.next();\n    meta = this.createIdentifier(meta, \"function\");\n\n    if (this.prodParam.hasYield && this.eat(types.dot)) {\n      return this.parseMetaProperty(node, meta, \"sent\");\n    }\n\n    return this.parseFunction(node);\n  }\n\n  parseMetaProperty(node, meta, propertyName) {\n    node.meta = meta;\n\n    if (meta.name === \"function\" && propertyName === \"sent\") {\n      if (this.isContextual(propertyName)) {\n        this.expectPlugin(\"functionSent\");\n      } else if (!this.hasPlugin(\"functionSent\")) {\n        this.unexpected();\n      }\n    }\n\n    const containsEsc = this.state.containsEsc;\n    node.property = this.parseIdentifier(true);\n\n    if (node.property.name !== propertyName || containsEsc) {\n      this.raise(node.property.start, Errors.UnsupportedMetaProperty, meta.name, propertyName);\n    }\n\n    return this.finishNode(node, \"MetaProperty\");\n  }\n\n  parseImportMetaProperty(node) {\n    const id = this.createIdentifier(this.startNodeAtNode(node), \"import\");\n    this.expect(types.dot);\n\n    if (this.isContextual(\"meta\")) {\n      this.expectPlugin(\"importMeta\");\n\n      if (!this.inModule) {\n        this.raiseWithData(id.start, {\n          code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n        }, Errors.ImportMetaOutsideModule);\n      }\n\n      this.sawUnambiguousESM = true;\n    } else if (!this.hasPlugin(\"importMeta\")) {\n      this.raise(id.start, Errors.ImportCallArityLtOne);\n    }\n\n    return this.parseMetaProperty(node, id, \"meta\");\n  }\n\n  parseLiteral(value, type, startPos, startLoc) {\n    startPos = startPos || this.state.start;\n    startLoc = startLoc || this.state.startLoc;\n    const node = this.startNodeAt(startPos, startLoc);\n    this.addExtra(node, \"rawValue\", value);\n    this.addExtra(node, \"raw\", this.input.slice(startPos, this.state.end));\n    node.value = value;\n    this.next();\n    return this.finishNode(node, type);\n  }\n\n  parseParenAndDistinguishExpression(canBeArrow) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    let val;\n    this.expect(types.parenL);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.maybeInArrowParameters = true;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.state.inFSharpPipelineDirectBody = false;\n    const innerStartPos = this.state.start;\n    const innerStartLoc = this.state.startLoc;\n    const exprList = [];\n    const refExpressionErrors = new ExpressionErrors();\n    const refNeedsArrowPos = {\n      start: 0\n    };\n    let first = true;\n    let spreadStart;\n    let optionalCommaStart;\n\n    while (!this.match(types.parenR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma, refNeedsArrowPos.start || null);\n\n        if (this.match(types.parenR)) {\n          optionalCommaStart = this.state.start;\n          break;\n        }\n      }\n\n      if (this.match(types.ellipsis)) {\n        const spreadNodeStartPos = this.state.start;\n        const spreadNodeStartLoc = this.state.startLoc;\n        spreadStart = this.state.start;\n        exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartPos, spreadNodeStartLoc));\n        this.checkCommaAfterRest(41);\n        break;\n      } else {\n        exprList.push(this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos));\n      }\n    }\n\n    const innerEndPos = this.state.start;\n    const innerEndLoc = this.state.startLoc;\n    this.expect(types.parenR);\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    let arrowNode = this.startNodeAt(startPos, startLoc);\n\n    if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {\n      if (!this.isAwaitAllowed() && !this.state.maybeInAsyncArrowHead) {\n        this.state.awaitPos = oldAwaitPos;\n      }\n\n      this.checkYieldAwaitInDefaultParams();\n      this.state.yieldPos = oldYieldPos;\n      this.state.awaitPos = oldAwaitPos;\n\n      for (let _i = 0; _i < exprList.length; _i++) {\n        const param = exprList[_i];\n\n        if (param.extra && param.extra.parenthesized) {\n          this.unexpected(param.extra.parenStart);\n        }\n      }\n\n      this.parseArrowExpression(arrowNode, exprList, false);\n      return arrowNode;\n    }\n\n    if (oldYieldPos !== -1) this.state.yieldPos = oldYieldPos;\n    if (oldAwaitPos !== -1) this.state.awaitPos = oldAwaitPos;\n\n    if (!exprList.length) {\n      this.unexpected(this.state.lastTokStart);\n    }\n\n    if (optionalCommaStart) this.unexpected(optionalCommaStart);\n    if (spreadStart) this.unexpected(spreadStart);\n    this.checkExpressionErrors(refExpressionErrors, true);\n    if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);\n    this.toReferencedListDeep(exprList, true);\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n\n    if (!this.options.createParenthesizedExpressions) {\n      this.addExtra(val, \"parenthesized\", true);\n      this.addExtra(val, \"parenStart\", startPos);\n      return val;\n    }\n\n    const parenExpression = this.startNodeAt(startPos, startLoc);\n    parenExpression.expression = val;\n    this.finishNode(parenExpression, \"ParenthesizedExpression\");\n    return parenExpression;\n  }\n\n  shouldParseArrow() {\n    return !this.canInsertSemicolon();\n  }\n\n  parseArrow(node) {\n    if (this.eat(types.arrow)) {\n      return node;\n    }\n  }\n\n  parseParenItem(node, startPos, startLoc) {\n    return node;\n  }\n\n  parseNew() {\n    const node = this.startNode();\n    let meta = this.startNode();\n    this.next();\n    meta = this.createIdentifier(meta, \"new\");\n\n    if (this.eat(types.dot)) {\n      const metaProp = this.parseMetaProperty(node, meta, \"target\");\n\n      if (!this.scope.inNonArrowFunction && !this.scope.inClass) {\n        let error = Errors.UnexpectedNewTarget;\n\n        if (this.hasPlugin(\"classProperties\")) {\n          error += \" or class properties\";\n        }\n\n        this.raise(metaProp.start, error);\n      }\n\n      return metaProp;\n    }\n\n    node.callee = this.parseNoCallExpr();\n\n    if (node.callee.type === \"Import\") {\n      this.raise(node.callee.start, Errors.ImportCallNotNewExpression);\n    } else if (node.callee.type === \"OptionalMemberExpression\" || node.callee.type === \"OptionalCallExpression\") {\n      this.raise(this.state.lastTokEnd, Errors.OptionalChainingNoNew);\n    } else if (this.eat(types.questionDot)) {\n      this.raise(this.state.start, Errors.OptionalChainingNoNew);\n    }\n\n    this.parseNewArguments(node);\n    return this.finishNode(node, \"NewExpression\");\n  }\n\n  parseNewArguments(node) {\n    if (this.eat(types.parenL)) {\n      const args = this.parseExprList(types.parenR);\n      this.toReferencedList(args);\n      node.arguments = args;\n    } else {\n      node.arguments = [];\n    }\n  }\n\n  parseTemplateElement(isTagged) {\n    const elem = this.startNode();\n\n    if (this.state.value === null) {\n      if (!isTagged) {\n        this.raise(this.state.start + 1, Errors.InvalidEscapeSequenceTemplate);\n      }\n    }\n\n    elem.value = {\n      raw: this.input.slice(this.state.start, this.state.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.state.value\n    };\n    this.next();\n    elem.tail = this.match(types.backQuote);\n    return this.finishNode(elem, \"TemplateElement\");\n  }\n\n  parseTemplate(isTagged) {\n    const node = this.startNode();\n    this.next();\n    node.expressions = [];\n    let curElt = this.parseTemplateElement(isTagged);\n    node.quasis = [curElt];\n\n    while (!curElt.tail) {\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement(isTagged));\n    }\n\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\");\n  }\n\n  parseObj(close, isPattern, isRecord, refExpressionErrors) {\n    const propHash = Object.create(null);\n    let first = true;\n    const node = this.startNode();\n    node.properties = [];\n    this.next();\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          this.addExtra(node, \"trailingComma\", this.state.lastTokStart);\n          this.next();\n          break;\n        }\n      }\n\n      const prop = this.parseObjectMember(isPattern, refExpressionErrors);\n\n      if (!isPattern) {\n        this.checkDuplicatedProto(prop, propHash, refExpressionErrors);\n      }\n\n      if (prop.shorthand) {\n        this.addExtra(prop, \"shorthand\", true);\n      }\n\n      node.properties.push(prop);\n    }\n\n    let type = \"ObjectExpression\";\n\n    if (isPattern) {\n      type = \"ObjectPattern\";\n    } else if (isRecord) {\n      type = \"RecordExpression\";\n    }\n\n    return this.finishNode(node, type);\n  }\n\n  isAsyncProp(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.match(types.name) || this.match(types.num) || this.match(types.string) || this.match(types.bracketL) || this.state.type.keyword || this.match(types.star)) && !this.hasPrecedingLineBreak();\n  }\n\n  parseObjectMember(isPattern, refExpressionErrors) {\n    let decorators = [];\n\n    if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\")) {\n        this.raise(this.state.start, Errors.UnsupportedPropertyDecorator);\n      }\n\n      while (this.match(types.at)) {\n        decorators.push(this.parseDecorator());\n      }\n    }\n\n    const prop = this.startNode();\n    let isGenerator = false;\n    let isAsync = false;\n    let startPos;\n    let startLoc;\n\n    if (this.match(types.ellipsis)) {\n      if (decorators.length) this.unexpected();\n\n      if (isPattern) {\n        this.next();\n        prop.argument = this.parseIdentifier();\n        this.checkCommaAfterRest(125);\n        return this.finishNode(prop, \"RestElement\");\n      }\n\n      return this.parseSpread();\n    }\n\n    if (decorators.length) {\n      prop.decorators = decorators;\n      decorators = [];\n    }\n\n    prop.method = false;\n\n    if (isPattern || refExpressionErrors) {\n      startPos = this.state.start;\n      startLoc = this.state.startLoc;\n    }\n\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n\n    const containsEsc = this.state.containsEsc;\n    this.parsePropertyName(prop, false);\n\n    if (!isPattern && !containsEsc && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.eat(types.star);\n      this.parsePropertyName(prop, false);\n    } else {\n      isAsync = false;\n    }\n\n    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc);\n    return prop;\n  }\n\n  isGetterOrSetterMethod(prop, isPattern) {\n    return !isPattern && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && (this.match(types.string) || this.match(types.num) || this.match(types.bracketL) || this.match(types.name) || !!this.state.type.keyword);\n  }\n\n  getGetterSetterExpectedParamCount(method) {\n    return method.kind === \"get\" ? 0 : 1;\n  }\n\n  checkGetterSetterParams(method) {\n    const paramCount = this.getGetterSetterExpectedParamCount(method);\n    const start = method.start;\n\n    if (method.params.length !== paramCount) {\n      if (method.kind === \"get\") {\n        this.raise(start, Errors.BadGetterArity);\n      } else {\n        this.raise(start, Errors.BadSetterArity);\n      }\n    }\n\n    if (method.kind === \"set\" && method.params[method.params.length - 1].type === \"RestElement\") {\n      this.raise(start, Errors.BadSetterRestParameter);\n    }\n  }\n\n  parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) {\n    if (isAsync || isGenerator || this.match(types.parenL)) {\n      if (isPattern) this.unexpected();\n      prop.kind = \"method\";\n      prop.method = true;\n      return this.parseMethod(prop, isGenerator, isAsync, false, false, \"ObjectMethod\");\n    }\n\n    if (!containsEsc && this.isGetterOrSetterMethod(prop, isPattern)) {\n      if (isGenerator || isAsync) this.unexpected();\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop, false);\n      this.parseMethod(prop, false, false, false, false, \"ObjectMethod\");\n      this.checkGetterSetterParams(prop);\n      return prop;\n    }\n  }\n\n  parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors) {\n    prop.shorthand = false;\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refExpressionErrors);\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n\n    if (!prop.computed && prop.key.type === \"Identifier\") {\n      this.checkReservedWord(prop.key.name, prop.key.start, true, true);\n\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else if (this.match(types.eq) && refExpressionErrors) {\n        if (refExpressionErrors.shorthandAssign === -1) {\n          refExpressionErrors.shorthandAssign = this.state.start;\n        }\n\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());\n      } else {\n        prop.value = prop.key.__clone();\n      }\n\n      prop.shorthand = true;\n      return this.finishNode(prop, \"ObjectProperty\");\n    }\n  }\n\n  parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refExpressionErrors, containsEsc) {\n    const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, containsEsc) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refExpressionErrors);\n    if (!node) this.unexpected();\n    return node;\n  }\n\n  parsePropertyName(prop, isPrivateNameAllowed) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n    } else {\n      const oldInPropertyName = this.state.inPropertyName;\n      this.state.inPropertyName = true;\n      prop.key = this.match(types.num) || this.match(types.string) || this.match(types.bigint) ? this.parseExprAtom() : this.parseMaybePrivateName(isPrivateNameAllowed);\n\n      if (prop.key.type !== \"PrivateName\") {\n        prop.computed = false;\n      }\n\n      this.state.inPropertyName = oldInPropertyName;\n    }\n\n    return prop.key;\n  }\n\n  initFunction(node, isAsync) {\n    node.id = null;\n    node.generator = false;\n    node.async = !!isAsync;\n  }\n\n  parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.initFunction(node, isAsync);\n    node.generator = !!isGenerator;\n    const allowModifiers = isConstructor;\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_SUPER | (inClassScope ? SCOPE_CLASS : 0) | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n    this.parseFunctionParams(node, allowModifiers);\n    this.parseFunctionBodyAndFinish(node, type, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return node;\n  }\n\n  parseArrowExpression(node, params, isAsync, trailingCommaPos) {\n    this.scope.enter(SCOPE_FUNCTION | SCOPE_ARROW);\n    this.prodParam.enter(functionFlags(isAsync, false));\n    this.initFunction(node, isAsync);\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n\n    if (params) {\n      this.state.maybeInArrowParameters = true;\n      this.setArrowFunctionParameters(node, params, trailingCommaPos);\n    }\n\n    this.state.maybeInArrowParameters = false;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.parseFunctionBody(node, true);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\");\n  }\n\n  setArrowFunctionParameters(node, params, trailingCommaPos) {\n    node.params = this.toAssignableList(params, trailingCommaPos);\n  }\n\n  parseFunctionBodyAndFinish(node, type, isMethod = false) {\n    this.parseFunctionBody(node, false, isMethod);\n    this.finishNode(node, type);\n  }\n\n  parseFunctionBody(node, allowExpression, isMethod = false) {\n    const isExpression = allowExpression && !this.match(types.braceL);\n    const oldInParameters = this.state.inParameters;\n    this.state.inParameters = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      this.checkParams(node, false, allowExpression, false);\n    } else {\n      const oldStrict = this.state.strict;\n      const oldLabels = this.state.labels;\n      this.state.labels = [];\n      this.prodParam.enter(this.prodParam.currentFlags() | PARAM_RETURN);\n      node.body = this.parseBlock(true, false, hasStrictModeDirective => {\n        const nonSimple = !this.isSimpleParamList(node.params);\n\n        if (hasStrictModeDirective && nonSimple) {\n          const errorPos = (node.kind === \"method\" || node.kind === \"constructor\") && !!node.key ? node.key.end : node.start;\n          this.raise(errorPos, Errors.IllegalLanguageModeDirective);\n        }\n\n        const strictModeChanged = !oldStrict && this.state.strict;\n        this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);\n\n        if (this.state.strict && node.id) {\n          this.checkLVal(node.id, BIND_OUTSIDE, undefined, \"function name\", undefined, strictModeChanged);\n        }\n      });\n      this.prodParam.exit();\n      this.state.labels = oldLabels;\n    }\n\n    this.state.inParameters = oldInParameters;\n  }\n\n  isSimpleParamList(params) {\n    for (let i = 0, len = params.length; i < len; i++) {\n      if (params[i].type !== \"Identifier\") return false;\n    }\n\n    return true;\n  }\n\n  checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {\n    const nameHash = Object.create(null);\n\n    for (let i = 0; i < node.params.length; i++) {\n      this.checkLVal(node.params[i], BIND_VAR, allowDuplicates ? null : nameHash, \"function parameter list\", undefined, strictModeChanged);\n    }\n  }\n\n  parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {\n    const elts = [];\n    let first = true;\n\n    while (!this.eat(close)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n\n        if (this.match(close)) {\n          if (nodeForExtra) {\n            this.addExtra(nodeForExtra, \"trailingComma\", this.state.lastTokStart);\n          }\n\n          this.next();\n          break;\n        }\n      }\n\n      elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));\n    }\n\n    return elts;\n  }\n\n  parseExprListItem(allowEmpty, refExpressionErrors, refNeedsArrowPos, allowPlaceholder) {\n    let elt;\n\n    if (allowEmpty && this.match(types.comma)) {\n      elt = null;\n    } else if (this.match(types.ellipsis)) {\n      const spreadNodeStartPos = this.state.start;\n      const spreadNodeStartLoc = this.state.startLoc;\n      elt = this.parseParenItem(this.parseSpread(refExpressionErrors, refNeedsArrowPos), spreadNodeStartPos, spreadNodeStartLoc);\n    } else if (this.match(types.question)) {\n      this.expectPlugin(\"partialApplication\");\n\n      if (!allowPlaceholder) {\n        this.raise(this.state.start, Errors.UnexpectedArgumentPlaceholder);\n      }\n\n      const node = this.startNode();\n      this.next();\n      elt = this.finishNode(node, \"ArgumentPlaceholder\");\n    } else {\n      elt = this.parseMaybeAssign(false, refExpressionErrors, this.parseParenItem, refNeedsArrowPos);\n    }\n\n    return elt;\n  }\n\n  parseIdentifier(liberal) {\n    const node = this.startNode();\n    const name = this.parseIdentifierName(node.start, liberal);\n    return this.createIdentifier(node, name);\n  }\n\n  createIdentifier(node, name) {\n    node.name = name;\n    node.loc.identifierName = name;\n    return this.finishNode(node, \"Identifier\");\n  }\n\n  parseIdentifierName(pos, liberal) {\n    let name;\n\n    if (this.match(types.name)) {\n      name = this.state.value;\n    } else if (this.state.type.keyword) {\n      name = this.state.type.keyword;\n      const context = this.state.context;\n\n      if ((name === \"class\" || name === \"function\") && context[context.length - 1].token === \"function\") {\n        context.pop();\n      }\n    } else {\n      throw this.unexpected();\n    }\n\n    if (liberal) {\n      this.state.type = types.name;\n    } else {\n      this.checkReservedWord(name, this.state.start, !!this.state.type.keyword, false);\n    }\n\n    this.next();\n    return name;\n  }\n\n  checkReservedWord(word, startLoc, checkKeywords, isBinding) {\n    if (this.prodParam.hasYield && word === \"yield\") {\n      this.raise(startLoc, Errors.YieldBindingIdentifier);\n      return;\n    }\n\n    if (word === \"await\") {\n      if (this.prodParam.hasAwait) {\n        this.raise(startLoc, Errors.AwaitBindingIdentifier);\n        return;\n      }\n\n      if (this.state.awaitPos === -1 && (this.state.maybeInAsyncArrowHead || this.isAwaitAllowed())) {\n        this.state.awaitPos = this.state.start;\n      }\n    }\n\n    if (this.scope.inClass && !this.scope.inNonArrowFunction && word === \"arguments\") {\n      this.raise(startLoc, Errors.ArgumentsDisallowedInInitializer);\n      return;\n    }\n\n    if (checkKeywords && isKeyword(word)) {\n      this.raise(startLoc, Errors.UnexpectedKeyword, word);\n      return;\n    }\n\n    const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;\n\n    if (reservedTest(word, this.inModule)) {\n      if (!this.prodParam.hasAwait && word === \"await\") {\n        this.raise(startLoc, Errors.AwaitNotInAsyncFunction);\n      } else {\n        this.raise(startLoc, Errors.UnexpectedReservedWord, word);\n      }\n    }\n  }\n\n  isAwaitAllowed() {\n    if (this.scope.inFunction) return this.prodParam.hasAwait;\n    if (this.options.allowAwaitOutsideFunction) return true;\n\n    if (this.hasPlugin(\"topLevelAwait\")) {\n      return this.inModule && this.prodParam.hasAwait;\n    }\n\n    return false;\n  }\n\n  parseAwait() {\n    const node = this.startNode();\n    this.next();\n\n    if (this.state.inParameters) {\n      this.raise(node.start, Errors.AwaitExpressionFormalParameter);\n    } else if (this.state.awaitPos === -1) {\n      this.state.awaitPos = node.start;\n    }\n\n    if (this.eat(types.star)) {\n      this.raise(node.start, Errors.ObsoleteAwaitStar);\n    }\n\n    if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {\n      if (this.hasPrecedingLineBreak() || this.match(types.plusMin) || this.match(types.parenL) || this.match(types.bracketL) || this.match(types.backQuote) || this.match(types.regexp) || this.match(types.slash) || this.hasPlugin(\"v8intrinsic\") && this.match(types.modulo)) {\n        this.ambiguousScriptDifferentAst = true;\n      } else {\n        this.sawUnambiguousESM = true;\n      }\n    }\n\n    if (!this.state.soloAwait) {\n      node.argument = this.parseMaybeUnary();\n    }\n\n    return this.finishNode(node, \"AwaitExpression\");\n  }\n\n  parseYield(noIn) {\n    const node = this.startNode();\n\n    if (this.state.inParameters) {\n      this.raise(node.start, Errors.YieldInParameter);\n    } else if (this.state.yieldPos === -1) {\n      this.state.yieldPos = node.start;\n    }\n\n    this.next();\n\n    if (this.match(types.semi) || !this.match(types.star) && !this.state.type.startsExpr || this.hasPrecedingLineBreak()) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign(noIn);\n    }\n\n    return this.finishNode(node, \"YieldExpression\");\n  }\n\n  checkPipelineAtInfixOperator(left, leftStartPos) {\n    if (this.getPluginOption(\"pipelineOperator\", \"proposal\") === \"smart\") {\n      if (left.type === \"SequenceExpression\") {\n        this.raise(leftStartPos, Errors.PipelineHeadSequenceExpression);\n      }\n    }\n  }\n\n  parseSmartPipelineBody(childExpression, startPos, startLoc) {\n    const pipelineStyle = this.checkSmartPipelineBodyStyle(childExpression);\n    this.checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos);\n    return this.parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc);\n  }\n\n  checkSmartPipelineBodyEarlyErrors(childExpression, pipelineStyle, startPos) {\n    if (this.match(types.arrow)) {\n      throw this.raise(this.state.start, Errors.PipelineBodyNoArrow);\n    } else if (pipelineStyle === \"PipelineTopicExpression\" && childExpression.type === \"SequenceExpression\") {\n      this.raise(startPos, Errors.PipelineBodySequenceExpression);\n    }\n  }\n\n  parseSmartPipelineBodyInStyle(childExpression, pipelineStyle, startPos, startLoc) {\n    const bodyNode = this.startNodeAt(startPos, startLoc);\n\n    switch (pipelineStyle) {\n      case \"PipelineBareFunction\":\n        bodyNode.callee = childExpression;\n        break;\n\n      case \"PipelineBareConstructor\":\n        bodyNode.callee = childExpression.callee;\n        break;\n\n      case \"PipelineBareAwaitedFunction\":\n        bodyNode.callee = childExpression.argument;\n        break;\n\n      case \"PipelineTopicExpression\":\n        if (!this.topicReferenceWasUsedInCurrentTopicContext()) {\n          this.raise(startPos, Errors.PipelineTopicUnused);\n        }\n\n        bodyNode.expression = childExpression;\n        break;\n\n      default:\n        throw new Error(`Internal @babel/parser error: Unknown pipeline style (${pipelineStyle})`);\n    }\n\n    return this.finishNode(bodyNode, pipelineStyle);\n  }\n\n  checkSmartPipelineBodyStyle(expression) {\n    switch (expression.type) {\n      default:\n        return this.isSimpleReference(expression) ? \"PipelineBareFunction\" : \"PipelineTopicExpression\";\n    }\n  }\n\n  isSimpleReference(expression) {\n    switch (expression.type) {\n      case \"MemberExpression\":\n        return !expression.computed && this.isSimpleReference(expression.object);\n\n      case \"Identifier\":\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  withTopicPermittingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 1,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withTopicForbiddingContext(callback) {\n    const outerContextTopicState = this.state.topicContext;\n    this.state.topicContext = {\n      maxNumOfResolvableTopics: 0,\n      maxTopicIndex: null\n    };\n\n    try {\n      return callback();\n    } finally {\n      this.state.topicContext = outerContextTopicState;\n    }\n  }\n\n  withSoloAwaitPermittingContext(callback) {\n    const outerContextSoloAwaitState = this.state.soloAwait;\n    this.state.soloAwait = true;\n\n    try {\n      return callback();\n    } finally {\n      this.state.soloAwait = outerContextSoloAwaitState;\n    }\n  }\n\n  registerTopicReference() {\n    this.state.topicContext.maxTopicIndex = 0;\n  }\n\n  primaryTopicReferenceIsAllowedInCurrentTopicContext() {\n    return this.state.topicContext.maxNumOfResolvableTopics >= 1;\n  }\n\n  topicReferenceWasUsedInCurrentTopicContext() {\n    return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;\n  }\n\n  parseFSharpPipelineBody(prec, noIn) {\n    const startPos = this.state.start;\n    const startLoc = this.state.startLoc;\n    this.state.potentialArrowAt = this.state.start;\n    const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;\n    this.state.inFSharpPipelineDirectBody = true;\n    const ret = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn);\n    this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;\n    return ret;\n  }\n\n}\n\nconst loopLabel = {\n  kind: \"loop\"\n},\n      switchLabel = {\n  kind: \"switch\"\n};\nconst FUNC_NO_FLAGS = 0b000,\n      FUNC_STATEMENT = 0b001,\n      FUNC_HANGING_STATEMENT = 0b010,\n      FUNC_NULLABLE_ID = 0b100;\nclass StatementParser extends ExpressionParser {\n  parseTopLevel(file, program) {\n    program.sourceType = this.options.sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, types.eof);\n\n    if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {\n      for (let _i = 0, _Array$from = Array.from(this.scope.undefinedExports); _i < _Array$from.length; _i++) {\n        const [name] = _Array$from[_i];\n        const pos = this.scope.undefinedExports.get(name);\n        this.raise(pos, Errors.ModuleExportUndefined, name);\n      }\n    }\n\n    file.program = this.finishNode(program, \"Program\");\n    file.comments = this.state.comments;\n    if (this.options.tokens) file.tokens = this.tokens;\n    return this.finishNode(file, \"File\");\n  }\n\n  stmtToDirective(stmt) {\n    const expr = stmt.expression;\n    const directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);\n    const directive = this.startNodeAt(stmt.start, stmt.loc.start);\n    const raw = this.input.slice(expr.start, expr.end);\n    const val = directiveLiteral.value = raw.slice(1, -1);\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    directive.value = this.finishNodeAt(directiveLiteral, \"DirectiveLiteral\", expr.end, expr.loc.end);\n    return this.finishNodeAt(directive, \"Directive\", stmt.end, stmt.loc.end);\n  }\n\n  parseInterpreterDirective() {\n    if (!this.match(types.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(context) {\n    if (!this.isContextual(\"let\")) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const nextCh = this.input.charCodeAt(next);\n    if (nextCh === 91) return true;\n    if (context) return false;\n    if (nextCh === 123) return true;\n\n    if (isIdentifierStart(nextCh)) {\n      let pos = next + 1;\n\n      while (isIdentifierChar(this.input.charCodeAt(pos))) {\n        ++pos;\n      }\n\n      const ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) return true;\n    }\n\n    return false;\n  }\n\n  parseStatement(context, topLevel) {\n    if (this.match(types.at)) {\n      this.parseDecorators(true);\n    }\n\n    return this.parseStatementContent(context, topLevel);\n  }\n\n  parseStatementContent(context, topLevel) {\n    let starttype = this.state.type;\n    const node = this.startNode();\n    let kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    switch (starttype) {\n      case types._break:\n      case types._continue:\n        return this.parseBreakContinueStatement(node, starttype.keyword);\n\n      case types._debugger:\n        return this.parseDebuggerStatement(node);\n\n      case types._do:\n        return this.parseDoStatement(node);\n\n      case types._for:\n        return this.parseForStatement(node);\n\n      case types._function:\n        if (this.lookaheadCharCode() === 46) break;\n\n        if (context) {\n          if (this.state.strict) {\n            this.raise(this.state.start, Errors.StrictFunction);\n          } else if (context !== \"if\" && context !== \"label\") {\n            this.raise(this.state.start, Errors.SloppyFunction);\n          }\n        }\n\n        return this.parseFunctionStatement(node, false, !context);\n\n      case types._class:\n        if (context) this.unexpected();\n        return this.parseClass(node, true);\n\n      case types._if:\n        return this.parseIfStatement(node);\n\n      case types._return:\n        return this.parseReturnStatement(node);\n\n      case types._switch:\n        return this.parseSwitchStatement(node);\n\n      case types._throw:\n        return this.parseThrowStatement(node);\n\n      case types._try:\n        return this.parseTryStatement(node);\n\n      case types._const:\n      case types._var:\n        kind = kind || this.state.value;\n\n        if (context && kind !== \"var\") {\n          this.raise(this.state.start, Errors.UnexpectedLexicalDeclaration);\n        }\n\n        return this.parseVarStatement(node, kind);\n\n      case types._while:\n        return this.parseWhileStatement(node);\n\n      case types._with:\n        return this.parseWithStatement(node);\n\n      case types.braceL:\n        return this.parseBlock();\n\n      case types.semi:\n        return this.parseEmptyStatement(node);\n\n      case types._export:\n      case types._import:\n        {\n          const nextTokenCharCode = this.lookaheadCharCode();\n\n          if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {\n            break;\n          }\n\n          if (!this.options.allowImportExportEverywhere && !topLevel) {\n            this.raise(this.state.start, Errors.UnexpectedImportExport);\n          }\n\n          this.next();\n          let result;\n\n          if (starttype === types._import) {\n            result = this.parseImport(node);\n\n            if (result.type === \"ImportDeclaration\" && (!result.importKind || result.importKind === \"value\")) {\n              this.sawUnambiguousESM = true;\n            }\n          } else {\n            result = this.parseExport(node);\n\n            if (result.type === \"ExportNamedDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportAllDeclaration\" && (!result.exportKind || result.exportKind === \"value\") || result.type === \"ExportDefaultDeclaration\") {\n              this.sawUnambiguousESM = true;\n            }\n          }\n\n          this.assertModuleNodeAllowed(node);\n          return result;\n        }\n\n      default:\n        {\n          if (this.isAsyncFunction()) {\n            if (context) {\n              this.raise(this.state.start, Errors.AsyncFunctionInSingleStatementContext);\n            }\n\n            this.next();\n            return this.parseFunctionStatement(node, true, !context);\n          }\n        }\n    }\n\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n      return this.parseLabeledStatement(node, maybeName, expr, context);\n    } else {\n      return this.parseExpressionStatement(node, expr);\n    }\n  }\n\n  assertModuleNodeAllowed(node) {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raiseWithData(node.start, {\n        code: \"BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED\"\n      }, Errors.ImportOutsideModule);\n    }\n  }\n\n  takeDecorators(node) {\n    const decorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (decorators.length) {\n      node.decorators = decorators;\n      this.resetStartLocationFromNode(node, decorators[0]);\n      this.state.decoratorStack[this.state.decoratorStack.length - 1] = [];\n    }\n  }\n\n  canHaveLeadingDecorator() {\n    return this.match(types._class);\n  }\n\n  parseDecorators(allowExport) {\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    while (this.match(types.at)) {\n      const decorator = this.parseDecorator();\n      currentContextDecorators.push(decorator);\n    }\n\n    if (this.match(types._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (this.hasPlugin(\"decorators\") && !this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, Errors.DecoratorExportClass);\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(this.state.start, Errors.UnexpectedLeadingDecorator);\n    }\n  }\n\n  parseDecorator() {\n    this.expectOnePlugin([\"decorators-legacy\", \"decorators\"]);\n    const node = this.startNode();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      this.state.decoratorStack.push([]);\n      const startPos = this.state.start;\n      const startLoc = this.state.startLoc;\n      let expr;\n\n      if (this.eat(types.parenL)) {\n        expr = this.parseExpression();\n        this.expect(types.parenR);\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(types.dot)) {\n          const node = this.startNodeAt(startPos, startLoc);\n          node.object = expr;\n          node.property = this.parseIdentifier(true);\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n      }\n\n      node.expression = this.parseMaybeDecoratorArguments(expr);\n      this.state.decoratorStack.pop();\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(expr) {\n    if (this.eat(types.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(types.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(node, keyword) {\n    const isBreak = keyword === \"break\";\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, keyword);\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n  }\n\n  verifyBreakContinue(node, keyword) {\n    const isBreak = keyword === \"break\";\n    let i;\n\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n\n    if (i === this.state.labels.length) {\n      this.raise(node.start, Errors.IllegalBreakContinue, keyword);\n    }\n  }\n\n  parseDebuggerStatement(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression() {\n    this.expect(types.parenL);\n    const val = this.parseExpression();\n    this.expect(types.parenR);\n    return val;\n  }\n\n  parseDoStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"do\"));\n    this.state.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(types.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  parseForStatement(node) {\n    this.next();\n    this.state.labels.push(loopLabel);\n    let awaitAt = -1;\n\n    if (this.isAwaitAllowed() && this.eatContextual(\"await\")) {\n      awaitAt = this.state.lastTokStart;\n    }\n\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(types.parenL);\n\n    if (this.match(types.semi)) {\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, null);\n    }\n\n    const isLet = this.isLet();\n\n    if (this.match(types._var) || this.match(types._const) || isLet) {\n      const init = this.startNode();\n      const kind = isLet ? \"let\" : this.state.value;\n      this.next();\n      this.parseVar(init, true, kind);\n      this.finishNode(init, \"VariableDeclaration\");\n\n      if ((this.match(types._in) || this.isContextual(\"of\")) && init.declarations.length === 1) {\n        return this.parseForIn(node, init, awaitAt);\n      }\n\n      if (awaitAt > -1) {\n        this.unexpected(awaitAt);\n      }\n\n      return this.parseFor(node, init);\n    }\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n\n    if (this.match(types._in) || this.isContextual(\"of\")) {\n      this.toAssignable(init);\n      const description = this.isContextual(\"of\") ? \"for-of statement\" : \"for-in statement\";\n      this.checkLVal(init, undefined, undefined, description);\n      return this.parseForIn(node, init, awaitAt);\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n\n    return this.parseFor(node, init);\n  }\n\n  parseFunctionStatement(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), isAsync);\n  }\n\n  parseIfStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(node) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(this.state.start, Errors.IllegalReturn);\n    }\n\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  parseSwitchStatement(node) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases = node.cases = [];\n    this.expect(types.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n    let cur;\n\n    for (let sawDefault; !this.match(types.braceR);) {\n      if (this.match(types._case) || this.match(types._default)) {\n        const isCase = this.match(types._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(this.state.lastTokStart, Errors.MultipleDefaultsInSwitch);\n          }\n\n          sawDefault = true;\n          cur.test = null;\n        }\n\n        this.expect(types.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatement(null));\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next();\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(node) {\n    this.next();\n\n    if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) {\n      this.raise(this.state.lastTokEnd, Errors.NewlineAfterThrow);\n    }\n\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseTryStatement(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(types._catch)) {\n      const clause = this.startNode();\n      this.next();\n\n      if (this.match(types.parenL)) {\n        this.expect(types.parenL);\n        clause.param = this.parseBindingAtom();\n        const simple = clause.param.type === \"Identifier\";\n        this.scope.enter(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, BIND_LEXICAL, null, \"catch clause\");\n        this.expect(types.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      clause.body = this.withTopicForbiddingContext(() => this.parseBlock(false, false));\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(node.start, Errors.NoCatchOrFinally);\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  parseVarStatement(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  parseWhileStatement(node) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"while\"));\n    this.state.labels.pop();\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(node) {\n    if (this.state.strict) {\n      this.raise(this.state.start, Errors.StrictWith);\n    }\n\n    this.next();\n    node.object = this.parseHeaderExpression();\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"with\"));\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  parseLabeledStatement(node, maybeName, expr, context) {\n    for (let _i2 = 0, _this$state$labels = this.state.labels; _i2 < _this$state$labels.length; _i2++) {\n      const label = _this$state$labels[_i2];\n\n      if (label.name === maybeName) {\n        this.raise(expr.start, Errors.LabelRedeclaration, maybeName);\n      }\n    }\n\n    const kind = this.state.type.isLoop ? \"loop\" : this.match(types._switch) ? \"switch\" : null;\n\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start\n    });\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {\n    const node = this.startNode();\n    this.expect(types.braceL);\n\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n\n    this.parseBlockBody(node, allowDirectives, false, types.braceR, afterBlockParse);\n\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt) {\n    return stmt.type === \"ExpressionStatement\" && stmt.expression.type === \"StringLiteral\" && !stmt.expression.extra.parenthesized;\n  }\n\n  parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {\n    const body = node.body = [];\n    const directives = node.directives = [];\n    this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : undefined, topLevel, end, afterBlockParse);\n  }\n\n  parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {\n    const octalPositions = [];\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      if (!parsedNonDirective && this.state.octalPositions.length) {\n        octalPositions.push(...this.state.octalPositions);\n      }\n\n      const stmt = this.parseStatement(null, topLevel);\n\n      if (directives && !parsedNonDirective && this.isValidDirective(stmt)) {\n        const directive = this.stmtToDirective(stmt);\n        directives.push(directive);\n\n        if (!hasStrictModeDirective && directive.value.value === \"use strict\") {\n          hasStrictModeDirective = true;\n          this.setStrict(true);\n        }\n\n        continue;\n      }\n\n      parsedNonDirective = true;\n      body.push(stmt);\n    }\n\n    if (this.state.strict && octalPositions.length) {\n      for (let _i3 = 0; _i3 < octalPositions.length; _i3++) {\n        const pos = octalPositions[_i3];\n        this.raise(pos, Errors.StrictOctalLiteral);\n      }\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  parseFor(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.match(types.semi) ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.match(types.parenR) ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  parseForIn(node, init, awaitAt) {\n    const isForIn = this.match(types._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt > -1) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt > -1;\n    }\n\n    if (init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (!isForIn || this.state.strict || init.kind !== \"var\" || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, Errors.ForInOfLoopInitializer, isForIn ? \"for-in\" : \"for-of\");\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, Errors.InvalidLhs, \"for-loop\");\n    }\n\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    node.body = this.withTopicForbiddingContext(() => this.parseStatement(\"for\"));\n    this.scope.exit();\n    this.state.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  parseVar(node, isFor, kind) {\n    const declarations = node.declarations = [];\n    const isTypescript = this.hasPlugin(\"typescript\");\n    node.kind = kind;\n\n    for (;;) {\n      const decl = this.startNode();\n      this.parseVarId(decl, kind);\n\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else {\n        if (kind === \"const\" && !(this.match(types._in) || this.isContextual(\"of\"))) {\n          if (!isTypescript) {\n            this.unexpected();\n          }\n        } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.match(types._in) || this.isContextual(\"of\")))) {\n          this.raise(this.state.lastTokEnd, Errors.DeclarationMissingInitializer, \"Complex binding patterns\");\n        }\n\n        decl.init = null;\n      }\n\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) break;\n    }\n\n    return node;\n  }\n\n  parseVarId(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, undefined, \"variable declaration\", kind !== \"var\");\n  }\n\n  parseFunction(node, statement = FUNC_NO_FLAGS, isAsync = false) {\n    const isStatement = statement & FUNC_STATEMENT;\n    const isHangingStatement = statement & FUNC_HANGING_STATEMENT;\n    const requireId = !!isStatement && !(statement & FUNC_NULLABLE_ID);\n    this.initFunction(node, isAsync);\n\n    if (this.match(types.star) && isHangingStatement) {\n      this.raise(this.state.start, Errors.GeneratorInSingleStatementContext);\n    }\n\n    node.generator = this.eat(types.star);\n\n    if (isStatement) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    const oldYieldPos = this.state.yieldPos;\n    const oldAwaitPos = this.state.awaitPos;\n    this.state.maybeInArrowParameters = false;\n    this.state.yieldPos = -1;\n    this.state.awaitPos = -1;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isStatement) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node);\n    this.withTopicForbiddingContext(() => {\n      this.parseFunctionBodyAndFinish(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n    });\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isStatement && !isHangingStatement) {\n      this.registerFunctionStatementId(node);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    this.state.yieldPos = oldYieldPos;\n    this.state.awaitPos = oldAwaitPos;\n    return node;\n  }\n\n  parseFunctionId(requireId) {\n    return requireId || this.match(types.name) ? this.parseIdentifier() : null;\n  }\n\n  parseFunctionParams(node, allowModifiers) {\n    const oldInParameters = this.state.inParameters;\n    this.state.inParameters = true;\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, 41, false, allowModifiers);\n    this.state.inParameters = oldInParameters;\n    this.checkYieldAwaitInDefaultParams();\n  }\n\n  registerFunctionStatementId(node) {\n    if (!node.id) return;\n    this.scope.declareName(node.id.name, this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION, node.id.start);\n  }\n\n  parseClass(node, isStatement, optionalId) {\n    this.next();\n    this.takeDecorators(node);\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n    this.state.strict = oldStrict;\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n  }\n\n  isClassProperty() {\n    return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);\n  }\n\n  isClassMethod() {\n    return this.match(types.parenL);\n  }\n\n  isNonstaticConstructor(method) {\n    return !method.computed && !method.static && (method.key.name === \"constructor\" || method.key.value === \"constructor\");\n  }\n\n  parseClassBody(constructorAllowsSuper, oldStrict) {\n    this.classScope.enter();\n    const state = {\n      hadConstructor: false\n    };\n    let decorators = [];\n    const classBody = this.startNode();\n    classBody.body = [];\n    this.expect(types.braceL);\n    this.withTopicForbiddingContext(() => {\n      while (!this.match(types.braceR)) {\n        if (this.eat(types.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(this.state.lastTokEnd, Errors.DecoratorSemicolon);\n          }\n\n          continue;\n        }\n\n        if (this.match(types.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode();\n\n        if (decorators.length) {\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state, constructorAllowsSuper);\n\n        if (member.kind === \"constructor\" && member.decorators && member.decorators.length > 0) {\n          this.raise(member.start, Errors.DecoratorConstructor);\n        }\n      }\n    });\n\n    if (!oldStrict) {\n      this.state.strict = false;\n    }\n\n    this.next();\n\n    if (decorators.length) {\n      throw this.raise(this.state.start, Errors.TrailingDecorator);\n    }\n\n    this.classScope.exit();\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  parseClassMemberFromModifier(classBody, member) {\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseIdentifier(true);\n\n    if (this.isClassMethod()) {\n      const method = member;\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(classBody, method, false, false, false, false);\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop = member;\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    } else if (containsEsc) {\n      throw this.unexpected();\n    }\n\n    return false;\n  }\n\n  parseClassMember(classBody, member, state, constructorAllowsSuper) {\n    const isStatic = this.isContextual(\"static\");\n\n    if (isStatic && this.parseClassMemberFromModifier(classBody, member)) {\n      return;\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper);\n  }\n\n  parseClassMemberWithIsStatic(classBody, member, state, isStatic, constructorAllowsSuper) {\n    const publicMethod = member;\n    const privateMethod = member;\n    const publicProp = member;\n    const privateProp = member;\n    const method = publicMethod;\n    const publicMember = publicMethod;\n    member.static = isStatic;\n\n    if (this.eat(types.star)) {\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(publicMethod.key.start, Errors.ConstructorIsGenerator);\n      }\n\n      this.pushClassMethod(classBody, publicMethod, true, false, false, false);\n      return;\n    }\n\n    const containsEsc = this.state.containsEsc;\n    const key = this.parseClassPropertyName(member);\n    const isPrivate = key.type === \"PrivateName\";\n    const isSimple = key.type === \"Identifier\";\n    const maybeQuestionTokenStart = this.state.start;\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(key.start, Errors.DuplicateConstructor);\n        }\n\n        state.hadConstructor = true;\n        allowsDirectSuper = constructorAllowsSuper;\n      }\n\n      this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (isSimple && key.name === \"async\" && !containsEsc && !this.isLineTerminator()) {\n      const isGenerator = this.eat(types.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStart);\n      }\n\n      method.kind = \"method\";\n      this.parseClassPropertyName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, Errors.ConstructorIsAsync);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);\n      }\n    } else if (isSimple && (key.name === \"get\" || key.name === \"set\") && !containsEsc && !(this.match(types.star) && this.isLineTerminator())) {\n      method.kind = key.name;\n      this.parseClassPropertyName(publicMethod);\n\n      if (method.key.type === \"PrivateName\") {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(publicMethod.key.start, Errors.ConstructorIsAccessor);\n        }\n\n        this.pushClassMethod(classBody, publicMethod, false, false, false, false);\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (this.isLineTerminator()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  parseClassPropertyName(member) {\n    const key = this.parsePropertyName(member, true);\n\n    if (!member.computed && member.static && (key.name === \"prototype\" || key.value === \"prototype\")) {\n      this.raise(key.start, Errors.StaticPrototype);\n    }\n\n    if (key.type === \"PrivateName\" && key.id.name === \"constructor\") {\n      this.raise(key.start, Errors.ConstructorClassPrivateField);\n    }\n\n    return key;\n  }\n\n  pushClassProperty(classBody, prop) {\n    if (!prop.computed && (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")) {\n      this.raise(prop.key.start, Errors.ConstructorClassField);\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(classBody, prop) {\n    this.expectPlugin(\"classPrivateProperties\", prop.key.start);\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n    this.classScope.declarePrivateName(node.key.id.name, CLASS_ELEMENT_OTHER, node.key.start);\n  }\n\n  pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {\n    classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, \"ClassMethod\", true));\n  }\n\n  pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {\n    this.expectPlugin(\"classPrivateMethods\", method.key.start);\n    const node = this.parseMethod(method, isGenerator, isAsync, false, false, \"ClassPrivateMethod\", true);\n    classBody.body.push(node);\n    const kind = node.kind === \"get\" ? node.static ? CLASS_ELEMENT_STATIC_GETTER : CLASS_ELEMENT_INSTANCE_GETTER : node.kind === \"set\" ? node.static ? CLASS_ELEMENT_STATIC_SETTER : CLASS_ELEMENT_INSTANCE_SETTER : CLASS_ELEMENT_OTHER;\n    this.classScope.declarePrivateName(node.key.id.name, kind, node.key.start);\n  }\n\n  parsePostMemberNameModifiers(methodOrProp) {}\n\n  parseAccessModifier() {\n    return undefined;\n  }\n\n  parseClassPrivateProperty(node) {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(types.eq) ? this.parseMaybeAssign() : null;\n    this.semicolon();\n    this.prodParam.exit();\n    this.scope.exit();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  parseClassProperty(node) {\n    if (!node.typeAnnotation) {\n      this.expectPlugin(\"classProperties\");\n    }\n\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.prodParam.enter(PARAM);\n\n    if (this.match(types.eq)) {\n      this.expectPlugin(\"classProperties\");\n      this.next();\n      node.value = this.parseMaybeAssign();\n    } else {\n      node.value = null;\n    }\n\n    this.semicolon();\n    this.prodParam.exit();\n    this.scope.exit();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassId(node, isStatement, optionalId, bindingType = BIND_CLASS) {\n    if (this.match(types.name)) {\n      node.id = this.parseIdentifier();\n\n      if (isStatement) {\n        this.checkLVal(node.id, bindingType, undefined, \"class name\");\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        this.unexpected(null, Errors.MissingClassName);\n      }\n    }\n  }\n\n  parseClassSuper(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  parseExport(node) {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(node);\n    const parseAfterDefault = !hasDefault || this.eat(types.comma);\n    const hasStar = parseAfterDefault && this.eatExportStar(node);\n    const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);\n    const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(types.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      this.parseExportFrom(node, true);\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers || hasNamespace && parseAfterNamespace && !hasSpecifiers) {\n      throw this.unexpected(null, types.braceL);\n    }\n\n    let hasDeclaration;\n\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      this.parseExportFrom(node, isFromRequired);\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(node);\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      this.checkExport(node, true, false, !!node.source);\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(types._default)) {\n      node.declaration = this.parseExportDefaultExpression();\n      this.checkExport(node, true, true);\n      return this.finishNode(node, \"ExportDefaultDeclaration\");\n    }\n\n    throw this.unexpected(null, types.braceL);\n  }\n\n  eatExportStar(node) {\n    return this.eat(types.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node) {\n    if (this.isExportDefaultSpecifier()) {\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node) {\n    if (this.isContextual(\"as\")) {\n      if (!node.specifiers) node.specifiers = [];\n      const specifier = this.startNodeAt(this.state.lastTokStart, this.state.lastTokStartLoc);\n      this.next();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers.push(this.finishNode(specifier, \"ExportNamespaceSpecifier\"));\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node) {\n    if (this.match(types.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      node.specifiers.push(...this.parseExportSpecifiers());\n      node.source = null;\n      node.declaration = null;\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseExportDeclaration(node) {\n    if (this.shouldParseExportDeclaration()) {\n      if (this.isContextual(\"async\")) {\n        const next = this.nextTokenStart();\n\n        if (!this.isUnparsedContextual(next, \"function\")) {\n          this.unexpected(next, types._function);\n        }\n      }\n\n      node.specifiers = [];\n      node.source = null;\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n\n    return false;\n  }\n\n  isAsyncFunction() {\n    if (!this.isContextual(\"async\")) return false;\n    const next = this.nextTokenStart();\n    return !lineBreak.test(this.input.slice(this.state.pos, next)) && this.isUnparsedContextual(next, \"function\");\n  }\n\n  parseExportDefaultExpression() {\n    const expr = this.startNode();\n    const isAsync = this.isAsyncFunction();\n\n    if (this.match(types._function) || isAsync) {\n      this.next();\n\n      if (isAsync) {\n        this.next();\n      }\n\n      return this.parseFunction(expr, FUNC_STATEMENT | FUNC_NULLABLE_ID, isAsync);\n    } else if (this.match(types._class)) {\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types.at)) {\n      if (this.hasPlugin(\"decorators\") && this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n        this.raise(this.state.start, Errors.DecoratorBeforeExport);\n      }\n\n      this.parseDecorators(false);\n      return this.parseClass(expr, true, true);\n    } else if (this.match(types._const) || this.match(types._var) || this.isLet()) {\n      throw this.raise(this.state.start, Errors.UnsupportedDefaultExport);\n    } else {\n      const res = this.parseMaybeAssign();\n      this.semicolon();\n      return res;\n    }\n  }\n\n  parseExportDeclaration(node) {\n    return this.parseStatement(null);\n  }\n\n  isExportDefaultSpecifier() {\n    if (this.match(types.name)) {\n      const value = this.state.value;\n\n      if (value === \"async\" || value === \"let\") {\n        return false;\n      }\n\n      if ((value === \"type\" || value === \"interface\") && !this.state.containsEsc) {\n        const l = this.lookahead();\n\n        if (l.type === types.name && l.value !== \"from\" || l.type === types.braceL) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(types._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    return this.input.charCodeAt(next) === 44 || this.isUnparsedContextual(next, \"from\");\n  }\n\n  parseExportFrom(node, expect) {\n    if (this.eatContextual(\"from\")) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n    } else {\n      if (expect) {\n        this.unexpected();\n      } else {\n        node.source = null;\n      }\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration() {\n    if (this.match(types.at)) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n      if (this.hasPlugin(\"decorators\")) {\n        if (this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\")) {\n          this.unexpected(this.state.start, Errors.DecoratorBeforeExport);\n        } else {\n          return true;\n        }\n      }\n    }\n\n    return this.state.type.keyword === \"var\" || this.state.type.keyword === \"const\" || this.state.type.keyword === \"function\" || this.state.type.keyword === \"class\" || this.isLet() || this.isAsyncFunction();\n  }\n\n  checkExport(node, checkNames, isDefault, isFrom) {\n    if (checkNames) {\n      if (isDefault) {\n        this.checkDuplicateExports(node, \"default\");\n      } else if (node.specifiers && node.specifiers.length) {\n        for (let _i4 = 0, _node$specifiers = node.specifiers; _i4 < _node$specifiers.length; _i4++) {\n          const specifier = _node$specifiers[_i4];\n          this.checkDuplicateExports(specifier, specifier.exported.name);\n\n          if (!isFrom && specifier.local) {\n            this.checkReservedWord(specifier.local.name, specifier.local.start, true, false);\n            this.scope.checkLocalExport(specifier.local);\n          }\n        }\n      } else if (node.declaration) {\n        if (node.declaration.type === \"FunctionDeclaration\" || node.declaration.type === \"ClassDeclaration\") {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (let _i5 = 0, _node$declaration$dec = node.declaration.declarations; _i5 < _node$declaration$dec.length; _i5++) {\n            const declaration = _node$declaration$dec[_i5];\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n\n    const currentContextDecorators = this.state.decoratorStack[this.state.decoratorStack.length - 1];\n\n    if (currentContextDecorators.length) {\n      const isClass = node.declaration && (node.declaration.type === \"ClassDeclaration\" || node.declaration.type === \"ClassExpression\");\n\n      if (!node.declaration || !isClass) {\n        throw this.raise(node.start, Errors.UnsupportedDecoratorExport);\n      }\n\n      this.takeDecorators(node.declaration);\n    }\n  }\n\n  checkDeclaration(node) {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (let _i6 = 0, _node$properties = node.properties; _i6 < _node$properties.length; _i6++) {\n        const prop = _node$properties[_i6];\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (let _i7 = 0, _node$elements = node.elements; _i7 < _node$elements.length; _i7++) {\n        const elem = _node$elements[_i7];\n\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(node, name) {\n    if (this.state.exportedIdentifiers.indexOf(name) > -1) {\n      this.raise(node.start, name === \"default\" ? Errors.DuplicateDefaultExport : Errors.DuplicateExport, name);\n    }\n\n    this.state.exportedIdentifiers.push(name);\n  }\n\n  parseExportSpecifiers() {\n    const nodes = [];\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      const node = this.startNode();\n      node.local = this.parseIdentifier(true);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdentifier(true) : node.local.__clone();\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n\n    return nodes;\n  }\n\n  parseImport(node) {\n    node.specifiers = [];\n\n    if (!this.match(types.string)) {\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      const parseNext = !hasDefault || this.eat(types.comma);\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(\"from\");\n    }\n\n    node.source = this.parseImportSource();\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource() {\n    if (!this.match(types.string)) this.unexpected();\n    return this.parseExprAtom();\n  }\n\n  shouldParseDefaultImport(node) {\n    return this.match(types.name);\n  }\n\n  parseImportSpecifierLocal(node, specifier, type, contextDescription) {\n    specifier.local = this.parseIdentifier();\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, contextDescription);\n    node.specifiers.push(this.finishNode(specifier, type));\n  }\n\n  maybeParseDefaultImportSpecifier(node) {\n    if (this.shouldParseDefaultImport(node)) {\n      this.parseImportSpecifierLocal(node, this.startNode(), \"ImportDefaultSpecifier\", \"default import specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node) {\n    if (this.match(types.star)) {\n      const specifier = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      this.parseImportSpecifierLocal(node, specifier, \"ImportNamespaceSpecifier\", \"import namespace specifier\");\n      return true;\n    }\n\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node) {\n    let first = true;\n    this.expect(types.braceL);\n\n    while (!this.eat(types.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        if (this.eat(types.colon)) {\n          throw this.raise(this.state.start, Errors.DestructureNamedImport);\n        }\n\n        this.expect(types.comma);\n        if (this.eat(types.braceR)) break;\n      }\n\n      this.parseImportSpecifier(node);\n    }\n  }\n\n  parseImportSpecifier(node) {\n    const specifier = this.startNode();\n    specifier.imported = this.parseIdentifier(true);\n\n    if (this.eatContextual(\"as\")) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      this.checkReservedWord(specifier.imported.name, specifier.start, true, true);\n      specifier.local = specifier.imported.__clone();\n    }\n\n    this.checkLVal(specifier.local, BIND_LEXICAL, undefined, \"import specifier\");\n    node.specifiers.push(this.finishNode(specifier, \"ImportSpecifier\"));\n  }\n\n}\n\nclass ClassScope {\n  constructor() {\n    this.privateNames = new Set();\n    this.loneAccessors = new Map();\n    this.undefinedPrivateNames = new Map();\n  }\n\n}\nclass ClassScopeHandler {\n  constructor(raise) {\n    this.stack = [];\n    this.undefinedPrivateNames = new Map();\n    this.raise = raise;\n  }\n\n  current() {\n    return this.stack[this.stack.length - 1];\n  }\n\n  enter() {\n    this.stack.push(new ClassScope());\n  }\n\n  exit() {\n    const oldClassScope = this.stack.pop();\n    const current = this.current();\n\n    for (let _i = 0, _Array$from = Array.from(oldClassScope.undefinedPrivateNames); _i < _Array$from.length; _i++) {\n      const [name, pos] = _Array$from[_i];\n\n      if (current) {\n        if (!current.undefinedPrivateNames.has(name)) {\n          current.undefinedPrivateNames.set(name, pos);\n        }\n      } else {\n        this.raise(pos, Errors.InvalidPrivateFieldResolution, name);\n      }\n    }\n  }\n\n  declarePrivateName(name, elementType, pos) {\n    const classScope = this.current();\n    let redefined = classScope.privateNames.has(name);\n\n    if (elementType & CLASS_ELEMENT_KIND_ACCESSOR) {\n      const accessor = redefined && classScope.loneAccessors.get(name);\n\n      if (accessor) {\n        const oldStatic = accessor & CLASS_ELEMENT_FLAG_STATIC;\n        const newStatic = elementType & CLASS_ELEMENT_FLAG_STATIC;\n        const oldKind = accessor & CLASS_ELEMENT_KIND_ACCESSOR;\n        const newKind = elementType & CLASS_ELEMENT_KIND_ACCESSOR;\n        redefined = oldKind === newKind || oldStatic !== newStatic;\n        if (!redefined) classScope.loneAccessors.delete(name);\n      } else if (!redefined) {\n        classScope.loneAccessors.set(name, elementType);\n      }\n    }\n\n    if (redefined) {\n      this.raise(pos, Errors.PrivateNameRedeclaration, name);\n    }\n\n    classScope.privateNames.add(name);\n    classScope.undefinedPrivateNames.delete(name);\n  }\n\n  usePrivateName(name, pos) {\n    let classScope;\n\n    for (let _i2 = 0, _this$stack = this.stack; _i2 < _this$stack.length; _i2++) {\n      classScope = _this$stack[_i2];\n      if (classScope.privateNames.has(name)) return;\n    }\n\n    if (classScope) {\n      classScope.undefinedPrivateNames.set(name, pos);\n    } else {\n      this.raise(pos, Errors.InvalidPrivateFieldResolution, name);\n    }\n  }\n\n}\n\nclass Parser extends StatementParser {\n  constructor(options, input) {\n    options = getOptions(options);\n    super(options, input);\n    const ScopeHandler = this.getScopeHandler();\n    this.options = options;\n    this.inModule = this.options.sourceType === \"module\";\n    this.scope = new ScopeHandler(this.raise.bind(this), this.inModule);\n    this.prodParam = new ProductionParameterHandler();\n    this.classScope = new ClassScopeHandler(this.raise.bind(this));\n    this.plugins = pluginsMap(this.options.plugins);\n    this.filename = options.sourceFilename;\n  }\n\n  getScopeHandler() {\n    return ScopeHandler;\n  }\n\n  parse() {\n    let paramFlags = PARAM;\n\n    if (this.hasPlugin(\"topLevelAwait\") && this.inModule) {\n      paramFlags |= PARAM_AWAIT;\n    }\n\n    this.scope.enter(SCOPE_PROGRAM);\n    this.prodParam.enter(paramFlags);\n    const file = this.startNode();\n    const program = this.startNode();\n    this.nextToken();\n    file.errors = null;\n    this.parseTopLevel(file, program);\n    file.errors = this.state.errors;\n    return file;\n  }\n\n}\n\nfunction pluginsMap(plugins) {\n  const pluginMap = new Map();\n\n  for (let _i = 0; _i < plugins.length; _i++) {\n    const plugin = plugins[_i];\n    const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];\n    if (!pluginMap.has(name)) pluginMap.set(name, options || {});\n  }\n\n  return pluginMap;\n}\n\nfunction parse(input, options) {\n  if (options && options.sourceType === \"unambiguous\") {\n    options = Object.assign({}, options);\n\n    try {\n      options.sourceType = \"module\";\n      const parser = getParser(options, input);\n      const ast = parser.parse();\n\n      if (parser.sawUnambiguousESM) {\n        return ast;\n      }\n\n      if (parser.ambiguousScriptDifferentAst) {\n        try {\n          options.sourceType = \"script\";\n          return getParser(options, input).parse();\n        } catch (_unused) {}\n      } else {\n        ast.program.sourceType = \"script\";\n      }\n\n      return ast;\n    } catch (moduleError) {\n      try {\n        options.sourceType = \"script\";\n        return getParser(options, input).parse();\n      } catch (_unused2) {}\n\n      throw moduleError;\n    }\n  } else {\n    return getParser(options, input).parse();\n  }\n}\nfunction parseExpression(input, options) {\n  const parser = getParser(options, input);\n\n  if (parser.options.strictMode) {\n    parser.state.strict = true;\n  }\n\n  return parser.getExpression();\n}\n\nfunction getParser(options, input) {\n  let cls = Parser;\n\n  if (options && options.plugins) {\n    validatePlugins(options.plugins);\n    cls = getParserClass(options.plugins);\n  }\n\n  return new cls(options, input);\n}\n\nconst parserClassCache = {};\n\nfunction getParserClass(pluginsFromOptions) {\n  const pluginList = mixinPluginNames.filter(name => hasPlugin(pluginsFromOptions, name));\n  const key = pluginList.join(\"/\");\n  let cls = parserClassCache[key];\n\n  if (!cls) {\n    cls = Parser;\n\n    for (let _i = 0; _i < pluginList.length; _i++) {\n      const plugin = pluginList[_i];\n      cls = mixinPlugins[plugin](cls);\n    }\n\n    parserClassCache[key] = cls;\n  }\n\n  return cls;\n}\n\nexports.parse = parse;\nexports.parseExpression = parseExpression;\nexports.tokTypes = types;\n//# sourceMappingURL=index.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _callMeta = require(\"../type-graph/meta/call-meta\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _functionType = require(\"../inference/function-type\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _functionType2 = require(\"../type-graph/types/function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getActualType(actual, typeScope) {\n  if (actual === undefined || actual === null) {\n    return _type.Type.Undefined;\n  }\n\n  if (Array.isArray(actual)) {\n    const items = actual.map(a => getActualType(a, typeScope));\n    return _tupleType.TupleType.term(_tupleType.TupleType.getName(items), {}, items);\n  }\n\n  if (actual instanceof _variableInfo.VariableInfo) {\n    return getActualType(actual.type, typeScope);\n  }\n\n  if (actual instanceof _typeVar.TypeVar && actual.root != undefined) {\n    return actual.root;\n  }\n\n  return actual;\n}\n\nfunction isAssign(call) {\n  return call.targetName.includes(\"=\") && !call.targetName.includes(\"==\");\n}\n\nfunction isValidTypes(targetName, declaratedType, actual, typeScope) {\n  let declaratedRootType = declaratedType instanceof _functionType2.RestArgument ? declaratedType.type : declaratedType;\n  const actualRootType = getActualType(actual, typeScope);\n\n  if (declaratedType instanceof _functionType2.RestArgument && Array.isArray(actual)) {\n    return isValidTypes(targetName, declaratedType.type, actualRootType, typeScope);\n  } else if (!(declaratedType instanceof _functionType2.RestArgument)) {\n    declaratedRootType = declaratedRootType instanceof _typeVar.TypeVar && declaratedRootType.root ? declaratedRootType.root : declaratedRootType;\n\n    if (actualRootType instanceof _unionType.UnionType) {\n      return actualRootType.variants.every(t => isValidTypes(targetName, declaratedRootType, actual instanceof _variableInfo.VariableInfo ? new _variableInfo.VariableInfo(t) : t, typeScope));\n    }\n\n    if (declaratedRootType.onlyLiteral && !(declaratedRootType instanceof _objectType.ObjectType && declaratedRootType.isNominal) && declaratedRootType !== _objectType.ObjectType.Object && declaratedRootType !== _objectType.ObjectType.Object.root && declaratedRootType !== _functionType2.FunctionType.Function && declaratedRootType !== _functionType2.FunctionType.Function.root && actual instanceof _variableInfo.VariableInfo) {\n      return declaratedRootType.equalsTo(actualRootType);\n    }\n\n    if (targetName === \"return\" || targetName === \"init\" || targetName === \"=\" || declaratedRootType.parent.priority >= _typeScope.TypeScope.MODULE_SCOPE_PRIORITY && (0, _typeUtils.isReachableType)(declaratedRootType, typeScope)) {\n      _typeVar.TypeVar.strictEquality = true;\n      const result = declaratedRootType.isPrincipalTypeFor(actualRootType);\n      _typeVar.TypeVar.strictEquality = false;\n      return result;\n    }\n\n    return declaratedRootType.isPrincipalTypeFor(actualRootType);\n  }\n\n  throw new Error(\"Never!\");\n}\n\nfunction checkSingleCall(path, call, typeScope, errors) {\n  const givenArgumentsTypes = call.arguments.map(t => t instanceof _variableInfo.VariableInfo ? t.type : t);\n  const targetFunctionType = (0, _functionType.getCallTarget)(call);\n  const targetArguments = targetFunctionType.argumentsTypes;\n  const requiredTargetArguments = targetArguments.filter(a => !(a instanceof _unionType.UnionType && a.variants.find(a => a.equalsTo(_type.Type.Undefined)) || a instanceof _functionType2.RestArgument));\n\n  if (requiredTargetArguments.length > givenArgumentsTypes.length) {\n    errors.push(new _errors2.default(`${requiredTargetArguments.length} arguments are required. Given ${givenArgumentsTypes.length}.`, call.loc, path));\n  } else if (targetArguments.length < givenArgumentsTypes.length && !(targetArguments[targetArguments.length - 1] instanceof _functionType2.RestArgument)) {\n    errors.push(new _errors2.default(`${targetArguments.length} arguments are expected. Given ${givenArgumentsTypes.length}.`, call.loc, path));\n  } else {\n    let firstArgumentType = call.arguments[0];\n    firstArgumentType = firstArgumentType instanceof _variableInfo.VariableInfo ? firstArgumentType.type : firstArgumentType;\n\n    if (isAssign(call) && firstArgumentType instanceof _immutableType.$AppliedImmutable) {\n      errors.push(new _errors2.default(`Attempt to mutate immutable type`, call.loc, path));\n    }\n\n    for (let i = 0; i < targetArguments.length; i++) {\n      const arg1 = targetArguments[i];\n      const arg2 = arg1 instanceof _functionType2.RestArgument ? call.arguments.slice(i) : call.arguments[i];\n\n      if (!isValidTypes(call.targetName, arg1, arg2, call.typeScope)) {\n        let actualType = arg1 instanceof _functionType2.RestArgument ? givenArgumentsTypes.slice(i) : givenArgumentsTypes[i];\n        actualType = actualType instanceof _variableInfo.VariableInfo ? actualType.type : actualType;\n        const actualTypeName = // $FlowIssue\n        arg2 === undefined ? \"undefined\" : _tupleType.TupleType.getName(actualType);\n        errors.push(new _errors2.default(`Type \"${actualTypeName}\" is incompatible with type \"${String(arg1.name)}\"`, arg1 instanceof _functionType2.RestArgument ? call.loc : call.argumentsLocations[i] || call.loc, path));\n      }\n    }\n  }\n}\n\nfunction checkCalls(path, scope, typeScope, errors) {\n  let returnWasCalled = false;\n  let finalWasCalled = false;\n\n  for (let i = 0; i < scope.calls.length; i++) {\n    const call = scope.calls[i];\n\n    if (call.target === undefined) {\n      continue;\n    }\n\n    if (call.targetName === \"return\") {\n      returnWasCalled = true;\n    }\n\n    if (call.isFinal) {\n      finalWasCalled = true;\n    }\n\n    checkSingleCall(path, call, typeScope, errors);\n  }\n\n  if (scope instanceof _variableScope.VariableScope && scope.type === _variableScope.VariableScope.FUNCTION_TYPE && scope.declaration instanceof _variableInfo.VariableInfo && !returnWasCalled && !finalWasCalled) {\n    const {\n      declaration\n    } = scope;\n    const {\n      returnType,\n      isAsync\n    } = declaration.type instanceof _genericType.GenericType ? declaration.type.subordinateType : declaration.type;\n\n    if (!declaration.isInferenced && !isFunctionShouldNotCallReturn(returnType, isAsync)) {\n      errors.push(new _errors2.default(`Function should return something with type \"${String(returnType.name)}\"`, declaration.meta.loc, path));\n    }\n  }\n}\n\nfunction isFunctionShouldNotCallReturn(returnType, isAsync) {\n  if (returnType === undefined || returnType instanceof _typeVar.TypeVar && !returnType.isUserDefined) {\n    return true;\n  }\n\n  if (returnType instanceof _unionType.UnionType) {\n    return returnType.variants.some(returnType => isFunctionShouldNotCallReturn(returnType, isAsync));\n  }\n\n  return returnType === _type.Type.Undefined || isAsync && returnType.equalsTo(_type.Type.Undefined.promisify());\n}\n\nexports.default = checkCalls;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createModuleScope = exports.createGlobalScope = exports.HegelError = exports.VariableInfo = exports.Type = exports.PositionedModuleScope = exports.ModuleScope = exports.VariableScope = exports.TypeScope = undefined;\n\nvar _errors = require(\"./utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type-graph/types/type\");\n\nvar _typeScope = require(\"./type-graph/type-scope\");\n\nvar _variableInfo = require(\"./type-graph/variable-info\");\n\nvar _variableScope = require(\"./type-graph/variable-scope\");\n\nvar _moduleScope = require(\"./type-graph/module-scope\");\n\nvar _typeGraph = require(\"./type-graph/type-graph\");\n\nvar _typeGraph2 = _interopRequireDefault(_typeGraph);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst TypeScope = exports.TypeScope = _typeScope.TypeScope;\nconst VariableScope = exports.VariableScope = _variableScope.VariableScope;\nconst ModuleScope = exports.ModuleScope = _moduleScope.ModuleScope;\nconst PositionedModuleScope = exports.PositionedModuleScope = _moduleScope.PositionedModuleScope;\nconst Type = exports.Type = _type.Type;\nconst VariableInfo = exports.VariableInfo = _variableInfo.VariableInfo;\nconst HegelError = exports.HegelError = _errors2.default;\nconst createGlobalScope = exports.createGlobalScope = _typeGraph2.default;\nconst createModuleScope = exports.createModuleScope = _typeGraph.createModuleScope;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.refinePropertyWithConstraint = refinePropertyWithConstraint;\nexports.refinementProperty = refinementProperty;\nexports.equalsRefinement = equalsRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _common = require(\"../utils/common\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isIdentifierOrProperty(node) {\n  return node.type === _nodes2.default.IDENTIFIER && node.name !== \"undefined\" || node.type === _nodes2.default.MEMBER_EXPRESSION;\n}\n\nfunction getEqualsArguments(left, right, refinementNode) {\n  if ((refinementNode.type !== _nodes2.default.SWITCH_CASE || right === null || left === null) && (refinementNode.type !== _nodes2.default.BINARY_EXPRESSION || ![\"===\", \"==\", \"!==\", \"!=\"].includes(refinementNode.operator))) {\n    return;\n  }\n\n  let target = null;\n\n  if (isIdentifierOrProperty(left)) {\n    target = left;\n  } else if (isIdentifierOrProperty(right)) {\n    target = right;\n  }\n\n  let value = null;\n\n  if (isSimpleLiteral(left)) {\n    value = left;\n  } else if (isSimpleLiteral(right)) {\n    value = right;\n  }\n\n  if (!target || !value) {\n    return null;\n  }\n\n  return {\n    value,\n    target\n  };\n}\n\nfunction isStrict(refinementNode) {\n  if (refinementNode.type === _nodes2.default.SWITCH_CASE) {\n    return true;\n  }\n\n  switch (refinementNode.operator) {\n    case \"===\":\n    case \"!==\":\n      return true;\n\n    case \"==\":\n    case \"!=\":\n      return false;\n  }\n\n  throw new Error(\"Never!\");\n}\n\nfunction isSimpleLiteral(node) {\n  return node.type === _nodes2.default.NULL_LITERAL || node.type === _nodes2.default.NUMERIC_LITERAL || node.type === _nodes2.default.BIGINT_LITERAL || node.type === _nodes2.default.STRING_LITERAL || node.type === _nodes2.default.BOOLEAN_LITERAL || node.type === _nodes2.default.IDENTIFIER && node.name === \"undefined\";\n}\n\nfunction getRefinmentType(value, refinementNode) {\n  const UNION = _unionType.UnionType.term(\"undefined | null\", {}, [_type.Type.Undefined, _type.Type.Null]);\n\n  const strict = isStrict(refinementNode);\n\n  switch (value.type) {\n    case _nodes2.default.NUMERIC_LITERAL:\n      return _type.Type.term(value.value, {\n        isSubtypeOf: _type.Type.Number\n      });\n\n    case _nodes2.default.BIGINT_LITERAL:\n      return _type.Type.term(`${value.value}n`, {\n        isSubtypeOf: _type.Type.BigInt\n      });\n\n    case _nodes2.default.STRING_LITERAL:\n      return _type.Type.term(`'${value.value}'`, {\n        isSubtypeOf: _type.Type.String\n      });\n\n    case _nodes2.default.BOOLEAN_LITERAL:\n      return _type.Type.term(value.value);\n\n    case _nodes2.default.NULL_LITERAL:\n      return strict ? _type.Type.Null : UNION;\n  }\n\n  if (value.type === _nodes2.default.IDENTIFIER && value.name === \"undefined\") {\n    return strict ? _type.Type.Undefined : UNION;\n  }\n\n  throw new Error(\"Never!\");\n}\n\nfunction refinementVariants([refinementedVariants, alternateVariants], variant, refinementType) {\n  if (refinementType.isPrincipalTypeFor(variant)) {\n    return [refinementedVariants.concat([variant]), alternateVariants];\n  }\n\n  if (variant.isPrincipalTypeFor(refinementType)) {\n    return [refinementedVariants.concat([refinementType]), alternateVariants.concat([variant])];\n  }\n\n  return [refinementedVariants, alternateVariants.concat([variant])];\n}\n\nfunction equalsIdentifier(node, currentScope, typeScope, value, refinementNode, isSwitch) {\n  const variableName = node.name;\n  const refinementType = getRefinmentType(value, refinementNode);\n  const variableInfo = currentScope.findVariable(node);\n  const [refinementedVariants, alternateVariants] = variableInfo.type instanceof _unionType.UnionType ? variableInfo.type.variants.reduce((res, variant) => refinementVariants(res, variant, refinementType), [[], []]) : refinementVariants([[], []], variableInfo.type, refinementType);\n\n  if (!(variableInfo.type instanceof _typeVar.TypeVar) && variableInfo.type !== _type.Type.Unknown && refinementedVariants.length === 0) {\n    throw new _errors2.default(`Type ${String(variableInfo.type.name)} can't be \"${String(refinementType.name)}\" type`, refinementNode.loc);\n  }\n\n  const refinementedType = _unionType.UnionType.term(null, {}, refinementedVariants);\n\n  const alternateType = alternateVariants.length === 0 || refinementType === variableInfo.type ? _type.Type.Never : _unionType.UnionType.term(null, {}, alternateVariants);\n\n  if (refinementedType == _type.Type.Never || alternateType == _type.Type.Never && !isSwitch) {\n    const typeName = String(refinementType.name);\n    throw new _errors2.default(`Type ${refinementedType === _type.Type.Never ? \"can't be\" : \"is always\"} \"${typeName}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinementedType, alternateType];\n}\n\nfunction refinePropertyWithConstraint(chaining, refinementType, variableType, typeScope) {\n  const refinementedType = chaining.reduceRight((res, property) => (0, _typeUtils.createObjectWith)(property, res, typeScope), refinementType);\n  return [refinementedType, variableType];\n}\n\nfunction propertyWith(propertyName, propertyType, propertyOwner, typeScope) {\n  if (propertyType == undefined) {\n    return propertyType;\n  }\n\n  const newPropertyOwner = (0, _typeUtils.createObjectWith)(propertyName, propertyType, typeScope);\n  return (0, _typeUtils.mergeObjectsTypes)(propertyOwner, newPropertyOwner, typeScope);\n}\n\nfunction refinementProperty(variableName, variableType, refinementType, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope, destructUnion = false) {\n  const currentPropertyName = chainingProperties[currentPropertyNameIndex];\n  const isLast = currentPropertyNameIndex === chainingProperties.length - 1;\n\n  if (variableType instanceof _typeVar.TypeVar || variableType === _type.Type.Unknown) {\n    if (!(variableType instanceof _typeVar.TypeVar) || variableType.constraint === undefined) {\n      return refinePropertyWithConstraint(chainingProperties.slice(currentPropertyNameIndex), refinementType, variableType, typeScope);\n    }\n\n    variableType = variableType.constraint;\n  }\n\n  if (isLast && variableType instanceof _collectionType.CollectionType) {\n    return;\n  }\n\n  if (variableType instanceof _objectType.ObjectType) {\n    const property = variableType.getPropertyType(currentPropertyName);\n\n    if (property == null) {\n      return;\n    }\n\n    if (isLast) {\n      if (property instanceof _unionType.UnionType) {\n        const [refinementedVariants, alternateVariants] = property.variants.reduce((res, variant) => refinementVariants(res, variant, refinementType), [[], []]);\n        const [refinemented, alternate] = (0, _inferenceUtils.getTypesFromVariants)( // $FlowIssue\n        refinementedVariants, // $FlowIssue\n        alternateVariants, typeScope);\n        return [propertyWith(currentPropertyName, refinemented, variableType, typeScope), propertyWith(currentPropertyName, alternate, variableType, typeScope)];\n      }\n\n      if (refinementType.isPrincipalTypeFor(property)) {\n        return [variableType, undefined];\n      }\n\n      if (property.isPrincipalTypeFor(refinementType)) {\n        return [propertyWith(currentPropertyName, refinementType, variableType, typeScope), variableType];\n      }\n\n      if (destructUnion && refinementType instanceof _unionType.UnionType) {\n        const pickedVariants = refinementType.variants.filter(variant => property.isPrincipalTypeFor(variant));\n        return [propertyWith(currentPropertyName, _unionType.UnionType.term(null, {}, pickedVariants), variableType, typeScope), variableType];\n      }\n\n      return [undefined, variableType];\n    }\n\n    const nextIndex = currentPropertyNameIndex + 1;\n    const nestedRefinement = refinementProperty(variableName, property, refinementType, refinementNode, nextIndex, chainingProperties, typeScope);\n\n    if (!nestedRefinement) {\n      return;\n    }\n\n    return [propertyWith(currentPropertyName, nestedRefinement[0], variableType, typeScope), propertyWith(currentPropertyName, nestedRefinement[1], variableType, typeScope)];\n  }\n\n  if (variableType instanceof _unionType.UnionType) {\n    const [refinementedVariants, alternateVariants] = variableType.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n      const isNotAlternateVariant = variant instanceof _objectType.ObjectType && variant.getPropertyType(currentPropertyName);\n      const refinementedTypeAndAlternateType = isNotAlternateVariant ? refinementProperty(variableName, variant, refinementType, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) : undefined;\n\n      if (!refinementedTypeAndAlternateType) {\n        return [refinementedVariants, alternateVariants.concat([variant])];\n      }\n\n      const [refinementedType, alternateType] = refinementedTypeAndAlternateType;\n      return [refinementedType ? refinementedVariants.concat([refinementedType]) : refinementedVariants, alternateType ? alternateVariants.concat([alternateType]) : alternateVariants];\n    }, [[], []]);\n    return (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n  }\n}\n\nfunction equalsProperty(node, currentScope, typeScope, value, refinementNode, isSwitch) {\n  const targetObject = (0, _common.getMemberExressionTarget)(node);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(node);\n  const refinementType = getRefinmentType(value, refinementNode);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !targetVariableInfo || !propertiesChaining || targetVariableInfo instanceof _variableScope.VariableScope) {\n    return;\n  }\n\n  const refinmentedAndAlternate = refinementProperty(variableName, targetVariableInfo.type, refinementType, refinementNode, 0, propertiesChaining, typeScope);\n\n  if (refinmentedAndAlternate == undefined) {\n    return;\n  }\n\n  const [refinemented, alternate] = refinmentedAndAlternate;\n\n  if (refinemented != undefined && alternate == undefined && isSwitch) {\n    return [variableName, refinemented, _type.Type.Never];\n  }\n\n  if (refinemented == undefined || alternate == undefined && !isSwitch) {\n    const typeName = String(refinementType.name);\n    throw new _errors2.default(`Property ${refinemented === undefined ? \"can't be\" : \"is always\"} \"${typeName}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinemented, alternate || _type.Type.Never];\n}\n\nfunction equalsRefinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  const isSwitch = currentRefinementNode.type === _nodes2.default.SWITCH_CASE;\n  const args = getEqualsArguments(isSwitch ? currentRefinementNode.parent.discriminant : currentRefinementNode.left, isSwitch ? currentRefinementNode.test : currentRefinementNode.right, currentRefinementNode);\n\n  if (!args) {\n    return;\n  }\n\n  const {\n    target,\n    value\n  } = args;\n  let refinementedType, alternateType, name;\n\n  if (target.type === _nodes2.default.IDENTIFIER) {\n    [name, refinementedType, alternateType] = equalsIdentifier(target, currentScope, typeScope, value, currentRefinementNode, isSwitch);\n  }\n\n  if (target.type === _nodes2.default.MEMBER_EXPRESSION) {\n    const result = equalsProperty(target, currentScope, typeScope, value, currentRefinementNode, isSwitch);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  if (refinementedType) {\n    if (currentRefinementNode.operator === \"!==\" || currentRefinementNode.operator === \"!=\") {\n      // $FlowIssue\n      return [name, alternateType, refinementedType];\n    } // $FlowIssue\n\n\n    return [name, refinementedType, alternateType];\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferenceErrorType = inferenceErrorType;\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nfunction inferenceErrorType(tryNode, moduleScope) {\n  const tryScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(tryNode));\n\n  if (tryScope === undefined || tryScope.throwable === undefined) {\n    throw new Error(\"Never\");\n  }\n\n  const variants = tryScope.throwable.map(t => t instanceof _variableInfo.VariableInfo ? t.type : t);\n  return _unionType.UnionType.term(null, {}, variants);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferenceFunctionLiteralType = inferenceFunctionLiteralType;\nexports.getCallTarget = getCallTarget;\nexports.implicitApplyGeneric = implicitApplyGeneric;\nexports.getRawFunctionType = getRawFunctionType;\nexports.getInvocationType = getInvocationType;\nexports.clearRoot = clearRoot;\nexports.prepareGenericFunctionType = prepareGenericFunctionType;\nexports.inferenceFunctionTypeByScope = inferenceFunctionTypeByScope;\nexports.isGenericFunctionType = isGenericFunctionType;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _callMeta = require(\"../type-graph/meta/call-meta\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _bottomType = require(\"../type-graph/types/bottom-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _propertyType = require(\"../type-graph/types/property-type\");\n\nvar _throwsType = require(\"../type-graph/types/throws-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _variableUtils = require(\"../utils/variable-utils\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _call = require(\"../type-graph/call\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst typeVarNames = [\"_a\", \"_b\", \"_c\", \"_d\", \"_e\", \"_f\", \"_g\", \"_h\", \"_i\", \"_j\", \"_k\", \"_l\", \"_m\", \"_n\", \"_o\", \"_p\", \"__a\", \"__b\", \"__c\", \"__d\", \"__e\", \"__f\", \"__g\", \"__h\", \"__i\", \"__j\", \"__k\", \"__l\", \"__m\", \"__n\", \"__o\", \"__p\"];\n\nconst isValidRestArgumentType = type => type instanceof _collectionType.CollectionType || type instanceof _tupleType.TupleType || type instanceof _bottomType.$BottomType && type.getRootedSubordinateType().isPrincipalTypeFor(_collectionType.CollectionType.Array);\n\nfunction inferenceFunctionLiteralType(currentNode, typeScope, parentScope, typeGraph, isTypeDefinitions, parentNode, pre, middle, post) {\n  const localTypeScope = new _typeScope.TypeScope((0, _scopeUtils.findNearestTypeScope)(parentScope, typeGraph));\n  const functionScope = isTypeDefinitions ? new _variableScope.VariableScope(_variableScope.VariableScope.FUNCTION_TYPE, parentScope) : typeGraph.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n  if (!(functionScope instanceof _variableScope.VariableScope)) {\n    throw new Error(\"Function scope should be created before inference\");\n  }\n\n  const genericArguments = new Set();\n\n  if (currentNode.typeParameters != undefined) {\n    currentNode.typeParameters.params.forEach(typeAnnotation => genericArguments.add((0, _typeUtils.getTypeFromTypeAnnotation)({\n      typeAnnotation\n    }, localTypeScope, parentScope, true, null, parentNode, typeGraph, pre, middle, post)));\n  } else {\n    localTypeScope.makeCustom();\n  }\n\n  let nameIndex = 0;\n\n  try {\n    do {\n      _type.Type.find(typeVarNames[nameIndex], {\n        parent: localTypeScope\n      });\n\n      nameIndex++;\n    } while (true);\n  } catch {}\n\n  const self = parentScope.type === _variableScope.VariableScope.CLASS_TYPE || parentScope.type === _variableScope.VariableScope.OBJECT_TYPE ? // $FlowIssue\n  parentScope.body.get(_constants.THIS_TYPE).type : null;\n  const argumentsTypes = currentNode.params.map((param, index) => {\n    if (param.optional && !isTypeDefinitions) {\n      throw new _errors2.default(\"The optional argument syntax is not allowed. Use optional type instead.\", param.loc);\n    }\n\n    const {\n      name\n    } = param.left || param;\n    const typeNode = param.left !== undefined ? param.left.typeAnnotation : param.typeAnnotation;\n    const typeAnnotation = param.optional ? {\n      typeAnnotation: { ...typeNode,\n        type: _nodes2.default.NULLABLE_TYPE_ANNOTATION\n      }\n    } : typeNode;\n    let paramType = (0, _typeUtils.getTypeFromTypeAnnotation)(typeAnnotation, localTypeScope, parentScope, false, // $FlowIssue\n    self, parentNode, typeGraph, pre, middle, post);\n    const isWithoutAnnotation = typeNode == undefined;\n    functionScope.body.set(name, new _variableInfo.VariableInfo(paramType, functionScope, new _meta.Meta(param.loc)));\n\n    if (param.left !== undefined) {\n      if (!isWithoutAnnotation && typeNode.typeAnnotation.type === _nodes2.default.NULLABLE_TYPE_ANNOTATION) {\n        throw new _errors2.default(\"Argument cannot be optional and has initializer.\", typeNode.typeAnnotation.loc);\n      }\n\n      const callResultType = (0, _call.addCallToTypeGraph)(param, typeGraph, functionScope, parentNode, pre, middle, post);\n      const newType = callResultType.result instanceof _variableInfo.VariableInfo ? callResultType.result.type : callResultType.result;\n      paramType = !isWithoutAnnotation ? paramType : (0, _variableUtils.getVariableType)(new _variableInfo.VariableInfo(paramType, functionScope), newType, typeScope, callResultType.inferenced);\n      const variants = [paramType, _type.Type.Undefined];\n      paramType = _unionType.UnionType.term(null, {}, variants);\n    }\n\n    if (isWithoutAnnotation && paramType === _type.Type.Unknown) {\n      const typeVar = (0, _typeUtils.addTypeVar)(typeVarNames[nameIndex + index], localTypeScope);\n\n      if (typeVar instanceof _typeVar.TypeVar) {\n        genericArguments.add(typeVar);\n      }\n\n      paramType = typeVar;\n    }\n\n    if (param.type === _nodes2.default.REST_ELEMENT) {\n      if (!isWithoutAnnotation && !(paramType instanceof _unionType.UnionType && paramType.variants.every(isValidRestArgumentType) || isValidRestArgumentType(paramType))) {\n        throw new _errors2.default(\"Rest argument type should be an array-like\", param.typeAnnotation.loc);\n      }\n\n      paramType = paramType instanceof _typeVar.TypeVar && !paramType.isUserDefined ? _type.Type.find(\"Array\").applyGeneric([_type.Type.Unknown]) : paramType;\n      paramType = _functionType.RestArgument.term(null, {}, paramType);\n    }\n\n    return paramType;\n  });\n  let throwableType;\n  let returnType = currentNode.returnType != undefined ? (0, _typeUtils.getTypeFromTypeAnnotation)(currentNode.returnType, localTypeScope, parentScope, false, // $FlowIssue\n  self, parentNode, typeGraph, pre, middle, post) : (0, _typeUtils.addTypeVar)(typeVarNames[nameIndex + argumentsTypes.length], localTypeScope);\n\n  if (currentNode.returnType == undefined) {\n    if (returnType instanceof _typeVar.TypeVar) {\n      genericArguments.add(returnType);\n    }\n  }\n\n  if (returnType instanceof _throwsType.$ThrowsResult || returnType instanceof _unionType.UnionType) {\n    if (returnType instanceof _unionType.UnionType) {\n      const [returnTypes, errors] = returnType.variants.reduce(([result, errors], type) => type instanceof _throwsType.$ThrowsResult ? [result, [...errors, type.errorType]] : [[...result, type], errors], [[], []]);\n\n      if (errors.length !== 0) {\n        returnType = _unionType.UnionType.term(null, {}, returnTypes);\n        throwableType = new _throwsType.$ThrowsResult(null, {}, _unionType.UnionType.term(null, {}, errors));\n      }\n    } else {\n      throwableType = returnType;\n      returnType = _type.Type.Undefined;\n    }\n  }\n\n  if (currentNode.async) {\n    const unknownPromise = _type.Type.Unknown.promisify();\n\n    if (!unknownPromise.isPrincipalTypeFor(returnType) && currentNode.returnType != undefined) {\n      throw new _errors2.default(`Return type of async function should be an promise`, currentNode.returnType.loc);\n    }\n  }\n\n  const genericArgumentsTypes = [...genericArguments];\n\n  const typeName = _functionType.FunctionType.getName(argumentsTypes, returnType, genericArgumentsTypes, currentNode.async, throwableType && throwableType.errorType);\n\n  const type = _functionType.FunctionType.term(typeName, {}, argumentsTypes, returnType);\n\n  type.isAsync = currentNode.async === true;\n  type.throwable = throwableType && throwableType.errorType;\n\n  if (genericArgumentsTypes.length === 0 || !(type instanceof _functionType.FunctionType)) {\n    return type;\n  }\n\n  return _genericType.GenericType.new(typeName, {}, genericArgumentsTypes, localTypeScope, type);\n}\n\nfunction getCallTarget(call, withClean = true) {\n  let callTargetType = call.target instanceof _variableInfo.VariableInfo ? call.target.type : call.target;\n\n  if (callTargetType instanceof _immutableType.$AppliedImmutable) {\n    callTargetType = callTargetType.readonly;\n  }\n\n  if (callTargetType instanceof _typeVar.TypeVar) {\n    callTargetType = _type.Type.getTypeRoot(callTargetType);\n  }\n\n  if (callTargetType instanceof _genericType.GenericType) {\n    callTargetType = getRawFunctionType(callTargetType, call.arguments, null, callTargetType.localTypeScope, call.loc, // $FlowIssue\n    withClean);\n  }\n\n  return callTargetType;\n}\n\nconst isArgumentVariable = x => {\n  const type = x instanceof _variableInfo.VariableInfo ? x.type : x;\n  return type instanceof _typeVar.TypeVar;\n};\n\nfunction resolveOuterTypeVarsFromCall(call, genericArguments, oldGenericArguments, typeScope, typeGraph) {\n  const callTarget = getCallTarget(call, false);\n\n  if (callTarget === undefined) {\n    return;\n  } // $FlowIssue\n\n\n  const level = oldGenericArguments[0];\n  const roots = new Map();\n\n  for (let i = 0; i < call.arguments.length; i++) {\n    const callArgument = call.arguments[i];\n    let actualType = callArgument instanceof _variableInfo.VariableInfo ? callArgument.type : callArgument;\n    let declaratedType = callTarget.argumentsTypes[i];\n\n    if (actualType === undefined || declaratedType === undefined) {\n      continue;\n    }\n\n    if (declaratedType instanceof _functionType.RestArgument) {\n      actualType = _tupleType.TupleType.term(null, {}, call.arguments.slice(i).map(a => a instanceof _variableInfo.VariableInfo ? a.type : a));\n      i = call.arguments.length;\n    }\n\n    actualType = _type.Type.getTypeRoot(actualType, true);\n    declaratedType = _type.Type.getTypeRoot(declaratedType); // $FlowIssue\n\n    let difference = declaratedType.parent.priority > actualType.parent.priority ? actualType.getDifference(declaratedType, true) : declaratedType.getDifference(actualType, true);\n\n    for (let j = 0; j < difference.length; j++) {\n      let {\n        root,\n        variable\n      } = difference[j];\n\n      if (_typeVar.TypeVar.isSelf(root)) {\n        continue;\n      }\n\n      root = _type.Type.getTypeRoot(root);\n      variable = _type.Type.getTypeRoot(variable, true);\n\n      if (!genericArguments.some(arg => arg.contains(variable)) || genericArguments.includes(variable) && variable.isUserDefined) {\n        continue;\n      }\n\n      const shouldSetNewRoot = variable instanceof _typeVar.TypeVar && !root.contains(variable) && (variable.constraint === undefined || variable.constraint.isPrincipalTypeFor(root)) && (variable.root === undefined || variable.root.isSuperTypeFor(variable.root));\n\n      if (!genericArguments.includes(variable)) {\n        genericArguments.push(variable);\n      }\n\n      if (!shouldSetNewRoot) {\n        continue;\n      }\n\n      variable.root = root;\n    }\n  }\n}\n\nfunction implicitApplyGeneric(fn, argumentsTypes, localTypeScope, loc, withClean = true, dropUnknown = false) {\n  const appliedArgumentsTypes = new Map();\n  const unreachableTypes = new Set();\n  const declaratedArgumentsTypes = fn.subordinateType.argumentsTypes;\n\n  for (let i = 0; i < declaratedArgumentsTypes.length; i++) {\n    const maybeBottom = declaratedArgumentsTypes[i];\n    const givenArgument = argumentsTypes[i] || _type.Type.Undefined;\n    let givenArgumentType = givenArgument instanceof _variableInfo.VariableInfo ? givenArgument.type : givenArgument;\n    let declaratedArgument = maybeBottom;\n    declaratedArgument = declaratedArgument instanceof _bottomType.$BottomType ? declaratedArgument.unpack() : declaratedArgument;\n    declaratedArgument = declaratedArgument instanceof _genericType.GenericType ? declaratedArgument.subordinateType : declaratedArgument;\n\n    if (declaratedArgument instanceof _functionType.RestArgument) {\n      givenArgumentType = _tupleType.TupleType.term(null, {}, argumentsTypes.slice(i).map(a => a instanceof _variableInfo.VariableInfo ? a.type : a));\n      declaratedArgument = declaratedArgument.type;\n    }\n\n    const difference = givenArgumentType.getDifference(declaratedArgument, true);\n\n    for (let j = 0; j < difference.length; j++) {\n      let {\n        root,\n        variable\n      } = difference[j];\n\n      if (_typeVar.TypeVar.isSelf(root)) {\n        continue;\n      }\n\n      root = _type.Type.getTypeRoot(root);\n      variable = _type.Type.getTypeRoot(variable); // $FlowIssue\n\n      variable = fn.genericArguments.find(arg => arg.equalsTo(variable));\n\n      if (variable === undefined) {\n        continue;\n      }\n\n      const existed = appliedArgumentsTypes.get(variable);\n      const shouldSetNewRoot = variable instanceof _typeVar.TypeVar && variable !== root && (existed === undefined || existed instanceof _typeVar.TypeVar || dropUnknown && existed === _type.Type.Unknown || !(root instanceof _typeVar.TypeVar && !root.isUserDefined) && root.isSuperTypeFor(existed));\n\n      if (!shouldSetNewRoot) {\n        const principal = existed && existed.findPrincipal(root);\n\n        if (principal === undefined) {\n          continue;\n        }\n\n        root = principal;\n      }\n\n      appliedArgumentsTypes.set(variable, root);\n    }\n\n    if (maybeBottom instanceof _bottomType.$BottomType) {\n      maybeBottom.unrootSubordinateType();\n    }\n  }\n\n  const rootFinder = t => {\n    const root = _type.Type.getTypeRoot(t);\n\n    let mainRoot = appliedArgumentsTypes.get(root);\n\n    while (appliedArgumentsTypes.has(mainRoot)) {\n      mainRoot = appliedArgumentsTypes.get(mainRoot);\n    }\n\n    return mainRoot;\n  };\n\n  const appliedParameters = fn.genericArguments.map(t => {\n    const resultType = rootFinder(t) || _type.Type.getTypeRoot(t);\n\n    if (resultType instanceof _typeVar.TypeVar && !(0, _typeUtils.isReachableType)(resultType, localTypeScope)) {\n      unreachableTypes.add(resultType);\n    }\n\n    if (resultType instanceof _typeVar.TypeVar && resultType === t && resultType.defaultType !== undefined) {\n      return rootFinder(resultType.defaultType) || _type.Type.getTypeRoot(resultType.defaultType);\n    }\n\n    return resultType;\n  });\n  const result = fn.applyGeneric(appliedParameters, loc).generalize([...unreachableTypes], localTypeScope);\n\n  if (withClean) {\n    fn.genericArguments.forEach(clearRoot);\n  }\n\n  return result;\n}\n\nconst invocationTypeNames = [\"_q\", \"_r\", \"_s\", \"_t\", \"_u\", \"_v\", \"_w\", \"_x\", \"_y\", \"_z\"];\nlet iterator = 0;\n\nfunction getRawFunctionType(fn, args, genericArguments, localTypeScope, loc, withClean = true, initializing = false, dropUnknown = false) {\n  fn = fn instanceof _typeVar.TypeVar && fn.root !== undefined ? _type.Type.getTypeRoot(fn) : fn;\n  fn = fn instanceof _bottomType.$BottomType ? fn.unpack(loc) : fn;\n\n  if (fn instanceof _functionType.FunctionType) {\n    return fn;\n  }\n\n  if (fn instanceof _typeVar.TypeVar) {\n    if (fn.isUserDefined) {\n      throw new Error(\"Never!\");\n    }\n\n    const argTypes = args.map(a => {\n      const result = a instanceof _variableInfo.VariableInfo ? a.type : a;\n\n      if (result instanceof _typeVar.TypeVar && !(0, _typeUtils.isReachableType)(result, fn.parent)) {\n        fn.parent.body.set(result.name, result);\n      }\n\n      return result;\n    });\n    const returnTypeName = invocationTypeNames[iterator];\n\n    const returnType = _typeVar.TypeVar.new(returnTypeName, {\n      parent: fn.parent\n    });\n\n    const newFunctionTypeName = _functionType.FunctionType.getName(argTypes, returnType, []);\n\n    const result = _functionType.FunctionType.term(newFunctionTypeName, {\n      parent: localTypeScope\n    }, argTypes, returnType);\n\n    fn.root = result;\n    return result;\n  }\n\n  let result = genericArguments != null ? // $FlowIssue\n  fn.applyGeneric(genericArguments, loc, true, false, initializing) : implicitApplyGeneric(fn, args, localTypeScope, loc, withClean, dropUnknown);\n\n  if (result instanceof _bottomType.$BottomType) {\n    result = result.unpack();\n  }\n\n  if (result instanceof _bottomType.$BottomType) {\n    result = result.subordinateMagicType;\n  }\n\n  if (result instanceof _genericType.GenericType) {\n    result = result.subordinateType;\n  }\n\n  return result;\n}\n\nfunction getInvocationType(fn, argumentsTypes, genericArguments, localTypeScope, loc, initializing = false, dropUnknown = false) {\n  let {\n    returnType\n  } = fn instanceof _functionType.FunctionType ? fn : getRawFunctionType(fn, argumentsTypes, genericArguments, localTypeScope, loc, true, initializing, dropUnknown);\n  returnType = returnType instanceof _typeVar.TypeVar ? _type.Type.getTypeRoot(returnType) : returnType;\n  returnType = returnType instanceof _bottomType.$BottomType && (returnType.genericArguments.every(t => !(t instanceof _typeVar.TypeVar)) || returnType.subordinateMagicType instanceof _propertyType.$PropertyType) ? returnType.unpack() : returnType;\n  return returnType instanceof _typeVar.TypeVar ? _type.Type.getTypeRoot(returnType) : returnType;\n}\n\nfunction clearRoot(type) {\n  type.root = undefined;\n}\n\nfunction prepareGenericFunctionType(functionScope) {\n  const {\n    genericArguments\n  } = functionScope.declaration.type;\n\n  for (let i = 0; i < genericArguments.length; i++) {\n    const genericArgument = genericArguments[i];\n\n    if (genericArgument instanceof _typeVar.TypeVar && genericArgument.isUserDefined) {\n      clearRoot(genericArgument);\n    }\n  }\n}\n\nfunction inferenceFunctionTypeByScope(functionScope, typeScope, typeGraph) {\n  const {\n    calls = []\n  } = functionScope;\n  const {\n    genericArguments: oldGenericArguments,\n    localTypeScope,\n    subordinateType: {\n      argumentsTypes,\n      returnType,\n      isAsync,\n      throwable\n    }\n  } = functionScope.declaration.type;\n  const genericArguments = [...oldGenericArguments];\n  let returnWasCalled = false;\n  let finalReturnWasCalled = false; // $FlowIssue\n\n  const nestedScopes = functionScope.getAllChildScopes(typeGraph);\n\n  for (const {\n    calls\n  } of nestedScopes) {\n    for (let i = 0; i < calls.length; i++) {\n      resolveOuterTypeVarsFromCall(calls[i], genericArguments, oldGenericArguments, localTypeScope, typeGraph);\n    }\n  }\n\n  for (let i = 0; i < calls.length; i++) {\n    const call = calls[i];\n\n    if (call.isFinal) {\n      finalReturnWasCalled = true;\n    }\n\n    if (call.targetName === \"return\" && returnType instanceof _typeVar.TypeVar && !returnType.isUserDefined) {\n      returnWasCalled = true;\n      const {\n        arguments: [returnArgument],\n        inferenced\n      } = call;\n      const newReturnType = returnArgument instanceof _variableInfo.VariableInfo ? returnArgument.type : returnArgument;\n      const newOneRoot = (0, _variableUtils.getVariableType)(undefined, newReturnType instanceof _typeVar.TypeVar ? _type.Type.getTypeRoot(newReturnType) : newReturnType, typeScope, inferenced);\n\n      if (newOneRoot === returnType) {\n        continue;\n      }\n\n      const oldRoot = _type.Type.getTypeRoot(returnType);\n\n      if (returnType.root === undefined || newOneRoot.isPrincipalTypeFor(oldRoot)) {\n        returnType.root = newOneRoot;\n      } else if (!oldRoot.isPrincipalTypeFor(newOneRoot)) {\n        const variants = (oldRoot instanceof _unionType.UnionType ? oldRoot.variants : [oldRoot]).concat([newOneRoot]);\n        returnType.root = _unionType.UnionType.term(null, {}, variants);\n      }\n    }\n  }\n\n  if (!returnWasCalled && returnType instanceof _typeVar.TypeVar && !returnType.isUserDefined) {\n    returnType.root = isAsync ? _type.Type.Undefined.promisify() : _type.Type.Undefined;\n  }\n\n  if (returnWasCalled && !finalReturnWasCalled && returnType instanceof _typeVar.TypeVar && !returnType.isUserDefined) {\n    const variants = returnType.root !== undefined ? [_type.Type.getTypeRoot(returnType)] : [];\n    returnType.root = _unionType.UnionType.term(null, {}, [...variants, isAsync ? _type.Type.Undefined.promisify() : _type.Type.Undefined]);\n  }\n\n  const created = new Map();\n\n  for (let i = 0; i < genericArguments.length; i++) {\n    const genericArg = genericArguments[i];\n\n    const root = _type.Type.getTypeRoot(genericArg);\n\n    if (root instanceof _typeVar.TypeVar && !genericArguments.includes(root)) {\n      const alreadyCreated = created.get(root);\n      const newRoot = alreadyCreated !== undefined ? alreadyCreated : Object.assign(new _typeVar.TypeVar(\"\"), root, {\n        isUserDefined: false\n      });\n      genericArg.root = newRoot;\n\n      if (alreadyCreated === undefined) {\n        created.set(root, newRoot);\n      }\n    }\n  }\n\n  const [allVars, allRoots] = genericArguments.reduce(([vars, roots], t) => t.root !== undefined ? [vars.concat([t]), roots.concat([_type.Type.getTypeRoot(t)])] : [vars, roots], [[], []]);\n\n  for (const scope of nestedScopes) {\n    for (const [_, v] of scope.body) {\n      if (v.type instanceof _typeVar.TypeVar && v.type.root != undefined) {\n        v.type = _type.Type.getTypeRoot(v.type);\n      } else {\n        // $FlowIssue\n        v.type = v.type.changeAll(allVars, allRoots);\n      }\n    }\n  }\n\n  let newGenericArguments = new Set();\n  const newArgumentsTypes = argumentsTypes.map(t => {\n    let result = t instanceof _typeVar.TypeVar && t.root != undefined ? _type.Type.getTypeRoot(t) : t; // $FlowIssue\n\n    result = result.changeAll(allVars, allRoots, typeScope);\n\n    if (result instanceof _typeVar.TypeVar && // $FlowIssue\n    !(0, _typeUtils.isReachableType)(result, localTypeScope.parent)) {\n      newGenericArguments.add(result);\n    }\n\n    return result;\n  });\n  let newReturnType = returnType instanceof _typeVar.TypeVar && returnType.root != undefined ? _type.Type.getTypeRoot(returnType) : returnType;\n  newReturnType = newReturnType.changeAll(allVars, allRoots, typeScope);\n\n  if (newReturnType instanceof _typeVar.TypeVar) {\n    newGenericArguments.add(newReturnType);\n  }\n\n  const shouldBeCleaned = [];\n\n  for (const {\n    calls\n  } of nestedScopes) {\n    for (let i = 0; i < calls.length; i++) {\n      const call = calls[i];\n      const args = call.arguments;\n      const target = call.target;\n      const targetType = target instanceof _variableInfo.VariableInfo ? target.type : target;\n\n      for (let j = 0; j < args.length; j++) {\n        const argument = args[j];\n        const argumentType = argument instanceof _variableInfo.VariableInfo ? argument.type : argument;\n\n        if (!(argumentType instanceof _typeVar.TypeVar)) {\n          if (argument instanceof _type.Type) {\n            args[j] = argument.changeAll(allVars, allRoots, typeScope);\n          }\n\n          continue;\n        }\n\n        const copy = created.get(argumentType);\n\n        if (argumentType.root !== undefined) {\n          args[j] = _type.Type.getTypeRoot(argumentType);\n\n          if (oldGenericArguments.includes(argumentType) && argumentType.isUserDefined) {\n            shouldBeCleaned.push(argumentType);\n          }\n        } else if (copy !== undefined) {\n          args[j] = copy;\n\n          if (call.targetName === \"return\" && call.target instanceof _functionType.FunctionType) {\n            // $FlowIssue\n            call.target = targetType.changeAll([argumentType], [copy], typeScope);\n          }\n        }\n      }\n\n      if (targetType instanceof _genericType.GenericType) {\n        targetType.genericArguments.forEach(a => a.isUserDefined && shouldBeCleaned.push(a));\n      }\n    }\n  }\n\n  for (let i = 0; i < oldGenericArguments.length; i++) {\n    const genericArgument = oldGenericArguments[i];\n\n    if (genericArgument.isUserDefined) {\n      newGenericArguments.add(genericArgument);\n      continue;\n    }\n\n    const oldRoot = _type.Type.getTypeRoot(genericArgument);\n\n    clearRoot(genericArgument);\n    const isTypeVarStillExisted = newArgumentsTypes.find(arg => arg.contains(genericArgument) && !(0, _typeUtils.isReachableType)(arg, localTypeScope.parent));\n\n    if (isTypeVarStillExisted && genericArgument instanceof _typeVar.TypeVar) {\n      newGenericArguments.add(genericArgument);\n    }\n\n    if (genericArgument instanceof _typeVar.TypeVar && !genericArgument.isUserDefined && genericArgument !== oldRoot) {\n      genericArgument.root = oldRoot;\n    }\n  }\n\n  for (let i = 0; i < genericArguments.length; i++) {\n    const genericArgument = genericArguments[i];\n\n    const root = _type.Type.getTypeRoot(genericArgument.changeAll(allVars, allRoots, localTypeScope));\n\n    if (!(root instanceof _typeVar.TypeVar) || oldGenericArguments.some(a => root.equalsTo(a, true) || genericArgument.equalsTo(a, true))) {\n      continue;\n    }\n\n    newGenericArguments.add(root);\n  }\n\n  shouldBeCleaned.forEach(clearRoot);\n  const newGenericArgumentsTypes = [...newGenericArguments].filter(t => !(0, _typeUtils.isReachableType)(t, localTypeScope.parent)).map(t => {\n    t.isUserDefined = true;\n    return t;\n  });\n\n  const newFunctionTypeName = _functionType.FunctionType.getName(newArgumentsTypes, newReturnType, newGenericArgumentsTypes, isAsync, throwable);\n\n  let newFunctionType = _functionType.FunctionType.term(newFunctionTypeName, {}, newArgumentsTypes, newReturnType, isAsync);\n\n  if (newFunctionType instanceof _functionType.FunctionType && newFunctionType.throwble === undefined) {\n    newFunctionType.throwable = throwable;\n  }\n\n  if (newGenericArgumentsTypes.length > 0) {\n    newFunctionType = _genericType.GenericType.new(newFunctionTypeName, {}, newGenericArgumentsTypes, localTypeScope, newFunctionType);\n  } // $FlowIssue\n\n\n  functionScope.declaration.type = newFunctionType;\n}\n\nfunction isGenericFunctionType(type) {\n  return type instanceof _genericType.GenericType && type.subordinateType instanceof _functionType.FunctionType;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inRefinement = inRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _common = require(\"../utils/common\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inIdentifier(targetNode, currentScope, typeScope, propertyName, refinementNode) {\n  const variable = currentScope.findVariable(targetNode);\n  const type = variable.type;\n\n  if (type instanceof _unionType.UnionType) {\n    const [refinementedVariants, alternateVariants] = type.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n      if (variant instanceof _objectType.ObjectType && variant.getPropertyType(propertyName)) {\n        return [refinementedVariants.concat([variant]), alternateVariants];\n      }\n\n      return [refinementedVariants, alternateVariants.concat([variant])];\n    }, [[], []]);\n    return [targetNode.name, ...(0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope)];\n  }\n\n  if (type instanceof _objectType.ObjectType && !type.isStrict && type.getPropertyType(targetNode.name) === null) {\n    return [targetNode.name, _objectType.ObjectType.term(null, {\n      isSoft: true\n    }, [...type.properties, [propertyName, new _variableInfo.VariableInfo(_type.Type.Unknown, currentScope)]]), type];\n  }\n}\n\nfunction refinementProperty(variableName, variableType, propertyName, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) {\n  const currentPropertyName = chainingProperties[currentPropertyNameIndex];\n  const isLast = currentPropertyNameIndex === chainingProperties.length - 1;\n\n  if (variableType instanceof _objectType.ObjectType) {\n    const property = variableType.properties.get(currentPropertyName);\n\n    if (property === undefined) {\n      return;\n    }\n\n    const propertyType = property.type;\n\n    if (isLast) {\n      if (!(propertyType instanceof _unionType.UnionType) && !(propertyType instanceof _objectType.ObjectType)) {\n        throw new _errors2.default(`Property has not \"${propertyName}\" property`, refinementNode.loc);\n      }\n\n      if (propertyType instanceof _objectType.ObjectType) {\n        const existed = propertyType.getPropertyType(propertyName);\n\n        if (!propertyType.isStrict && !existed) {\n          return [(0, _typeUtils.mergeObjectsTypes)(propertyType, (0, _typeUtils.createObjectWith)(propertyName, _type.Type.Unknown, typeScope), typeScope), property.type];\n        }\n\n        return existed ? [propertyType, undefined] : [undefined, propertyType];\n      }\n\n      const [refinementedVariants, alternateVariants] = propertyType.variants.reduce(([refinementedVariants, alternateVariants], variant) => variant instanceof _objectType.ObjectType && variant.getPropertyType(propertyName) ? [refinementedVariants.concat([variant]), alternateVariants] : [refinementedVariants, alternateVariants.concat([variant])], [[], []]);\n      const refinement = (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n      return (0, _inferenceUtils.mergeRefinementsVariants)(refinement[0], refinement[1], new _variableInfo.VariableInfo(_objectType.ObjectType.term(\"{ }\", {}, []), property.parent, property.meta), currentPropertyName, typeScope);\n    }\n\n    return refinementProperty(variableName, property.type, propertyName, refinementNode, currentPropertyNameIndex + 1, chainingProperties, typeScope);\n  }\n\n  if (variableType instanceof _unionType.UnionType) {\n    const [refinementedVariants, alternateVariants] = variableType.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n      const isNotAlternateVariant = variant instanceof _objectType.ObjectType && variant.getPropertyType(currentPropertyName);\n      const refinementedTypeAndAlternateType = isNotAlternateVariant ? refinementProperty(variableName, variant, propertyName, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) : undefined;\n\n      if (!refinementedTypeAndAlternateType) {\n        return [refinementedVariants, alternateVariants.concat([variant])];\n      }\n\n      const [refinementedType, alternateType] = refinementedTypeAndAlternateType;\n      return [refinementedType ? refinementedVariants.concat([(0, _typeUtils.mergeObjectsTypes)(variant, (0, _typeUtils.createObjectWith)(currentPropertyName, refinementedType, typeScope), typeScope)]) : refinementedVariants, alternateType ? alternateVariants.concat([(0, _typeUtils.mergeObjectsTypes)(variant, (0, _typeUtils.createObjectWith)(currentPropertyName, alternateType, typeScope), typeScope)]) : alternateVariants];\n    }, [[], []]);\n    return (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n  }\n}\n\nfunction inProperty(targetNode, currentScope, typeScope, propertyName, refinementNode) {\n  const targetObject = (0, _common.getMemberExressionTarget)(targetNode);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(targetNode);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !targetVariableInfo || !propertiesChaining || targetVariableInfo instanceof _variableScope.VariableScope) {\n    return;\n  }\n\n  const refinmentedAndAlternate = refinementProperty(variableName, targetVariableInfo.type, propertyName, refinementNode, 0, propertiesChaining, typeScope);\n\n  if (!refinmentedAndAlternate) {\n    return;\n  }\n\n  if (!refinmentedAndAlternate[0] || !refinmentedAndAlternate[1]) {\n    throw new _errors2.default(`Property always ${refinmentedAndAlternate[0] === undefined ? \"has not\" : \"has\"} property \"${propertyName}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinmentedAndAlternate[0], refinmentedAndAlternate[1]];\n}\n\nfunction inRefinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  if (currentRefinementNode.left.type !== _nodes2.default.STRING_LITERAL || currentRefinementNode.right.type !== _nodes2.default.IDENTIFIER && currentRefinementNode.right.type !== _nodes2.default.MEMBER_EXPRESSION) {\n    return;\n  }\n\n  const {\n    left: propertyNameNode,\n    right: targetNode\n  } = currentRefinementNode;\n  const propertyName = propertyNameNode.value;\n  let refinementedType, alternateType, name;\n\n  if (currentRefinementNode.right.type === _nodes2.default.IDENTIFIER) {\n    const result = inIdentifier(currentRefinementNode.right, currentScope, typeScope, propertyName, currentRefinementNode);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  if (currentRefinementNode.right.type === _nodes2.default.MEMBER_EXPRESSION) {\n    const result = inProperty(currentRefinementNode.right, currentScope, typeScope, propertyName, currentRefinementNode);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  return name && refinementedType && alternateType ? [name, refinementedType, alternateType] : undefined;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferenceTypeForNode = inferenceTypeForNode;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _functionType = require(\"./function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction inferenceTypeForNode(currentNode, typeScope, parentScope, typeGraph, parentNode, pre, middle, post, isTypeDefinitions = false, isImmutable = false) {\n  let result = null;\n\n  switch (currentNode.type) {\n    case _nodes2.default.NUMERIC_LITERAL:\n      result = _type.Type.term(currentNode.value, {\n        isSubtypeOf: _type.Type.Number\n      });\n      break;\n\n    case _nodes2.default.BIGINT_LITERAL:\n      result = _type.Type.term(`${currentNode.value}n`, {\n        isSubtypeOf: _type.Type.BigInt\n      });\n      break;\n\n    case _nodes2.default.TEMPLATE_LITERAL:\n      result = _type.Type.String;\n      break;\n\n    case _nodes2.default.STRING_LITERAL:\n      result = _type.Type.term(`'${currentNode.value}'`, {\n        isSubtypeOf: _type.Type.String\n      });\n      break;\n\n    case _nodes2.default.BOOLEAN_LITERAL:\n      result = _type.Type.term(currentNode.value);\n      break;\n\n    case _nodes2.default.NULL_LITERAL:\n      result = _type.Type.Null;\n      break;\n\n    case _nodes2.default.REG_EXP_LITERAL:\n      result = _type.Type.find(\"RegExp\");\n      break;\n\n    case _nodes2.default.ARRAY_EXPRESSION:\n      result = (0, _tupleType.inferenceTupleType)(currentNode, typeScope, parentScope, typeGraph, parentNode, pre, middle, post);\n      break;\n\n    case _nodes2.default.OBJECT_EXPRESSION:\n    case _nodes2.default.CLASS_EXPRESSION:\n      const objectScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n      if (objectScope === undefined) {\n        throw new Error(\"Never!!!\");\n      }\n\n      const self = objectScope.type === _variableScope.VariableScope.OBJECT_TYPE ? objectScope.body.get(_constants.THIS_TYPE) : objectScope.declaration;\n\n      if (!(self instanceof _variableInfo.VariableInfo)) {\n        throw new Error(\"Never!!!\");\n      }\n\n      result = self.type;\n      break;\n\n    case _nodes2.default.OBJECT_METHOD:\n    case _nodes2.default.CLASS_METHOD:\n    case _nodes2.default.CLASS_PRIVATE_METHOD:\n    case _nodes2.default.FUNCTION_DECLARATION:\n    case _nodes2.default.TS_DECLARE_METHOD:\n    case _nodes2.default.FUNCTION_EXPRESSION:\n    case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n    case _nodes2.default.TS_FUNCTION_DECLARATION:\n      result = (0, _functionType.inferenceFunctionLiteralType)(currentNode, typeScope, parentScope, typeGraph, isTypeDefinitions, parentNode, pre, middle, post);\n      break;\n\n    case _nodes2.default.IDENTIFIER:\n    case _nodes2.default.THIS_EXPRESSION:\n      const query = { ...currentNode,\n        name: currentNode.name || _constants.THIS_TYPE\n      };\n      const variableInfo = parentScope.findVariable(query);\n      result = variableInfo.type;\n      break;\n  }\n\n  if (isImmutable && result !== null && currentNode.type !== _nodes2.default.IDENTIFIER && currentNode.type !== _nodes2.default.THIS_EXPRESSION) {\n    result = _immutableType.$AppliedImmutable.term(null, {}, result);\n  }\n\n  if (result) {\n    return result;\n  }\n\n  throw new Error(currentNode.type);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instanceofRefinement = instanceofRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _common = require(\"../utils/common\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction instanceofIdentifier(targetNode, constructor, currentScope, typeScope, refinementNode) {\n  const variable = currentScope.findVariable(targetNode);\n  const type = variable.type;\n\n  if (!(type instanceof _unionType.UnionType) && type !== _type.Type.Unknown && !(type instanceof _typeVar.TypeVar) && !type.isPrincipalTypeFor(constructor)) {\n    throw new _errors2.default(`Variable can't be an instance of \"${refinementNode.right.name}\"`, refinementNode.loc);\n  }\n\n  if (type.equalsTo(constructor)) {\n    throw new _errors2.default(`Variable is always instance of \"${refinementNode.right.name}\"`, refinementNode.loc);\n  }\n\n  if (type === _type.Type.Unknown || !(type instanceof _unionType.UnionType)) {\n    return [targetNode.name, constructor, type];\n  } // $FlowIssue\n\n\n  const [refinementedVariants, alternateVariants] = type.variants.reduce(([refinementedVariants, alternateVariants], variant) => constructor.isPrincipalTypeFor(variant) ? [refinementedVariants.concat([variant]), alternateVariants] : [refinementedVariants, alternateVariants.concat([variant])], [[], []]);\n  return [targetNode.name, ...(0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope)];\n}\n\nfunction refinementProperty(variableName, variableType, constructor, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) {\n  const currentPropertyName = chainingProperties[currentPropertyNameIndex];\n  const isLast = currentPropertyNameIndex === chainingProperties.length - 1;\n\n  if (variableType instanceof _objectType.ObjectType) {\n    const property = variableType.properties.get(currentPropertyName);\n\n    if (property === undefined) {\n      return;\n    }\n\n    if (isLast) {\n      if (!(property.type instanceof _unionType.UnionType)) {\n        return constructor.isPrincipalTypeFor(property.type) ? [property.type, undefined] : [undefined, property.type];\n      }\n\n      const [refinementedVariants, alternateVariants] = property.type.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n        const refinmentedProperty = variant instanceof _objectType.ObjectType ? variant.properties.get(currentPropertyName) : undefined;\n        return refinmentedProperty && constructor.isSuperTypeFor(refinementProperty.type) ? [refinementedVariants.concat([variant]), alternateVariants] : [refinementedVariants, alternateVariants.concat([variant])];\n      }, [[], []]);\n      return (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n    }\n\n    return refinementProperty(variableName, property.type, constructor, refinementNode, currentPropertyNameIndex + 1, chainingProperties, typeScope);\n  }\n\n  if (variableType instanceof _unionType.UnionType) {\n    const [refinementedVariants, alternateVariants] = variableType.variants.reduce(([refinementedVariants, alternateVariants], variant) => {\n      const isNotAlternateVariant = variant instanceof _objectType.ObjectType && variant.getPropertyType(currentPropertyName);\n      const refinementedTypeAndAlternateType = isNotAlternateVariant ? refinementProperty(variableName, variant, constructor, refinementNode, currentPropertyNameIndex, chainingProperties, typeScope) : undefined;\n\n      if (!refinementedTypeAndAlternateType) {\n        return [refinementedVariants, alternateVariants.concat([variant])];\n      }\n\n      const [refinementedType, alternateType] = refinementedTypeAndAlternateType;\n      return [refinementedType ? refinementedVariants.concat([(0, _typeUtils.mergeObjectsTypes)(variant, (0, _typeUtils.createObjectWith)(currentPropertyName, refinementedType, typeScope), typeScope)]) : refinementedVariants, alternateType ? alternateVariants.concat([(0, _typeUtils.mergeObjectsTypes)(variant, (0, _typeUtils.createObjectWith)(currentPropertyName, alternateType, typeScope), typeScope)]) : alternateVariants];\n    }, [[], []]);\n    return (0, _inferenceUtils.getTypesFromVariants)(refinementedVariants, alternateVariants, typeScope);\n  }\n}\n\nfunction instanceofProperty(targetNode, constructor, currentScope, typeScope, refinementNode) {\n  const targetObject = (0, _common.getMemberExressionTarget)(targetNode);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(targetNode);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !targetVariableInfo || !propertiesChaining || targetVariableInfo instanceof _variableScope.VariableScope) {\n    return;\n  }\n\n  const refinmentedAndAlternate = refinementProperty(variableName, targetVariableInfo.type, constructor, refinementNode, 0, propertiesChaining, typeScope);\n\n  if (!refinmentedAndAlternate) {\n    return;\n  }\n\n  if (!refinmentedAndAlternate[0] || !refinmentedAndAlternate[1]) {\n    throw new _errors2.default(`Property ${refinmentedAndAlternate[0] === undefined ? \"can't be\" : \"is always\"} instance of \"${refinementNode.right.name}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinmentedAndAlternate[0], refinmentedAndAlternate[1]];\n}\n\nfunction instanceofRefinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  const {\n    left: target,\n    right: constructorNode\n  } = currentRefinementNode;\n\n  if (target.type !== _nodes2.default.IDENTIFIER && target.type !== _nodes2.default.MEMBER_EXPRESSION || constructorNode.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const constructor = currentScope.findVariable(constructorNode);\n\n  if (!(constructor.type instanceof _objectType.ObjectType && constructor.type.instanceType !== null)) {\n    throw new _errors2.default(\"Cannot apply instanceof to non-class type\", constructorNode.loc);\n  }\n\n  const instanceType = constructor.type.instanceType;\n  let refinementedType, alternateType, name;\n\n  if (target.type === _nodes2.default.IDENTIFIER) {\n    [name, refinementedType, alternateType] = instanceofIdentifier(target, instanceType, currentScope, typeScope, currentRefinementNode);\n  }\n\n  if (target.type === _nodes2.default.MEMBER_EXPRESSION) {\n    const result = instanceofProperty(target, instanceType, currentScope, typeScope, currentRefinementNode);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  return name && refinementedType && alternateType ? [name, refinementedType, alternateType] : undefined;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.refinement = refinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _refinementedType = require(\"../type-graph/types/refinemented-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _inOperator = require(\"./in-operator\");\n\nvar _equalsRefinement = require(\"./equals-refinement\");\n\nvar _typeof = require(\"./typeof\");\n\nvar _variableRefinement = require(\"./variable-refinement\");\n\nvar _common = require(\"../utils/common\");\n\nvar _instanceof = require(\"./instanceof\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getScopesForLogicalExpression(condition, currentScope, moduleScope) {\n  const primaryScopeName = _variableScope.VariableScope.getName({\n    loc: {\n      start: condition.loc.end\n    }\n  }); // $FlowIssue\n\n\n  let primaryScope = moduleScope.scopes.get(primaryScopeName);\n\n  if (!(primaryScope instanceof _variableScope.VariableScope)) {\n    primaryScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(primaryScopeName, primaryScope);\n  }\n\n  const alternateScopeName = _variableScope.VariableScope.getName({\n    loc: {\n      start: condition.loc.start\n    }\n  }); // $FlowIssue\n\n\n  let alternateScope = moduleScope.scopes.get(alternateScopeName);\n\n  if (!(alternateScope instanceof _variableScope.VariableScope)) {\n    alternateScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(alternateScopeName, alternateScope);\n  }\n\n  return condition.operator === \"&&\" ? [primaryScope, alternateScope] : [alternateScope, primaryScope];\n}\n\nfunction getScopesForSwitchCase(condition, currentScope, moduleScope) {\n  const primaryScopeName = _variableScope.VariableScope.getName(condition.consequent); // $FlowIssue\n\n\n  let primaryScope = moduleScope.scopes.get(primaryScopeName);\n\n  if (!(primaryScope instanceof _variableScope.VariableScope)) {\n    primaryScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(primaryScopeName, primaryScope);\n  }\n\n  const currentCaseIndex = condition.parent.cases.indexOf(condition);\n\n  if (currentCaseIndex === -1) {\n    return [primaryScope, []];\n  }\n\n  const alternateScopes = [];\n\n  for (let i = currentCaseIndex + 1; i < condition.parent.cases.length; i++) {\n    const $case = condition.parent.cases[i];\n\n    const alternateScopeName = _variableScope.VariableScope.getName($case.consequent); // $FlowIssue\n\n\n    let alternateScope = moduleScope.scopes.get(alternateScopeName);\n\n    if (!(alternateScope instanceof _variableScope.VariableScope)) {\n      alternateScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n      moduleScope.scopes.set(alternateScopeName, alternateScope);\n    }\n\n    alternateScopes.push(alternateScope);\n  }\n\n  return [primaryScope, alternateScopes];\n}\n\nfunction getScopesForConditionalExpression(condition, currentScope, moduleScope) {\n  const primaryScopeName = _variableScope.VariableScope.getName({\n    loc: {\n      start: condition.loc.start\n    }\n  }); // $FlowIssue\n\n\n  let primaryScope = moduleScope.scopes.get(primaryScopeName);\n\n  if (!(primaryScope instanceof _variableScope.VariableScope)) {\n    primaryScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(primaryScopeName, primaryScope);\n  }\n\n  const alternateScopeName = _variableScope.VariableScope.getName({\n    loc: {\n      start: condition.loc.end\n    }\n  }); // $FlowIssue\n\n\n  let alternateScope = moduleScope.scopes.get(alternateScopeName);\n\n  if (!(alternateScope instanceof _variableScope.VariableScope)) {\n    alternateScope = new _variableScope.VariableScope(_variableScope.VariableScope.BLOCK_TYPE, currentScope);\n    moduleScope.scopes.set(alternateScopeName, alternateScope);\n  }\n\n  return [primaryScope, alternateScope];\n}\n\nfunction getPrimaryAndAlternativeScopes(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  let primaryScope;\n  let alternateScope;\n\n  switch (currentRefinementNode.type) {\n    case _nodes2.default.IF_STATEMENT:\n      primaryScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentRefinementNode.consequent));\n      alternateScope = currentRefinementNode.alternate && moduleScope.scopes.get(_variableScope.VariableScope.getName(currentRefinementNode.alternate));\n      break;\n\n    case _nodes2.default.WHILE_STATEMENT:\n    case _nodes2.default.DO_WHILE_STATEMENT:\n    case _nodes2.default.FOR_STATEMENT:\n      primaryScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentRefinementNode.body));\n      break;\n\n    case _nodes2.default.LOGICAL_EXPRESSION:\n      [primaryScope, alternateScope] = getScopesForLogicalExpression(currentRefinementNode, currentScope, moduleScope);\n      break;\n\n    case _nodes2.default.CONDITIONAL_EXPRESSION:\n      [primaryScope, alternateScope] = getScopesForConditionalExpression(currentRefinementNode, currentScope, moduleScope);\n      break;\n\n    case _nodes2.default.SWITCH_CASE:\n      [primaryScope, alternateScope] = getScopesForSwitchCase(currentRefinementNode, currentScope, moduleScope);\n      break;\n  }\n\n  if (!primaryScope || primaryScope instanceof _variableInfo.VariableInfo || alternateScope instanceof _variableInfo.VariableInfo) {\n    throw new Error(\"Never!\");\n  }\n\n  return [primaryScope, alternateScope];\n}\n\nfunction getCondition(currentRefinementNode) {\n  switch (currentRefinementNode.type) {\n    case _nodes2.default.IF_STATEMENT:\n    case _nodes2.default.CONDITIONAL_EXPRESSION:\n    case _nodes2.default.WHILE_STATEMENT:\n    case _nodes2.default.DO_WHILE_STATEMENT:\n    case _nodes2.default.FOR_STATEMENT:\n      return currentRefinementNode.test;\n\n    case _nodes2.default.LOGICAL_EXPRESSION:\n    case _nodes2.default.SWITCH_CASE:\n      return currentRefinementNode;\n  }\n}\n\nfunction intersectionOfTypes(type1, type2, typeScope) {\n  if (type1 instanceof _unionType.UnionType && type2 instanceof _unionType.UnionType) {\n    const intersectedVariants = (0, _common.intersection)(type1.variants, type2.variants, (a, b) => a.equalsTo(b))[0];\n    return _unionType.UnionType.term(null, {}, intersectedVariants);\n  }\n\n  if (type1 instanceof _unionType.UnionType || type2 instanceof _unionType.UnionType) {\n    // $FlowIssue\n    const [unionType, notUnion] = // $FlowIssue\n    type1 instanceof _unionType.UnionType ? [type1, type2] : [type2, type1];\n    const isTypeExisting = unionType.variants.some(t => t.equalsTo(notUnion));\n    return isTypeExisting ? notUnion : _type.Type.Never;\n  }\n\n  return type1;\n}\n\nfunction unionOfTypes(type1, type2, typeScope) {\n  if (type1 instanceof _unionType.UnionType && type2 instanceof _unionType.UnionType) {\n    const unionVariants = (0, _common.union)(type1.variants, type2.variants, (a, b) => a.equalsTo(b));\n    return _unionType.UnionType.term(null, {}, unionVariants);\n  }\n\n  if (type1 instanceof _unionType.UnionType || type2 instanceof _unionType.UnionType) {\n    const [unionType, notUnion] = type1 instanceof _unionType.UnionType ? [type1, type2] : [type2, type1];\n    const newVariants = (0, _common.union)( // $FlowIssue\n    unionType.variants, [notUnion], (a, b) => a.equalsTo(b));\n    return _unionType.UnionType.term(null, {}, newVariants);\n  }\n\n  if (type1.isPrincipalTypeFor(type2)) {\n    return type1;\n  }\n\n  if (type2.isPrincipalTypeFor(type1)) {\n    return type2;\n  }\n\n  const variants = [type1, type2];\n  return _unionType.UnionType.term(null, {}, variants);\n}\n\nfunction getRefinementByBinaryExpression(binaryExpression, currentScope, typeScope, moduleScope) {\n  switch (binaryExpression.operator) {\n    case \"==\":\n    case \"!=\":\n    case \"===\":\n    case \"!==\":\n      return (0, _typeof.typeofRefinement)(binaryExpression, currentScope, typeScope, moduleScope);\n\n    case \"in\":\n      return (0, _inOperator.inRefinement)(binaryExpression, currentScope, typeScope, moduleScope);\n\n    case \"instanceof\":\n      return (0, _instanceof.instanceofRefinement)(binaryExpression, currentScope, typeScope, moduleScope);\n  }\n}\n\nfunction refinementByCondition(condition, currentScope, typeScope, moduleScope, primaryScope) {\n  switch (condition.type) {\n    case _nodes2.default.SWITCH_CASE:\n      const caseRefinement = (0, _equalsRefinement.equalsRefinement)(condition, primaryScope, typeScope, moduleScope);\n      const indexOfCurrentCase = condition.parent.cases.indexOf(condition);\n      const previousCase = indexOfCurrentCase > 0 ? condition.parent.cases[indexOfCurrentCase - 1] : undefined;\n\n      if (caseRefinement && previousCase && !previousCase.consequent.body.some(a => a.type === _nodes2.default.BREAK_STATEMENT || a.type === _nodes2.default.THROW_STATEMENT || a.type === _nodes2.default.RETURN_STATEMENT)) {\n        const [name, primary, alternate] = caseRefinement;\n        const previousCaseScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(previousCase.consequent));\n\n        if (previousCaseScope === undefined) {\n          throw new Error(\"Never!!!\");\n        }\n\n        const previousPrimaryRefinement = previousCaseScope.body.get(name);\n\n        if (previousPrimaryRefinement === undefined) {\n          return;\n        }\n\n        return [[name, _unionType.UnionType.term(null, {}, [primary, previousPrimaryRefinement.type]), alternate]];\n      }\n\n      return caseRefinement && [caseRefinement];\n\n    case _nodes2.default.UNARY_EXPRESSION:\n      if (condition.operator === \"!\") {\n        const refinements = refinementByCondition(condition.argument, currentScope, typeScope, moduleScope, primaryScope);\n        return refinements && refinements.map(refinement => refinement && [refinement[0], refinement[2], refinement[1]]);\n      }\n\n    case _nodes2.default.BINARY_EXPRESSION:\n      const typeofResult = getRefinementByBinaryExpression(condition, currentScope, typeScope, moduleScope);\n      return typeofResult && [typeofResult];\n\n    case _nodes2.default.IDENTIFIER:\n    case _nodes2.default.MEMBER_EXPRESSION:\n      const refinemented = (0, _variableRefinement.variableRefinement)(condition, currentScope, typeScope, moduleScope);\n      return refinemented && [refinemented];\n\n    case _nodes2.default.LOGICAL_EXPRESSION:\n      const [additionalPrimaryScope, additionalAlternateScope] = getScopesForLogicalExpression(condition, currentScope, moduleScope);\n      const leftSideRefinement = refinementByCondition(condition.left.body || condition.left, currentScope, typeScope, moduleScope, primaryScope);\n\n      if (leftSideRefinement) {\n        leftSideRefinement.forEach(([key, refinement, alternate]) => {\n          if (refinement !== undefined && !additionalPrimaryScope.body.has(key)) {\n            additionalPrimaryScope.body.set(key, new _variableInfo.VariableInfo(refinement, additionalPrimaryScope));\n          }\n\n          if (alternate !== undefined && !additionalAlternateScope.body.has(key)) {\n            additionalAlternateScope.body.set(key, new _variableInfo.VariableInfo(alternate, additionalAlternateScope));\n          }\n        });\n      }\n\n      const rightSideRefinement = refinementByCondition(condition.right.body || condition.right, condition.operator === \"||\" ? additionalAlternateScope : additionalPrimaryScope, typeScope, moduleScope, primaryScope);\n\n      if (!leftSideRefinement || !rightSideRefinement) {\n        return condition.operator === \"&&\" ? leftSideRefinement : rightSideRefinement;\n      }\n\n      const [sameRefinement, other] = (0, _common.intersection)(leftSideRefinement, rightSideRefinement, (a, b) => a[0] === b[0]);\n\n      if (sameRefinement.length === 0) {\n        return other;\n      }\n\n      const sameRefinementVariants = sameRefinement.map(([key, refinementedType, alternateType]) => {\n        const sameRefinement = leftSideRefinement.find(a => a[0] === key);\n\n        if (sameRefinement === undefined) {\n          return [key, refinementedType, alternateType];\n        }\n\n        if (condition.operator === \"||\" && sameRefinement[1] !== undefined && sameRefinement[2] !== undefined) {\n          return [key, unionOfTypes(refinementedType, sameRefinement[1], typeScope), intersectionOfTypes(alternateType, sameRefinement[2], typeScope)];\n        }\n\n        if (condition.operator === \"&&\" && sameRefinement[1] !== undefined && sameRefinement[2] !== undefined) {\n          return [key, intersectionOfTypes(refinementedType, sameRefinement[1], typeScope), unionOfTypes(alternateType, sameRefinement[2], typeScope)];\n        }\n\n        return [key, refinementedType, alternateType];\n      });\n      return sameRefinementVariants.concat(other);\n  }\n}\n\nfunction refinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  if (currentRefinementNode.isRefinemented) {\n    return;\n  }\n\n  const [primaryScope, alternateScope] = getPrimaryAndAlternativeScopes(currentRefinementNode, currentScope, typeScope, moduleScope);\n  const alternateScopes = Array.isArray(alternateScope) || alternateScope == undefined ? alternateScope : [alternateScope];\n  const condition = getCondition(currentRefinementNode);\n\n  if (condition == undefined) {\n    return;\n  }\n\n  const currentRefinements = refinementByCondition(condition, currentScope, typeScope, moduleScope, primaryScope);\n\n  if (!currentRefinements) {\n    return;\n  }\n\n  currentRefinements.forEach(refinement => {\n    let [varName, refinementedType, alternateType] = refinement;\n    const existed = currentScope.findVariable({\n      name: varName\n    });\n\n    if (!(existed.type instanceof _unionType.UnionType)) {\n      if (existed.type !== refinementedType) {\n        refinementedType = new _refinementedType.$Refinemented(refinementedType, existed.type);\n      }\n\n      if (existed.type !== alternateType) {\n        alternateType = new _refinementedType.$Refinemented(alternateType, existed.type);\n      }\n    }\n\n    if (!primaryScope.body.has(varName) || condition.type === _nodes2.default.SWITCH_CASE) {\n      primaryScope.body.set(varName, new _variableInfo.VariableInfo(refinementedType, currentScope));\n    }\n\n    if (alternateType && alternateScopes) {\n      alternateScopes.forEach(alternateScope => {\n        if (!alternateScope.body.has(varName) || condition.type === _nodes2.default.SWITCH_CASE) {\n          alternateScope.body.set(varName, new _variableInfo.VariableInfo(alternateType, currentScope));\n        }\n      });\n    }\n  });\n  currentRefinementNode.isRefinemented = true;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findUnhandledCases = findUnhandledCases;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _call = require(\"../type-graph/call\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction findUnhandledCases(node, errors, moduleScope, currentScope, parentNode, pre, middle, post) {\n  const {\n    discriminant,\n    cases\n  } = node; // test equals null only if it's default case\n\n  const hasDefaultCase = cases.some(switchCase => switchCase.test === null);\n\n  if ( // if switch statement doesn't have default case, we should check whether cases exhaustive or not\n  hasDefaultCase || discriminant.type !== _nodes2.default.IDENTIFIER && discriminant.type !== _nodes2.default.MEMBER_EXPRESSION) {\n    return;\n  }\n\n  const {\n    result: switchedValue\n  } = (0, _call.addCallToTypeGraph)(discriminant, moduleScope, currentScope, parentNode, pre, middle, post);\n  const switchedValueType = switchedValue instanceof _variableInfo.VariableInfo ? switchedValue.type : switchedValue;\n\n  if (!(switchedValueType instanceof _unionType.UnionType)) {\n    return;\n  }\n\n  let unmatchedVariants = [...switchedValueType.variants];\n  cases.forEach(({\n    test\n  }) => {\n    const {\n      result: matcherValue\n    } = (0, _call.addCallToTypeGraph)(test, moduleScope, currentScope, parentNode, pre, middle, post);\n    const matcherValueType = matcherValue instanceof _variableInfo.VariableInfo ? matcherValue.type : matcherValue;\n\n    if (matcherValueType instanceof _unionType.UnionType) {\n      errors.push(new _errors2.default(\"It is not safe to use variable which type is Union as case matcher, you should infer it value first\", node.loc));\n    }\n\n    unmatchedVariants = unmatchedVariants.filter(variant => !variant.equalsTo(matcherValueType));\n  });\n\n  if (unmatchedVariants.length !== 0) {\n    const notMatchedCases = _unionType.UnionType.getName(unmatchedVariants);\n\n    errors.push(new _errors2.default(`This switch case statement is not exhaustive. Here is an example of a case that is not matched: ${notMatchedCases}`, node.loc));\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.inferenceTupleType = inferenceTupleType;\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _call = require(\"../type-graph/call\");\n\nfunction inferenceTupleType(currentNode, typeScope, parentScope, typeGraph, parentNode, pre, middle, post) {\n  const items = currentNode.elements.map(a => {\n    if (a === null) {\n      return _type.Type.Undefined;\n    }\n\n    const {\n      result\n    } = (0, _call.addCallToTypeGraph)(a, typeGraph, parentScope, parentNode, pre, middle, post);\n    return result instanceof _type.Type ? result : result.type;\n  });\n  return _tupleType.TupleType.term(null, {}, items);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.typeofRefinement = typeofRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _common = require(\"../utils/common\");\n\nvar _equalsRefinement = require(\"./equals-refinement\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction isEqualOperator(node) {\n  return node.type === _nodes2.default.BINARY_EXPRESSION && (node.operator === \"===\" || node.operator === \"==\" || node.operator === \"!==\" || node.operator === \"!=\");\n}\n\nfunction isTypeofOperator(node) {\n  return node.type === _nodes2.default.UNARY_EXPRESSION && node.operator === \"typeof\";\n}\n\nfunction isReturnTypeOfTypeof(node) {\n  return node.type === _nodes2.default.STRING_LITERAL;\n}\n\nfunction getTypeofAndLiteral(left, right, typeofOperator) {\n  let typeofNode = null;\n\n  if (isTypeofOperator(left)) {\n    typeofNode = left;\n  } else if (isTypeofOperator(right)) {\n    typeofNode = right;\n  }\n\n  let stringNode = null;\n\n  if (isReturnTypeOfTypeof(left)) {\n    stringNode = left;\n  } else if (isReturnTypeOfTypeof(right)) {\n    stringNode = right;\n  }\n\n  if (!typeofNode || !stringNode) {\n    return null;\n  }\n\n  return {\n    typeofNode,\n    stringNode\n  };\n}\n\nfunction getRefinmentType(stringNode) {\n  switch (stringNode.value) {\n    case \"number\":\n      return _type.Type.Number;\n\n    case \"string\":\n      return _type.Type.String;\n\n    case \"boolean\":\n      return _unionType.UnionType.Boolean;\n\n    case \"bigint\":\n      return _type.Type.BigInt;\n\n    case \"undefined\":\n      return _type.Type.Undefined;\n\n    case \"symbol\":\n      return _type.Type.Symbol;\n\n    case \"function\":\n      return _functionType.FunctionType.Function;\n\n    case \"object\":\n      return _unionType.UnionType.term(\"{ ... } | null\", {}, [_objectType.ObjectType.term(\"{ ... }\", {\n        isSoft: true\n      }, []), _type.Type.Null]);\n  }\n\n  throw new _errors2.default(`Typeof cannot return \"${stringNode.value}\" value`, stringNode.loc);\n}\n\nfunction refinementVariants([refinementedVariants, alternateVariants], variant, refinementType) {\n  if (refinementType.isPrincipalTypeFor(variant)) {\n    return [refinementedVariants.concat([variant]), alternateVariants];\n  }\n\n  if (variant.isPrincipalTypeFor(refinementType)) {\n    return [refinementedVariants.concat([refinementType]), alternateVariants.concat([variant])];\n  }\n\n  return [refinementedVariants, alternateVariants.concat([variant])];\n}\n\nfunction typeofIdentifier(node, currentScope, typeScope, stringNode, refinementNode) {\n  const variableName = node.name;\n  const refinementType = getRefinmentType(stringNode);\n  const variableInfo = currentScope.findVariable(node);\n  const [refinementedVariants, alternateVariants] = variableInfo.type instanceof _unionType.UnionType ? variableInfo.type.variants.reduce((res, variant) => refinementVariants(res, variant, refinementType), [[], []]) : refinementVariants([[], []], variableInfo.type, refinementType);\n\n  if (!(variableInfo.type instanceof _typeVar.TypeVar) && variableInfo.type !== _type.Type.Unknown && refinementedVariants.length === 0) {\n    throw new _errors2.default(`Type ${String(variableInfo.type.name)} can't be \"${stringNode.value}\" type`, refinementNode.loc);\n  }\n\n  const refinementedType = _unionType.UnionType.term(null, {}, refinementedVariants);\n\n  const alternateType = alternateVariants.length === 0 || refinementType === variableInfo.type ? _type.Type.Never : _unionType.UnionType.term(null, {}, alternateVariants);\n\n  if (refinementedType === _type.Type.Never || alternateType === _type.Type.Never) {\n    throw new _errors2.default(`Variable ${refinementedType === _type.Type.Never ? \"can't be\" : \"is always\"} \"${stringNode.value}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinementedType, alternateType];\n}\n\nfunction typeofProperty(node, currentScope, typeScope, stringNode, refinementNode) {\n  const targetObject = (0, _common.getMemberExressionTarget)(node);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(node);\n  const refinementType = getRefinmentType(stringNode);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !propertiesChaining) {\n    return;\n  }\n\n  const refinmentedAndAlternate = (0, _equalsRefinement.refinementProperty)(variableName, targetVariableInfo.type, refinementType, refinementNode, 0, propertiesChaining, typeScope);\n\n  if (!refinmentedAndAlternate) {\n    return;\n  }\n\n  if (!refinmentedAndAlternate[0] || !refinmentedAndAlternate[1]) {\n    throw new _errors2.default(`Property ${refinmentedAndAlternate[0] === undefined ? \"can't be\" : \"is always\"} \"${stringNode.value}\"`, refinementNode.loc);\n  }\n\n  return [variableName, refinmentedAndAlternate[0], refinmentedAndAlternate[1]];\n}\n\nfunction typeofRefinement(currentRefinementNode, currentScope, typeScope, moduleScope) {\n  const typeofOperator = moduleScope.findVariable({\n    name: \"typeof\"\n  });\n\n  if (!isEqualOperator(currentRefinementNode)) {\n    return;\n  }\n\n  const args = getTypeofAndLiteral(currentRefinementNode.left, currentRefinementNode.right, typeofOperator);\n\n  if (!args) {\n    return (0, _equalsRefinement.equalsRefinement)(currentRefinementNode, currentScope, typeScope, moduleScope);\n  }\n\n  const {\n    typeofNode,\n    stringNode\n  } = args;\n  let refinementedType, alternateType, name;\n\n  if (typeofNode.argument.type === _nodes2.default.IDENTIFIER) {\n    [name, refinementedType, alternateType] = typeofIdentifier(typeofNode.argument, currentScope, typeScope, stringNode, currentRefinementNode);\n  }\n\n  if (typeofNode.argument.type === _nodes2.default.MEMBER_EXPRESSION) {\n    const result = typeofProperty(typeofNode.argument, currentScope, typeScope, stringNode, currentRefinementNode);\n\n    if (!result) {\n      return;\n    }\n\n    [name, refinementedType, alternateType] = result;\n  }\n\n  if (refinementedType) {\n    if (currentRefinementNode.operator === \"!==\" || currentRefinementNode.operator === \"!=\") {\n      // $FlowIssue\n      return [name, alternateType, refinementedType];\n    } // $FlowIssue\n\n\n    return [name, refinementedType, alternateType];\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.variableRefinement = variableRefinement;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _equalsRefinement = require(\"./equals-refinement\");\n\nvar _inferenceUtils = require(\"../utils/inference-utils\");\n\nvar _common = require(\"../utils/common\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getFalsyVariants(type) {\n  return (0, _typeUtils.getFalsy)().filter(falsy => type.isPrincipalTypeFor(falsy));\n}\n\nfunction getTruthyVariants(type) {\n  if ((0, _typeUtils.isFalsy)(type)) {\n    return [];\n  }\n\n  if (type === _unionType.UnionType.Boolean) {\n    return [_type.Type.True];\n  }\n\n  if (type instanceof _unionType.UnionType) {\n    return type.variants.filter(variant => !(0, _typeUtils.isFalsy)(variant));\n  }\n\n  return [type];\n}\n\nfunction forVariable(node, currentScope, typeScope) {\n  const name = node.name;\n  const variableInfo = currentScope.findVariable(node);\n  const refinementedVariants = getTruthyVariants(variableInfo.type);\n  const alternateVariants = getFalsyVariants(variableInfo.type);\n\n  if (!(variableInfo.type instanceof _typeVar.TypeVar) && (refinementedVariants.length === 0 || alternateVariants.length === 0)) {\n    return;\n  }\n\n  return [name, _unionType.UnionType.term(null, {}, refinementedVariants), _unionType.UnionType.term(null, {}, alternateVariants)];\n}\n\nfunction forProperty(node, currentScope, typeScope) {\n  const targetObject = (0, _common.getMemberExressionTarget)(node);\n\n  if (targetObject.type !== _nodes2.default.IDENTIFIER) {\n    return;\n  }\n\n  const variableName = targetObject.name;\n  const propertiesChaining = (0, _inferenceUtils.getPropertyChaining)(node);\n  const targetVariableInfo = currentScope.findVariable(targetObject);\n\n  if (!variableName || !propertiesChaining) {\n    return;\n  }\n\n  const refinementType = _unionType.UnionType.term(null, {}, (0, _typeUtils.getFalsy)());\n\n  const refinmentedAndAlternate = (0, _equalsRefinement.refinementProperty)(variableName, targetVariableInfo.type, refinementType, node, 0, propertiesChaining, typeScope, true);\n\n  if (!refinmentedAndAlternate || !refinmentedAndAlternate[0] || !refinmentedAndAlternate[1]) {\n    return;\n  }\n\n  return [variableName, refinmentedAndAlternate[1], refinmentedAndAlternate[0]];\n}\n\nfunction variableRefinement(node, currentScope, typeScope, moduleScope) {\n  return node.type === _nodes2.default.IDENTIFIER ? forVariable(node, currentScope, typeScope) : forProperty(node, currentScope, typeScope);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addCallToTypeGraph = addCallToTypeGraph;\nexports.addPropertyToThis = addPropertyToThis;\nexports.addMethodToThis = addMethodToThis;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _meta = require(\"./meta/meta\");\n\nvar _type = require(\"./types/type\");\n\nvar _keysType = require(\"./types/keys-type\");\n\nvar _valuesType = require(\"./types/values-type\");\n\nvar _typeVar = require(\"./types/type-var\");\n\nvar _callMeta = require(\"./meta/call-meta\");\n\nvar _typeScope = require(\"./type-scope\");\n\nvar _unionType = require(\"./types/union-type\");\n\nvar _objectType = require(\"./types/object-type\");\n\nvar _genericType = require(\"./types/generic-type\");\n\nvar _bottomType = require(\"./types/bottom-type\");\n\nvar _functionType = require(\"./types/function-type\");\n\nvar _variableInfo = require(\"./variable-info\");\n\nvar _propertyType = require(\"./types/property-type\");\n\nvar _variableScope = require(\"./variable-scope\");\n\nvar _refinementedType = require(\"./types/refinemented-type\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _functionUtils = require(\"../utils/function-utils\");\n\nvar _common = require(\"../utils/common\");\n\nvar _immutableType = require(\"./types/immutable-type\");\n\nvar _inference = require(\"../inference\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _variableUtils = require(\"../utils/variable-utils\");\n\nvar _moduleScope = require(\"./module-scope\");\n\nvar _throwable = require(\"../utils/throwable\");\n\nvar _constants = require(\"./constants\");\n\nvar _functionType2 = require(\"../inference/function-type\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addCallToTypeGraph(node, moduleScope, currentScope, parentNode, pre, middle, post, meta = {}) {\n  let target = null;\n  let inferenced = undefined;\n  let isFinal = undefined;\n  let targetName = \"\";\n  let args = null;\n  let argsLocations = [];\n  let genericArguments = null;\n  const typeScope = (0, _scopeUtils.findNearestTypeScope)(currentScope, moduleScope);\n  const withPositions = moduleScope instanceof _moduleScope.PositionedModuleScope;\n\n  if (node == null) {\n    return {\n      result: _type.Type.Undefined,\n      inferenced: false\n    };\n  }\n\n  if (node.type === _nodes2.default.EXPRESSION_STATEMENT) {\n    node = node.expression;\n  }\n\n  if (node.type === _nodes2.default.SUPER) {\n    node = {\n      type: _nodes2.default.IDENTIFIER,\n      name: \"super\",\n      loc: node.loc\n    };\n  }\n\n  switch (node.type) {\n    case _nodes2.default.TYPE_CAST:\n      throw new _errors2.default(\"Type cast does not exist in Hegel\", node.loc);\n\n    case _nodes2.default.TEMPLATE_LITERAL:\n      args = node.expressions.map(expression => addCallToTypeGraph(expression, moduleScope, currentScope, parentNode, pre, middle, post, meta).result);\n      argsLocations = node.expressions.map(node => node.loc);\n      targetName = \"tamplate literal\";\n      target = new _functionType.FunctionType(targetName, {}, args.map(() => _type.Type.String), _type.Type.String);\n      break;\n\n    case _nodes2.default.IF_STATEMENT:\n      target = currentScope.findVariable({\n        name: \"if\",\n        loc: node.loc\n      });\n      args = [addCallToTypeGraph(node.test, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      break;\n\n    case _nodes2.default.WHILE_STATEMENT:\n      target = currentScope.findVariable({\n        name: \"while\",\n        loc: node.loc\n      });\n      args = [addCallToTypeGraph(node.test, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      break;\n\n    case _nodes2.default.DO_WHILE_STATEMENT:\n      target = currentScope.findVariable({\n        name: \"do-while\",\n        loc: node.loc\n      });\n      args = [addCallToTypeGraph(node.test, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      break;\n\n    case _nodes2.default.FOR_STATEMENT:\n      target = currentScope.findVariable({\n        name: \"for\",\n        loc: node.loc\n      });\n      args = [_type.Type.Unknown, node.test ? addCallToTypeGraph(node.test, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.body)), parentNode, pre, middle, post, meta).result : _type.Type.Undefined, _type.Type.Unknown];\n      break;\n\n    case _nodes2.default.FUNCTION_EXPRESSION:\n    case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n    case _nodes2.default.IDENTIFIER:\n      const nodeName = node.type === _nodes2.default.IDENTIFIER ? node : {\n        name: (0, _common.getAnonymousKey)(node),\n        loc: node.loc\n      };\n      const varInfo = currentScope.findVariable(nodeName, parentNode, moduleScope, pre, middle, post);\n\n      if (withPositions && node.type === _nodes2.default.IDENTIFIER) {\n        // $FlowIssue\n        moduleScope.addPosition(node, varInfo);\n      }\n\n      return {\n        result: varInfo\n      };\n\n    case _nodes2.default.CLASS_PROPERTY:\n    case _nodes2.default.CLASS_PRIVATE_PROPERTY:\n    case _nodes2.default.OBJECT_PROPERTY:\n      const self = currentScope.findVariable({\n        name: _constants.THIS_TYPE\n      }); // $FlowIssue\n\n      let selfObject = node.static ? // $FlowIssue\n      self.parent.declaration.type : // $FlowIssue\n      self.type;\n      selfObject = selfObject instanceof _bottomType.$BottomType ? selfObject.subordinateMagicType.subordinateType : selfObject;\n\n      const _propertyName = (0, _variableUtils.getPropertyName)(node);\n\n      const propertyType = selfObject.properties.get(_propertyName);\n\n      if (propertyType === undefined) {\n        throw new Error(\"Never!!!\");\n      }\n\n      const value = node.value === null ? {\n        result: _type.Type.Undefined,\n        inferenced: false\n      } : addCallToTypeGraph(node.value, moduleScope, currentScope, parentNode, pre, middle, post, meta);\n      inferenced = value.inferenced;\n      args = [node.typeAnnotation != null ? propertyType : value.result, value.result];\n      targetName = \"=\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.VARIABLE_DECLARATOR:\n      const variableType = currentScope.findVariable(node.id);\n\n      if (withPositions) {\n        // $FlowIssue\n        moduleScope.addPosition(node.id, variableType);\n      }\n\n      const init = node.init === null ? {\n        result: _type.Type.Undefined,\n        inferenced: false\n      } : addCallToTypeGraph(node.init, moduleScope, currentScope, parentNode, pre, middle, post, { ...meta,\n        isImmutable: variableType.type instanceof _immutableType.$AppliedImmutable\n      });\n      inferenced = init.inferenced;\n      targetName = \"init\";\n      args = [variableType, init.result];\n      target = currentScope.findVariable({\n        name: \"=\",\n        loc: node.loc\n      }).type;\n      target = target instanceof _genericType.GenericType && node.id.typeAnnotation != undefined ? target.applyGeneric([variableType.type]) : target;\n      break;\n\n    case _nodes2.default.THROW_STATEMENT:\n      const error = addCallToTypeGraph(node.argument, moduleScope, currentScope, parentNode, pre, middle, post, meta);\n      args = [(0, _variableUtils.getVariableType)(undefined, error.result instanceof _variableInfo.VariableInfo ? error.result.type : error.result, typeScope, error.inferenced)];\n      targetName = \"throw\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      }, parentNode, moduleScope, pre, middle, post);\n      const nearestFn = (0, _scopeUtils.findNearestScopeByType)(_variableScope.VariableScope.FUNCTION_TYPE, currentScope);\n      isFinal = nearestFn instanceof _moduleScope.ModuleScope || currentScope === nearestFn || currentScope.getParentsUntil(nearestFn).every(parent => parent.creator === \"block\" || parent.creator === \"catch\");\n      const nearestThrowableScope = (0, _throwable.findThrowableBlock)(currentScope);\n      const throwableDeclaration = nearestThrowableScope && nearestThrowableScope.declaration;\n\n      if (nearestThrowableScope != null) {\n        (0, _throwable.addToThrowable)(args[0], nearestThrowableScope);\n      }\n\n      if (isFinal && currentScope !== nearestFn) {\n        nearestFn.calls.push(new _callMeta.CallMeta(undefined, [], node.loc, \"throw\", typeScope, false, true));\n      }\n\n      if (nearestThrowableScope == null || nearestThrowableScope.type !== _variableScope.VariableScope.FUNCTION_TYPE || throwableDeclaration == undefined) {\n        break;\n      } // $FlowIssue\n\n\n      const currentTargetType = target.type;\n      const declarationType = throwableDeclaration.type instanceof _genericType.GenericType ? throwableDeclaration.type.subordinateType : throwableDeclaration.type;\n\n      if (declarationType instanceof _objectType.ObjectType) {\n        throw new Error(\"Never!!!\");\n      }\n\n      if (declarationType.throwable !== undefined) {\n        target = currentTargetType.applyGeneric([declarationType.throwable]);\n      }\n\n      break;\n\n    case _nodes2.default.AWAIT_EXPRESSION:\n      args = [addCallToTypeGraph(node.argument, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      targetName = \"await\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      }, parentNode, moduleScope, pre, middle, post);\n      break;\n\n    case _nodes2.default.LOGICAL_EXPRESSION:\n      args = [addCallToTypeGraph(node.left.body, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.left)), node.left, pre, middle, post, meta).result, addCallToTypeGraph(node.right.body, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.right)), node.right, pre, middle, post, meta).result];\n      let leftArg = args[0];\n      leftArg = leftArg instanceof _variableInfo.VariableInfo ? leftArg.type : leftArg;\n      leftArg = node.operator === \"&&\" ? (0, _typeUtils.pickFalsy)(leftArg) : (0, _typeUtils.pickTruthy)(leftArg);\n      args[0] = leftArg || args[0];\n\n    case _nodes2.default.BINARY_EXPRESSION:\n      args = args || [addCallToTypeGraph(node.left, moduleScope, currentScope, parentNode, pre, middle, post, meta).result, addCallToTypeGraph(node.right, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      targetName = node.operator === \"+\" ? \"b+\" : node.operator;\n      targetName = node.operator === \"-\" ? \"b-\" : targetName;\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.ASSIGNMENT_EXPRESSION:\n    case _nodes2.default.ASSIGNMENT_PATTERN:\n      const right = addCallToTypeGraph(node.right, moduleScope, currentScope, parentNode, pre, middle, post, meta);\n      const left = addCallToTypeGraph(node.left, moduleScope, currentScope, parentNode, pre, middle, post, { ...meta,\n        isForAssign: true\n      });\n      args = [left.result, right.result];\n\n      if (left.result instanceof _variableInfo.VariableInfo && left.result.isConstant) {\n        throw new _errors2.default(\"Cannot assign to variable because it is a constant.\", node.loc);\n      }\n\n      targetName = node.operator || \"=\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      }).type;\n      target = target instanceof _genericType.GenericType && (node.type !== _nodes2.default.ASSIGNMENT_PATTERN || node.left.typeAnnotation != undefined) ? // $FlowIssue\n      target.applyGeneric([left.result.type || left.result]) : target;\n      inferenced = right.inferenced;\n      break;\n\n    case _nodes2.default.RETURN_STATEMENT:\n      targetName = \"return\";\n      const fn = (0, _scopeUtils.findNearestScopeByType)(_variableScope.VariableScope.FUNCTION_TYPE, currentScope);\n\n      if (fn instanceof _moduleScope.ModuleScope) {\n        throw new _errors2.default(\"Call return outside a function\", node.loc);\n      }\n\n      const arg = addCallToTypeGraph(node.argument, moduleScope, currentScope, parentNode, pre, middle, post, meta);\n      inferenced = arg.inferenced;\n      let argType = arg.result instanceof _variableInfo.VariableInfo ? arg.result.type : arg.result;\n      argType = argType instanceof _refinementedType.$Refinemented ? argType.from : argType;\n      let fType = fn.declaration.type;\n      fType = fType instanceof _genericType.GenericType ? fType.subordinateType : fType;\n      args = [fType.isAsync && !argType.isPromise() ? argType.promisify() : argType];\n      const declaration = fn.declaration.type instanceof _genericType.GenericType ? fn.declaration.type.subordinateType : fn.declaration.type;\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      }, parentNode, moduleScope, pre, middle, post); // $FlowIssue\n\n      target = target.type.subordinateType.changeAll( // $FlowIssue\n      target.type.genericArguments, [declaration.returnType]);\n      isFinal = currentScope === fn || // $FlowIssue\n      currentScope.getParentsUntil(fn).every(parent => parent.creator === \"block\");\n      currentScope = fn;\n      break;\n\n    case _nodes2.default.UNARY_EXPRESSION:\n    case _nodes2.default.UPDATE_EXPRESSION:\n      targetName = node.operator;\n      args = [addCallToTypeGraph(node.argument, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.PURE_KEY:\n      args = [addCallToTypeGraph(node.of, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      targetName = \"Object.keys\";\n      args = args.map(a => a instanceof _variableInfo.VariableInfo ? a.type : a);\n      target = new _keysType.$Keys().applyGeneric(args, node.loc); // $FlowIssue\n\n      target = new _functionType.FunctionType(targetName, {}, args, target);\n      break;\n\n    case _nodes2.default.PURE_VALUE:\n    case _nodes2.default.VALUE:\n      target = addCallToTypeGraph(node.of, moduleScope, currentScope, parentNode, pre, middle, post, meta).result;\n      args = [target];\n      targetName = \"Object.values\";\n      args = args.map(a => a instanceof _variableInfo.VariableInfo ? a.type : a);\n      const isArray = args[0] instanceof _collectionType.CollectionType;\n      target = new _valuesType.$Values().applyGeneric(args, node.loc);\n      target = isArray && node.type === _nodes2.default.VALUE ? _unionType.UnionType.term(null, {}, [target, _type.Type.Undefined]) : target; // $FlowIssue\n\n      target = new _functionType.FunctionType(targetName, {}, args, target);\n      break;\n\n    case _nodes2.default.MEMBER_EXPRESSION:\n      const propertyName = node.property.type === _nodes2.default.PRIVATE_NAME ? `#${node.property.id.name}` : node.property.name;\n      const isNotComputed = (node.property.type === _nodes2.default.IDENTIFIER || node.property.type === _nodes2.default.PRIVATE_NAME) && !node.computed;\n      args = [(0, _typeUtils.getWrapperType)(addCallToTypeGraph(node.object, moduleScope, currentScope, parentNode, pre, middle, post, meta).result, moduleScope), isNotComputed ? _type.Type.term(`'${propertyName}'`, {\n        isSubtypeOf: _type.Type.String\n      }) : addCallToTypeGraph(node.property, moduleScope, currentScope, parentNode, pre, middle, post, meta).result];\n      targetName = \".\";\n      genericArguments = args.map(t => t instanceof _variableInfo.VariableInfo ? t.type : t);\n      const lts = new _typeScope.TypeScope(typeScope);\n      const argsTypes = [_typeVar.TypeVar.new(\"A\", {\n        parent: lts\n      }, undefined, undefined, true), _typeVar.TypeVar.new(\"B\", {\n        parent: lts\n      }, undefined, undefined, true)];\n      const property = new _bottomType.$BottomType({\n        isForAssign: meta.isForAssign\n      }, new _propertyType.$PropertyType(\"\", {}, meta.isForInit), genericArguments);\n      target = _genericType.GenericType.term(`<A, B>(A, B) => ${String(property.name)}`, {}, argsTypes, lts, new _functionType.FunctionType(\"\", {}, argsTypes, property));\n      break;\n\n    case _nodes2.default.CONDITIONAL_EXPRESSION:\n      args = [addCallToTypeGraph(node.test, moduleScope, currentScope, parentNode, pre, middle, post, meta).result, addCallToTypeGraph(node.consequent.body, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.consequent)), node.consequent, pre, middle, post, meta).result, addCallToTypeGraph(node.alternate.body, moduleScope, // $FlowIssue\n      moduleScope.scopes.get(_variableScope.VariableScope.getName(node.alternate)), node.alternate, pre, middle, post, meta).result];\n      targetName = \"?:\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.NEW_EXPRESSION:\n      const argument = addCallToTypeGraph(node.callee, moduleScope, currentScope, parentNode, pre, middle, post, meta).result;\n      const argumentType = argument instanceof _variableInfo.VariableInfo ? argument.type : argument;\n      const potentialArgument = addCallToTypeGraph({ ...node,\n        type: _nodes2.default.CALL_EXPRESSION,\n        isConstructor: true\n      }, moduleScope, currentScope, parentNode, pre, middle, post, meta).result;\n\n      const defaultObject = _objectType.ObjectType.term(\"{  }\", {}, []);\n\n      args = [_objectType.ObjectType.Object.isPrincipalTypeFor(potentialArgument) ? potentialArgument : defaultObject];\n      targetName = \"new\";\n      target = currentScope.findVariable({\n        name: targetName,\n        loc: node.loc\n      });\n      break;\n\n    case _nodes2.default.CALL_EXPRESSION:\n      if (node.callee.type === _nodes2.default.IDENTIFIER || node.callee.type === _nodes2.default.THIS_EXPRESSION || node.callee.type === _nodes2.default.SUPER) {\n        targetName = node.callee.name;\n\n        if (node.callee.type === _nodes2.default.SUPER) {\n          targetName = \"super\";\n        }\n\n        if (node.callee.type === _nodes2.default.THIS_EXPRESSION) {\n          targetName = _constants.THIS_TYPE;\n        }\n\n        target = currentScope.findVariable({\n          name: targetName,\n          loc: node.callee.loc\n        }, parentNode, moduleScope, pre, middle, post);\n\n        if (withPositions) {\n          // $FlowIssue\n          moduleScope.addPosition(node.callee, target);\n        }\n      } else {\n        target = addCallToTypeGraph(node.callee, moduleScope, currentScope, parentNode, pre, middle, post, meta).result;\n      }\n\n      let targetType = target instanceof _variableInfo.VariableInfo ? target.type : target;\n      targetType = targetType instanceof _immutableType.$AppliedImmutable ? targetType.readonly : targetType;\n      targetType = targetType instanceof _bottomType.$BottomType ? targetType.unpack(node.loc) : targetType;\n\n      if (!(targetType instanceof _functionType.FunctionType) && !(targetType instanceof _genericType.GenericType && targetType.subordinateType instanceof _functionType.FunctionType)) {\n        target = targetType.getPropertyType(node.isConstructor ? _constants.CONSTRUCTABLE : _constants.CALLABLE) || target;\n        target = typeof targetType === \"string\" ? _variableScope.VariableScope.addAndTraverseNodeWithType( // $FlowIssue\n        undefined, target, parentNode, moduleScope, pre, middle, post) : target;\n        target = target instanceof _variableInfo.VariableInfo ? target : // $FlowIssue\n        new _variableInfo.VariableInfo(target, currentScope);\n        targetType =\n        /*::target.type !== undefined ?*/\n        target.type\n        /*:: : targetType*/\n        ;\n      }\n\n      genericArguments = node.typeArguments && node.typeArguments.params.map(arg => (0, _typeUtils.getTypeFromTypeAnnotation)({\n        typeAnnotation: arg\n      }, typeScope, currentScope, false, null, parentNode, moduleScope, pre, middle, post));\n      const localTypeScope = targetType instanceof _genericType.GenericType ? targetType.localTypeScope : typeScope;\n\n      if (targetType instanceof _genericType.GenericType && genericArguments != null) {\n        targetType = (0, _functionType2.getRawFunctionType)( // $FlowIssue\n        targetType, [], genericArguments, localTypeScope, node.loc);\n      }\n\n      let fnType = targetType instanceof _genericType.GenericType ? targetType.subordinateType : targetType;\n\n      if (fnType != undefined && !(fnType instanceof _functionType.FunctionType) && !(fnType instanceof _typeVar.TypeVar && !fnType.isUserDefined)) {\n        throw new _errors2.default(fnType instanceof _unionType.UnionType && fnType.variants.every(_functionUtils.isCallableType) ? `Signatures of each variant of type \"${String(fnType.name)}\" are not compatible with each other` : `The type \"${String(fnType.name)}\" is not callable.`, node.loc);\n      }\n\n      args = node.arguments.map((n, i) => {\n        argsLocations.push(n.loc); // $FlowIssue\n\n        const defaultArg = (fnType.argumentsTypes || [])[i];\n        return n.type === _nodes2.default.FUNCTION_EXPRESSION || n.type === _nodes2.default.ARROW_FUNCTION_EXPRESSION ? defaultArg : addCallToTypeGraph(n, moduleScope, currentScope, parentNode, pre, middle, post, { ...meta,\n          isImmutable: defaultArg instanceof _immutableType.$AppliedImmutable\n        }).result;\n      });\n      targetType.asNotUserDefined();\n      args = node.arguments.map((n, i) => {\n        if (n.type !== _nodes2.default.FUNCTION_EXPRESSION && n.type !== _nodes2.default.ARROW_FUNCTION_EXPRESSION) {\n          // $FlowIssue\n          return args[i];\n        } // $FlowIssue\n\n\n        let expectedType = fnType.argumentsTypes[i]; // We need it for right type inference of the argument function\n\n        if (targetType instanceof _genericType.GenericType) {\n          const existedGenericArguments = expectedType instanceof _genericType.GenericType ? expectedType.genericArguments : [];\n          const subordinateType = expectedType instanceof _genericType.GenericType ? expectedType.subordinateType : expectedType;\n          expectedType = new _genericType.GenericType(\"\", {}, [...existedGenericArguments, ...targetType.genericArguments], new _typeScope.TypeScope(), subordinateType);\n        }\n\n        const result = _variableScope.VariableScope.addAndTraverseNodeWithType( // $FlowIssue\n        expectedType, n, parentNode, moduleScope, pre, middle, post);\n\n        return result;\n      });\n      fnType = (0, _functionType2.getRawFunctionType)( // $FlowIssue\n      targetType, args, genericArguments, localTypeScope, node.loc);\n      targetType.asUserDefined();\n      const throwableType = targetType instanceof _genericType.GenericType ? targetType.subordinateType : targetType;\n\n      if (throwableType.throwable !== undefined && !(currentScope instanceof _moduleScope.ModuleScope)) {\n        const nearestThrowableScope = (0, _throwable.findThrowableBlock)(currentScope);\n\n        if (nearestThrowableScope != undefined) {\n          (0, _throwable.addToThrowable)(throwableType.throwable, nearestThrowableScope);\n\n          if (nearestThrowableScope.type === _variableScope.VariableScope.FUNCTION_TYPE) {\n            const declaration = nearestThrowableScope.declaration;\n\n            if (declaration === undefined) {\n              throw new Error(\"Never!!!\");\n            }\n\n            const declarationType = declaration.type instanceof _genericType.GenericType ? declaration.type.subordinateType : declaration.type;\n\n            if (declarationType instanceof _objectType.ObjectType) {\n              throw new Error(\"Never!!!\");\n            }\n\n            const declaratedThrowable = declarationType.throwable;\n\n            if (declaratedThrowable !== undefined && !declaratedThrowable.isPrincipalTypeFor(throwableType.throwable)) {\n              throw new _errors2.default(`Current function throws \"${String(throwableType.throwable.name)}\" type which is incompatible with declareted throw type \"${String(declaratedThrowable.name)}\"`, node.loc);\n            }\n          }\n        }\n      }\n\n      if (genericArguments != null || target.type instanceof _bottomType.$BottomType) {\n        target = fnType;\n      }\n\n      inferenced = targetType instanceof _genericType.GenericType && targetType.subordinateType.returnType instanceof _typeVar.TypeVar;\n      break;\n\n    case _nodes2.default.THIS_EXPRESSION:\n      const selfVar = currentScope.findVariable({\n        name: _constants.THIS_TYPE,\n        loc: node.loc\n      });\n      const nearestFunctionScope = (0, _scopeUtils.findNearestScopeByType)(_variableScope.VariableScope.FUNCTION_TYPE, currentScope);\n      nearestFunctionScope.calls.push(new _callMeta.CallMeta(undefined, [], node.loc, \"this\", typeScope));\n      return {\n        result: selfVar.type instanceof _bottomType.$BottomType ? selfVar.type.subordinateMagicType.subordinateType : selfVar.type,\n        inferenced: false\n      };\n\n    case _nodes2.default.SEQUENCE_EXPRESSION:\n      return addCallToTypeGraph(node.expressions[node.expressions.length - 1], moduleScope, currentScope, parentNode, pre, middle, post, meta);\n\n    default:\n      return {\n        result: (0, _inference.inferenceTypeForNode)(node, typeScope, currentScope, moduleScope, parentNode, pre, middle, post, meta.isTypeDefinitions, meta.isImmutable),\n        isLiteral: true,\n        inferenced: true\n      };\n  }\n\n  if (target === null || args === null) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const targetType = target instanceof _variableInfo.VariableInfo ? target.type : target;\n  const options = {\n    pre,\n    args,\n    meta,\n    node,\n    post,\n    middle,\n    target,\n    moduleScope,\n    typeScope,\n    targetType,\n    parentNode,\n    dropUnknown: targetName === \"=\" || targetName === \"init\",\n    genericArguments: genericArguments && genericArguments.map(a => a instanceof _type.Type ? a : a.type)\n  };\n\n  const getResult = targetType => {\n    const {\n      result,\n      inferenced: localInferenced\n    } = invoke({ ...options,\n      targetType\n    });\n    inferenced = inferenced || localInferenced;\n    return result;\n  };\n\n  const invocationType = targetType instanceof _unionType.UnionType ? _unionType.UnionType.term(null, {}, targetType.variants.map(getResult)) : getResult(targetType);\n  const callMeta = new _callMeta.CallMeta(target, args, node.loc, targetName, typeScope, inferenced, isFinal, argsLocations);\n\n  while (currentScope.skipCalls !== false && currentScope !== moduleScope) {\n    // $FlowIssue\n    currentScope = currentScope.parent;\n  }\n\n  currentScope.calls.push(callMeta);\n  return {\n    result: invocationType,\n    inferenced\n  };\n}\n\nfunction invoke({\n  parentNode,\n  typeScope,\n  moduleScope,\n  pre,\n  middle,\n  post,\n  target,\n  targetType,\n  genericArguments,\n  args,\n  node,\n  meta,\n  dropUnknown\n}) {\n  if (targetType instanceof _immutableType.$AppliedImmutable) {\n    targetType = targetType.readonly;\n  }\n\n  if (!(targetType instanceof _bottomType.$BottomType) && !(targetType instanceof _typeVar.TypeVar && !targetType.isUserDefined) && !(targetType instanceof _functionType.FunctionType) && !(targetType instanceof _genericType.GenericType && targetType.subordinateType instanceof _functionType.FunctionType)) {\n    throw new _errors2.default(\"The target is not callable type.\", node.loc);\n  }\n\n  try {\n    const invocationType = (0, _functionType2.getInvocationType)(targetType, args, genericArguments, typeScope, node.loc, meta.isForAssign, dropUnknown);\n\n    if (!(invocationType instanceof _type.Type)) {\n      return {\n        result: addPropertyToThis(invocationType, parentNode, typeScope, moduleScope, pre, middle, post),\n        inferenced: false\n      };\n    }\n\n    if (targetType instanceof _typeVar.TypeVar && !targetType.isUserDefined && target instanceof _variableInfo.VariableInfo) {\n      let func = (0, _scopeUtils.findNearestScopeByType)(_variableScope.VariableScope.FUNCTION_TYPE, // $FlowIssue\n      target.parent);\n\n      if (func.declaration && func.declaration.type instanceof _genericType.GenericType && invocationType instanceof _typeVar.TypeVar) {\n        const genericArguments = func.declaration.type.genericArguments;\n        genericArguments.push(invocationType);\n\n        const fn = _type.Type.getTypeRoot(targetType);\n\n        fn.argumentsTypes.forEach(arg => {\n          if (arg instanceof _typeVar.TypeVar && !arg.isUserDefined && !genericArguments.includes(arg)) {\n            genericArguments.push(arg);\n          }\n        });\n      }\n    }\n\n    return {\n      result: invocationType,\n      inferenced: isInferencedTypeVar(targetType) && isInferencedTypeVar(invocationType, true)\n    };\n  } catch (e) {\n    if (e.loc === undefined) {\n      e.loc = node.loc;\n    }\n\n    throw e;\n  }\n}\n\nfunction isInferencedTypeVar(t, withoutRoot = false) {\n  return t instanceof _typeVar.TypeVar && !t.isUserDefined && (!withoutRoot || t.root === undefined);\n}\n\nfunction addPropertyToThis(currentNode, parentNode, typeScope, moduleScope, precompute, middlecompute, postcompute) {\n  let propertyName;\n  const isPrivate = currentNode.type === _nodes2.default.CLASS_PRIVATE_PROPERTY;\n\n  if (isPrivate) {\n    propertyName = `#${currentNode.key.id.name}`;\n  } else {\n    propertyName = currentNode.key.name || `${currentNode.key.value}`;\n  } // $FlowIssue\n\n\n  const currentScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, moduleScope);\n  const currentClassScope = (0, _scopeUtils.findNearestScopeByType)([_variableScope.VariableScope.CLASS_TYPE, _variableScope.VariableScope.OBJECT_TYPE], currentScope); // $FlowIssue\n\n  const self = currentNode.static ? currentClassScope.declaration : currentClassScope.findVariable({\n    name: _constants.THIS_TYPE\n  });\n  const selfType = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (currentClassScope.isProcessed) {\n    // $FlowIssue\n    return selfType.properties.get(propertyName).type;\n  }\n\n  const currentTypeScope = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.localTypeScope : typeScope;\n  let type = _type.Type.Undefined;\n\n  if (currentNode.typeAnnotation != null) {\n    type = (0, _typeUtils.getTypeFromTypeAnnotation)(currentNode.typeAnnotation, currentTypeScope, currentClassScope, false, null, parentNode, moduleScope, precompute, middlecompute, postcompute);\n  }\n\n  const property = new _variableInfo.VariableInfo(type, currentClassScope, new _meta.Meta(currentNode.loc), false, false, isPrivate);\n\n  if (!(selfType instanceof _objectType.ObjectType)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  if (currentNode.hasInitializer || currentNode.type === _nodes2.default.OBJECT_PROPERTY) {\n    property.hasInitializer = true;\n  }\n\n  selfType.properties.set(propertyName, property);\n\n  if (moduleScope instanceof _moduleScope.PositionedModuleScope) {\n    moduleScope.addPosition(currentNode.key, property);\n  }\n\n  if (currentNode.type === _nodes2.default.OBJECT_METHOD || currentNode.type === _nodes2.default.CLASS_METHOD) {\n    const fn = _variableScope.VariableScope.addAndTraverseNodeWithType(null, currentNode, parentNode, moduleScope, precompute, middlecompute, postcompute);\n\n    property.hasInitializer = true;\n\n    if (fn === undefined) {\n      throw new Error(\"Never!!!\");\n    }\n\n    property.type = fn.type;\n  } else if (currentNode.value != null) {\n    const inferenced = addCallToTypeGraph(currentNode, moduleScope, currentClassScope, parentNode, precompute, middlecompute, postcompute).result;\n    property.hasInitializer = true;\n\n    if (currentNode.typeAnnotation === undefined) {\n      property.type = inferenced instanceof _variableInfo.VariableInfo ? inferenced.type : inferenced;\n    }\n  }\n\n  if (moduleScope instanceof _moduleScope.PositionedModuleScope) {\n    moduleScope.addPosition(currentNode, property);\n  }\n\n  return property.type;\n}\n\nfunction addMethodToThis(currentNode, parentNode, moduleScope, pre, middle, post, isTypeDefinitions) {\n  const currentScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(parentNode));\n\n  if (currentScope === undefined) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const classScope = (0, _scopeUtils.findNearestScopeByType)([_variableScope.VariableScope.CLASS_TYPE, _variableScope.VariableScope.OBJECT_TYPE], currentScope);\n\n  if (classScope.isProcessed) {\n    return;\n  }\n\n  let propertyName;\n  const isPrivate = currentNode.type === _nodes2.default.CLASS_PRIVATE_METHOD;\n\n  if (isPrivate) {\n    propertyName = `#${currentNode.key.id.name}`;\n  } else {\n    propertyName = currentNode.key.name || `${currentNode.key.value}`;\n  }\n\n  if (currentNode.kind === \"constructor\") {\n    propertyName = _constants.CONSTRUCTABLE;\n  }\n\n  const self = classScope.findVariable({\n    name: _constants.THIS_TYPE\n  }); // $FlowIssue\n\n  const classVar = currentNode.static || propertyName === _constants.CONSTRUCTABLE ? classScope.declaration : self;\n  const classType = classVar.type instanceof _bottomType.$BottomType ? classVar.type.subordinateMagicType.subordinateType : classVar.type;\n  const methodScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n  if (methodScope !== undefined && !isTypeDefinitions) {\n    return false;\n  } // $FlowIssue\n\n\n  const existedProperty = classType.properties.get(propertyName);\n  const expectedType = existedProperty instanceof _variableInfo.VariableInfo ? existedProperty.type : undefined;\n  currentNode.expected = currentNode.expected || expectedType;\n  let fn = (0, _functionUtils.addFunctionToTypeGraph)(currentNode, parentNode, moduleScope, pre, middle, post, isTypeDefinitions);\n\n  if (isPrivate) {\n    fn = new _variableInfo.VariableInfo(fn.type, fn.parent, fn.meta, fn.isConstant, fn.isInferenced, true);\n  }\n\n  fn.hasInitializer = true;\n\n  if (!isTypeDefinitions && classScope.type === _variableScope.VariableScope.CLASS_TYPE) {\n    const fnScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n    if (fnScope === undefined) {\n      throw new Error(\"Never!!!\");\n    }\n\n    fnScope.declaration = fn; // $FlowIssue\n\n    fnScope.body.set(_constants.THIS_TYPE, currentNode.static ? classScope.declaration : self);\n\n    if (classScope.declaration.type.isSubtypeOf !== _objectType.ObjectType.Object && currentNode.static) {\n      // $FlowIssue\n      fnScope.body.set(\"super\", new _variableInfo.VariableInfo(classScope.declaration.type.isSubtypeOf, fnScope));\n    }\n  } // $FlowIssue\n\n\n  classType.properties.set(propertyName, fn);\n\n  if (propertyName === _constants.CONSTRUCTABLE) {\n    const type = // For Function Variable Scope type can't be an ObjectType\n    fn.type instanceof _genericType.GenericType ? fn.type.subordinateType : fn.type;\n    const returnType = (type.returnType instanceof _objectType.ObjectType || type.returnType instanceof _collectionType.CollectionType) && _objectType.ObjectType.Object.isPrincipalTypeFor(type.returnType) ? type.returnType : self.type;\n    const fnName = `${String(self.type.name)} constructor`;\n\n    let constructorType = _functionType.FunctionType.term(fnName, {}, type.argumentsTypes, returnType);\n\n    if (self.type instanceof _bottomType.$BottomType) {\n      const fnType = fn.type;\n      const additionalArray = fnType instanceof _genericType.GenericType ? fnType.genericArguments.filter(a => a !== fnType.subordinateType.returnType) : [];\n      const genericArguments = Array.from(new Set([...self.type.genericArguments, ...additionalArray]));\n      const localTypeScope = fn.type instanceof _genericType.GenericType ? fn.type.localTypeScope : self.type.subordinateMagicType.localTypeScope;\n      constructorType = _genericType.GenericType.new(fnName, {}, genericArguments, localTypeScope, constructorType);\n    } else if (fn.type instanceof _genericType.GenericType) {\n      constructorType = _genericType.GenericType.new(fnName, {}, fn.type.genericArguments, fn.type.localTypeScope, constructorType);\n    }\n\n    fn.type = constructorType;\n  }\n\n  if (moduleScope instanceof _moduleScope.PositionedModuleScope) {\n    // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n    moduleScope.addPosition(currentNode, fn);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n// flow\nconst THIS_TYPE = exports.THIS_TYPE = \"[[This]]\";\nconst CALLABLE = exports.CALLABLE = \"[[Callable]]\";\nconst CONSTRUCTABLE = exports.CONSTRUCTABLE = \"[[Constructable]]\";\nconst INDEXABLE = exports.INDEXABLE = \"[[Indexable]]\";","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CallMeta = undefined;\n\nvar _meta = require(\"./meta\");\n\nvar _type = require(\"../types/type\");\n\nvar _genericType = require(\"../types/generic-type\");\n\nvar _functionType = require(\"../types/function-type\");\n\nvar _variableInfo = require(\"../variable-info\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass CallMeta extends _meta.Meta {\n  constructor(target, args, loc, targetName, typeScope, inferenced = false, isFinal = false, argumentsLocations = []) {\n    super(loc);\n\n    _defineProperty(this, \"target\", void 0);\n\n    _defineProperty(this, \"targetName\", void 0);\n\n    _defineProperty(this, \"arguments\", void 0);\n\n    _defineProperty(this, \"argumentsLocations\", void 0);\n\n    _defineProperty(this, \"inferenced\", void 0);\n\n    _defineProperty(this, \"isFinal\", void 0);\n\n    _defineProperty(this, \"typeScope\", void 0);\n\n    this.target = target;\n    this.targetName = targetName;\n    this.arguments = args;\n    this.typeScope = typeScope;\n    this.inferenced = inferenced;\n    this.isFinal = isFinal;\n    this.argumentsLocations = argumentsLocations;\n  }\n\n}\n\nexports.CallMeta = CallMeta;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst ZeroLocation = {\n  start: {\n    column: -1,\n    line: -1\n  },\n  end: {\n    column: -1,\n    line: -1\n  }\n};\n\nclass Meta {\n  constructor(loc = ZeroLocation) {\n    _defineProperty(this, \"loc\", void 0);\n\n    _defineProperty(this, \"changed\", void 0);\n\n    this.loc = loc;\n    this.changed = false;\n  }\n\n}\n\nexports.Meta = Meta;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PositionedModuleScope = exports.ModuleScope = undefined;\n\nvar _scope = require(\"./scope\");\n\nvar _typeScope = require(\"./type-scope\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// $FlowIssue\nclass ModuleScope extends _scope.Scope {\n  constructor(path, body = new Map(), parent = null, typeScope = new _typeScope.TypeScope()) {\n    // $FlowIssue\n    super(parent);\n\n    _defineProperty(this, \"typeScope\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"calls\", []);\n\n    _defineProperty(this, \"exports\", void 0);\n\n    _defineProperty(this, \"exportsTypes\", void 0);\n\n    _defineProperty(this, \"scopes\", void 0);\n\n    _defineProperty(this, \"path\", void 0);\n\n    this.parent = parent;\n    this.path = path;\n    this.body = body;\n    this.typeScope = typeScope;\n    this.exports = new Map();\n    this.exportsTypes = new Map();\n    this.scopes = new Map();\n  }\n\n}\n\nexports.ModuleScope = ModuleScope;\n\nclass PositionedModuleScope extends ModuleScope {\n  constructor(path, body = new Map(), parent, typeScope = new _typeScope.TypeScope()) {\n    super(path, body, parent, typeScope);\n\n    _defineProperty(this, \"positions\", void 0);\n\n    this.positions = new Map();\n  }\n\n  addPosition(node, variableInfoOrType) {\n    const line = this.positions.get(node.loc.start.line) || new Map();\n    line.set(`${node.loc.start.column},${node.loc.end.column}`, variableInfoOrType);\n    this.positions.set(node.loc.start.line, line);\n  }\n\n  getVarAtPosition(loc, typeGraph) {\n    const line = this.positions.get(loc.line);\n\n    if (line === undefined) {\n      return;\n    }\n\n    let varInfo = undefined;\n\n    for (const [startEnd, vi] of line.entries()) {\n      let [start, end] = startEnd.split(\",\");\n      start = Number(start);\n      end = Number(end);\n\n      if (loc.column >= start && loc.column <= end) {\n        varInfo = vi;\n        break;\n      }\n    }\n\n    return varInfo;\n  }\n\n}\n\nexports.PositionedModuleScope = PositionedModuleScope;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Scope = undefined;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _traverse = require(\"../utils/traverse\");\n\nvar _traverse2 = _interopRequireDefault(_traverse);\n\nvar _variableInfo = require(\"./variable-info\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass Scope {\n  static canTraverseFunction(rest) {\n    return rest.length === 5;\n  }\n\n  static getName(node) {\n    return `[[Scope${node.loc.start.line}-${node.loc.start.column}]]`;\n  }\n\n  static addAndTraverseNodeWithType(definedType, currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute) {\n    currentNode.expected = definedType != undefined && \"variants\" in definedType ? // $FlowIssue\n    definedType.variants.find(a => \"argumentsTypes\" in a) : definedType;\n    const scopeName = this.getName(currentNode);\n    (0, _traverse2.default)(currentNode, precompute, middlecompute, postcompute, _nodes2.default.isFunction(currentNode) ? parentNode : parentNode.parentNode || parentNode);\n    const scope = typeGraph.scopes.get(scopeName); // $FlowIssue\n\n    if (scope === undefined || scope.type !== \"function\") {\n      return;\n    }\n\n    const declaration = scope.declaration;\n\n    if (!(declaration instanceof _variableInfo.VariableInfo)) {\n      throw new Error(\"Never!!!\");\n    }\n\n    return declaration;\n  }\n\n  constructor(parent) {\n    _defineProperty(this, \"body\", new Map());\n\n    _defineProperty(this, \"parent\", void 0);\n\n    this.parent = parent;\n  }\n\n  findVariable({\n    name,\n    loc\n  }, ...rest) {\n    let parent = this;\n\n    do {\n      const variableInfo = parent.body.get(name);\n\n      if (variableInfo !== undefined) {\n        if (variableInfo instanceof _variableInfo.VariableInfo) {\n          return variableInfo;\n        }\n\n        if (!(variableInfo instanceof Scope) && Scope.canTraverseFunction(rest)) {\n          // $FlowIssue\n          let result = Scope.addAndTraverseNodeWithType( // $FlowIssue\n          undefined, variableInfo, ...rest);\n\n          if (result === undefined) {\n            result = this.findVariable({\n              name,\n              loc\n            });\n          }\n\n          if (result !== undefined) {\n            return result;\n          }\n        }\n      }\n\n      parent = parent.parent;\n    } while (parent);\n\n    throw new _errors2.default(`Variable \"${name}\" is not defined!`, loc);\n  }\n\n  findRecord({\n    name,\n    loc\n  }) {\n    let parent = this;\n\n    do {\n      const recordInfo = parent.body.get(name);\n\n      if (recordInfo && !(recordInfo instanceof Scope)) {\n        return recordInfo;\n      }\n\n      parent = parent.parent;\n    } while (parent);\n\n    throw new _errors2.default(`Record \"${name}\" is not defined!`, loc);\n  }\n\n  isParentFor(scope) {\n    let parent = scope;\n\n    do {\n      if (parent === this) {\n        return true;\n      }\n\n      parent = parent.parent;\n    } while (parent != null);\n  }\n\n  getParentsUntil(parent) {\n    const parents = [];\n    let currentScope = this;\n\n    do {\n      parents.push(currentScope);\n      currentScope = currentScope.parent;\n    } while (currentScope !== null && currentScope !== parent);\n\n    return parents;\n  }\n\n  getAllChildScopes(module) {\n    const children = [];\n\n    for (const [_, scope] of module.scopes) {\n      if (this.isParentFor(scope)) {\n        children.push(scope);\n      }\n    }\n\n    return children;\n  }\n\n}\n\nexports.Scope = Scope;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createModuleScope = createModuleScope;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _checking = require(\"../checking\");\n\nvar _checking2 = _interopRequireDefault(_checking);\n\nvar _traverse = require(\"../utils/traverse\");\n\nvar _traverse2 = _interopRequireDefault(_traverse);\n\nvar _globals = require(\"../utils/globals\");\n\nvar _globals2 = _interopRequireDefault(_globals);\n\nvar _utilityTypes = require(\"../utils/utility-types\");\n\nvar _utilityTypes2 = _interopRequireDefault(_utilityTypes);\n\nvar _operators = require(\"../utils/operators\");\n\nvar _operators2 = _interopRequireDefault(_operators);\n\nvar _imports = require(\"../utils/imports\");\n\nvar _imports2 = _interopRequireDefault(_imports);\n\nvar _errors = require(\"../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./types/type\");\n\nvar _meta = require(\"./meta/meta\");\n\nvar _typeVar = require(\"./types/type-var\");\n\nvar _typeScope = require(\"./type-scope\");\n\nvar _refinement = require(\"../inference/refinement\");\n\nvar _unionType = require(\"./types/union-type\");\n\nvar _ignore = require(\"../utils/ignore\");\n\nvar _objectType = require(\"./types/object-type\");\n\nvar _genericType = require(\"./types/generic-type\");\n\nvar _functionType = require(\"./types/function-type\");\n\nvar _variableInfo = require(\"./variable-info\");\n\nvar _variableScope = require(\"./variable-scope\");\n\nvar _variableUtils = require(\"../utils/variable-utils\");\n\nvar _switchRefinement = require(\"../inference/switch-refinement\");\n\nvar _errorType = require(\"../inference/error-type\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nvar _moduleScope = require(\"./module-scope\");\n\nvar _call = require(\"./call\");\n\nvar _hierarchy = require(\"../utils/hierarchy\");\n\nvar _typeUtils = require(\"../utils/type-utils\");\n\nvar _functionUtils = require(\"../utils/function-utils\");\n\nvar _classUtils = require(\"../utils/class-utils\");\n\nvar _functionType2 = require(\"../inference/function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst hasTypeParams = node => node.typeParameters && (node.typeParameters.type === _nodes2.default.TYPE_PARAMETER_DECLARATION || node.typeParameters.type === _nodes2.default.TS_TYPE_PARAMETER_DECLARATION) && Array.isArray(node.typeParameters.params) && node.typeParameters.params.length !== 0;\n\nconst getAliasBody = node => {\n  switch (node.type) {\n    case _nodes2.default.TYPE_ALIAS:\n      return {\n        typeAnnotation: node.right\n      };\n\n    case _nodes2.default.TS_INTERFACE_DECLARATION:\n      return {\n        typeAnnotation: node\n      };\n\n    case _nodes2.default.TS_TYPE_ALIAS:\n      return node;\n  }\n\n  throw new Error(node.type);\n};\n\nconst addTypeAlias = (node, parentNode, typeGraph, precompute, middlecompute, postcompute) => {\n  const typeScope = typeGraph.typeScope;\n  const localTypeScope = new _typeScope.TypeScope(typeScope);\n  const typeName = node.id.name;\n\n  const self = _typeVar.TypeVar.createSelf(typeName, typeScope);\n\n  typeScope.body.set(typeName, self);\n  const genericArguments = node.typeParameters && node.typeParameters.params.map(typeAnnotation => (0, _typeUtils.getTypeFromTypeAnnotation)({\n    typeAnnotation\n  }, localTypeScope, typeGraph, true, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n  const name = genericArguments != undefined ? _genericType.GenericType.getName(typeName, genericArguments) : undefined;\n  const type = (0, _typeUtils.getTypeFromTypeAnnotation)(getAliasBody(node), localTypeScope, typeGraph, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute, name);\n  const typeAlias = genericArguments ? _genericType.GenericType.new(typeName, {\n    parent: typeScope\n  }, genericArguments, localTypeScope, type) : type;\n  self.root = typeAlias;\n  self.name = typeAlias.name;\n\n  if (genericArguments != null) {\n    typeAlias.shouldBeUsedAsGeneric = true;\n    self.shouldBeUsedAsGeneric = true;\n  }\n\n  typeScope.body.set(typeName, typeAlias);\n\n  if (node.exportAs) {\n    typeGraph.exportsTypes.set(node.exportAs, typeAlias);\n  }\n\n  if (typeGraph instanceof _moduleScope.PositionedModuleScope) {\n    typeGraph.addPosition(node.id, type);\n  }\n};\n\nconst fillModuleScope = (typeGraph, errors, isTypeDefinitions) => {\n  const typeScope = typeGraph.typeScope;\n  return (currentNode, parentNode, precompute, middlecompute, postcompute, meta = {}) => {\n    if (currentNode.type === _nodes2.default.EXPORT_NAMED_DECLARATION || currentNode.type === _nodes2.default.EXPORT_DEFAULT_DECLARATION) {\n      currentNode = currentNode.declaration;\n    }\n\n    switch (currentNode.type) {\n      case _nodes2.default.VARIABLE_DECLARATION:\n        if (currentNode.init != undefined) {\n          currentNode.declarations.forEach(a => Object.assign(a, {\n            init: currentNode.init\n          }));\n        }\n\n        break;\n\n      case _nodes2.default.VARIABLE_DECLARATOR:\n        const variableInfo = (0, _variableUtils.addVariableToGraph)(Object.assign(currentNode, meta), parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n        if (currentNode.init != undefined && variableInfo.type !== _type.Type.Unknown) {\n          currentNode.init.expected = variableInfo.type;\n        }\n\n        break;\n\n      case _nodes2.default.TYPE_ALIAS:\n      case _nodes2.default.TS_TYPE_ALIAS:\n      case _nodes2.default.TS_INTERFACE_DECLARATION:\n        addTypeAlias(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.CLASS_DECLARATION:\n      case _nodes2.default.CLASS_EXPRESSION:\n      case _nodes2.default.OBJECT_EXPRESSION:\n        (0, _classUtils.addClassScopeToTypeGraph)(currentNode, parentNode, typeGraph);\n        break;\n\n      case _nodes2.default.LOGICAL_EXPRESSION:\n      case _nodes2.default.CONDITIONAL_EXPRESSION:\n      case _nodes2.default.SWITCH_CASE:\n        (0, _refinement.refinement)(currentNode, (0, _scopeUtils.getParentForNode)(currentNode, parentNode, typeGraph), typeScope, typeGraph);\n        break;\n\n      case _nodes2.default.IF_STATEMENT:\n      case _nodes2.default.WHILE_STATEMENT:\n      case _nodes2.default.DO_WHILE_STATEMENT:\n      case _nodes2.default.FOR_STATEMENT:\n      case _nodes2.default.FOR_OF_STATEMENT:\n      case _nodes2.default.FOR_IN_STATEMENT:\n      case _nodes2.default.FOR_IN_STATEMENT:\n        const block = currentNode.body || currentNode.consequent;\n        (0, _scopeUtils.addScopeToTypeGraph)(block, parentNode, typeGraph, currentNode);\n\n        if (currentNode.alternate) {\n          (0, _scopeUtils.addScopeToTypeGraph)(currentNode.alternate, parentNode, typeGraph, currentNode.alternate);\n        }\n\n        if (![_nodes2.default.FOR_OF_STATEMENT, _nodes2.default.FOR_IN_STATEMENT].includes(currentNode.type)) {\n          (0, _refinement.refinement)(currentNode, (0, _scopeUtils.getParentForNode)(block, parentNode, typeGraph), typeScope, typeGraph);\n        }\n\n        if (currentNode.test != undefined) {\n          currentNode.test.isRefinemented = true;\n        }\n\n        break;\n\n      case _nodes2.default.FUNCTION_DECLARATION:\n      case _nodes2.default.TS_FUNCTION_DECLARATION:\n        const existedRecord = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, typeGraph).findRecord(currentNode.id);\n\n        if (existedRecord instanceof _variableInfo.VariableInfo) {\n          return false;\n        }\n\n      case _nodes2.default.FUNCTION_EXPRESSION:\n      case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n        const functionVariable = (0, _functionUtils.addFunctionToTypeGraph)(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute, isTypeDefinitions);\n\n        if (currentNode.exportAs) {\n          // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n          typeGraph.exports.set(currentNode.exportAs, functionVariable);\n        }\n\n        break;\n\n      case _nodes2.default.BLOCK_STATEMENT:\n        if (_nodes2.default.isFunction(parentNode) && parentNode.body === currentNode) {\n          break;\n        }\n\n        (0, _scopeUtils.addScopeToTypeGraph)(currentNode, parentNode, typeGraph, currentNode);\n        break;\n\n      case _nodes2.default.OBJECT_METHOD:\n      case _nodes2.default.CLASS_METHOD:\n      case _nodes2.default.CLASS_PRIVATE_METHOD:\n      case _nodes2.default.TS_DECLARE_METHOD:\n        (0, _call.addMethodToThis)(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute, isTypeDefinitions);\n        break;\n\n      case _nodes2.default.TRY_STATEMENT:\n        currentNode.block.skipCalls = true;\n        const tryBlock = (0, _scopeUtils.getScopeFromNode)(currentNode.block, parentNode, typeGraph, undefined, \"try\");\n        tryBlock.throwable = [];\n        typeGraph.scopes.set(_variableScope.VariableScope.getName(currentNode.block), tryBlock);\n\n        if (!currentNode.handler) {\n          return true;\n        }\n\n        const handlerScopeKey = _variableScope.VariableScope.getName(currentNode.handler.body);\n\n        typeGraph.scopes.set(handlerScopeKey, (0, _scopeUtils.getScopeFromNode)(currentNode.handler.body, parentNode, typeGraph, undefined, \"catch\"));\n\n        if (!currentNode.handler.param) {\n          return true;\n        }\n\n        (0, _variableUtils.addVariableToGraph)(currentNode.handler.param, currentNode.handler.body, typeGraph, precompute, middlecompute, postcompute, currentNode.handler.param.name);\n        break;\n    }\n\n    return true;\n  };\n};\n\nconst middlefillModuleScope = (typeGraph, errors, isTypeDefinitions) => {\n  const typeScope = typeGraph.typeScope;\n  return (currentNode, parentNode, precompute, middlecompute, postcompute, meta = {}) => {\n    if (currentNode.type === _nodes2.default.EXPORT_NAMED_DECLARATION || currentNode.type === _nodes2.default.EXPORT_DEFAULT_DECLARATION) {\n      currentNode = currentNode.declaration || currentNode;\n    }\n\n    switch (currentNode.type) {\n      case _nodes2.default.IMPORT_DECLARATION:\n        errors.push(new _errors2.default(\"All imports should be placed at the top of text document without any statements between.\", currentNode.loc, typeGraph.path));\n        break;\n\n      case _nodes2.default.INTERFACE_DECLARATION:\n        if (isTypeDefinitions) {\n          return;\n        }\n\n        errors.push(new _errors2.default(\"Interfaces do not exist in Hegel. Use 'type alias' instead.\", currentNode.loc, typeGraph.path));\n        break;\n\n      case _nodes2.default.THIS_TYPE_DEFINITION:\n        (0, _classUtils.addThisToClassScope)(currentNode, parentNode, typeScope, typeGraph, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.OBJECT_PROPERTY:\n      case _nodes2.default.OBJECT_METHOD:\n      case _nodes2.default.CLASS_PROPERTY:\n      case _nodes2.default.CLASS_METHOD:\n      case _nodes2.default.CLASS_PRIVATE_METHOD:\n      case _nodes2.default.CLASS_PRIVATE_PROPERTY:\n        (0, _classUtils.addPropertyNodeToThis)(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.FUNCTION_DECLARATION:\n      case _nodes2.default.TS_FUNCTION_DECLARATION:\n        (0, _functionUtils.addFunctionNodeToTypeGraph)(currentNode, parentNode, typeGraph);\n        break;\n\n      case _nodes2.default.TS_INTERFACE_DECLARATION:\n      case _nodes2.default.CLASS_DECLARATION:\n      case _nodes2.default.TS_TYPE_ALIAS:\n        if (currentNode.type === _nodes2.default.CLASS_DECLARATION && !isTypeDefinitions) {\n          return;\n        }\n\n        (0, _typeUtils.addTypeNodeToTypeGraph)(currentNode, typeGraph);\n        break;\n    }\n  };\n};\n\nconst afterFillierActions = (moduleScope, errors, isTypeDefinitions) => {\n  return (currentNode, parentNode, precompute, middlecompute, postcompute, meta = {}) => {\n    if (currentNode.type === _nodes2.default.EXPORT_NAMED_DECLARATION || currentNode.type === _nodes2.default.EXPORT_DEFAULT_DECLARATION) {\n      currentNode = currentNode.declaration;\n    }\n\n    const currentScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, moduleScope);\n    const typeScope = (0, _scopeUtils.findNearestTypeScope)(currentScope, moduleScope);\n\n    switch (currentNode.type) {\n      case _nodes2.default.OBJECT_EXPRESSION:\n        const obj = (0, _classUtils.addObjectToTypeGraph)(currentNode, moduleScope);\n\n        if (currentNode.exportAs) {\n          moduleScope.exports.set(currentNode.exportAs, obj);\n        }\n\n        break;\n\n      case _nodes2.default.CLASS_PROPERTY:\n      case _nodes2.default.OBJECT_PROPERTY:\n      case _nodes2.default.CLASS_PRIVATE_PROPERTY:\n        (0, _call.addPropertyToThis)(currentNode, parentNode, typeScope, moduleScope, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.SWITCH_STATEMENT:\n        (0, _switchRefinement.findUnhandledCases)(currentNode, errors, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute);\n        break;\n\n      case _nodes2.default.CLASS_DECLARATION:\n      case _nodes2.default.CLASS_EXPRESSION:\n        const classConstructor = (0, _classUtils.addClassToTypeGraph)(currentNode, typeScope, moduleScope, parentNode, precompute, middlecompute, postcompute, isTypeDefinitions);\n\n        if (currentNode.exportAs) {\n          // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n          moduleScope.exports.set(currentNode.exportAs, classConstructor);\n          moduleScope.exportsTypes.set(currentNode.exportAs, // $FlowIssue\n          classConstructor.type.instanceType);\n        }\n\n        break;\n\n      case _nodes2.default.TYPE_ALIAS:\n      case _nodes2.default.TS_TYPE_ALIAS:\n      case _nodes2.default.TS_INTERFACE_DECLARATION:\n        const type = _type.Type.find(currentNode.id.name, {\n          parent: typeScope\n        }, parentNode, moduleScope, precompute, middlecompute, postcompute);\n\n        if (currentNode.exportAs && !moduleScope.exportsTypes.has(currentNode.exportAs)) {\n          moduleScope.exportsTypes.set(currentNode.exportAs, type);\n        }\n\n        break;\n\n      case _nodes2.default.VARIABLE_DECLARATION:\n        break;\n\n      case _nodes2.default.EXPORT_LIST:\n        const isTypeExport = currentNode.exportKind === \"type\";\n        const specifiersSource = isTypeExport ? moduleScope.typeScope : moduleScope;\n        const specifiersTarget = isTypeExport ? moduleScope.exportsTypes : moduleScope.exports;\n        currentNode.specifiers.forEach(({\n          local,\n          exported\n        }) => {\n          const existedVariableOrType = specifiersSource instanceof _moduleScope.ModuleScope ? specifiersSource.findVariable(local, parentNode, moduleScope, precompute, middlecompute, postcompute) : specifiersSource.findTypeWithName(local.name, parentNode, moduleScope, precompute, middlecompute, postcompute); // $FlowIssue\n\n          specifiersTarget.set(exported.name, existedVariableOrType);\n        });\n        break;\n\n      case _nodes2.default.VARIABLE_DECLARATOR:\n        const variableInfo = currentScope.findVariable(currentNode.id);\n        const newTypeOrVar = isTypeDefinitions && currentNode.init === null ? _type.Type.Unknown : (0, _call.addCallToTypeGraph)(currentNode, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute);\n\n        if (currentNode.id != null && currentNode.id.typeAnnotation == undefined && currentNode.init !== null) {\n          const newType = newTypeOrVar.result instanceof _variableInfo.VariableInfo ? newTypeOrVar.result.type : newTypeOrVar.result;\n          variableInfo.type = (0, _variableUtils.getVariableType)(variableInfo, newType, typeScope, newTypeOrVar.inferenced);\n        }\n\n        if (currentNode.exportAs) {\n          moduleScope.exports.set(currentNode.exportAs, variableInfo);\n        }\n\n        break;\n\n      case _nodes2.default.BLOCK_STATEMENT:\n        if (!currentNode.catchBlock || !currentNode.catchBlock.param) {\n          return;\n        }\n\n        if (currentNode.catchBlock.param.type !== _nodes2.default.IDENTIFIER) {\n          throw new Error(\"Unsupported yet\");\n        }\n\n        const errorVariable = (0, _scopeUtils.getParentForNode)(currentNode.catchBlock.param, currentNode.catchBlock.body, moduleScope).findVariable(currentNode.catchBlock.param, parentNode, moduleScope, precompute, middlecompute, postcompute);\n        errorVariable.type = (0, _errorType.inferenceErrorType)(currentNode, moduleScope);\n        errorVariable.type = _unionType.UnionType.term(null, {}, [_type.Type.Unknown, errorVariable.type]);\n\n        if (moduleScope instanceof _moduleScope.PositionedModuleScope) {\n          moduleScope.addPosition(currentNode.catchBlock.param, errorVariable);\n        }\n\n        break;\n\n      case _nodes2.default.IF_STATEMENT:\n      case _nodes2.default.RETURN_STATEMENT:\n      case _nodes2.default.EXPRESSION_STATEMENT:\n      case _nodes2.default.WHILE_STATEMENT:\n      case _nodes2.default.DO_WHILE_STATEMENT:\n      case _nodes2.default.FOR_STATEMENT:\n      case _nodes2.default.THROW_STATEMENT:\n      case _nodes2.default.NEW_EXPRESSION:\n        const resultOfCall = (0, _call.addCallToTypeGraph)(currentNode, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute, {\n          isForInit: parentNode.kind === \"constructor\"\n        }).result;\n        const invocationResultType = resultOfCall instanceof _variableInfo.VariableInfo ? resultOfCall.type : resultOfCall;\n\n        if ((0, _functionUtils.isSideEffectCall)(currentNode, invocationResultType)) {\n          const functionName = currentNode.expression.callee.name || \"Anonymous Function\";\n          errors.push(new _errors2.default(`You use function \"${functionName}\" as side effect function, but it returns a ${String(invocationResultType.name)} type`, currentNode.loc, moduleScope.path));\n        }\n\n        if (currentNode.exportAs) {\n          const exportVar = resultOfCall instanceof _variableInfo.VariableInfo ? resultOfCall : new _variableInfo.VariableInfo(resultOfCall, moduleScope);\n          moduleScope.exports.set(currentNode.exportAs, exportVar);\n        }\n\n        break;\n\n      case _nodes2.default.OBJECT_METHOD:\n      case _nodes2.default.CLASS_METHOD:\n      case _nodes2.default.CLASS_PRIVATE_METHOD:\n      case _nodes2.default.FUNCTION_EXPRESSION:\n      case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n      case _nodes2.default.FUNCTION_DECLARATION:\n        const functionScope = moduleScope.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n        if (functionScope === undefined) {\n          throw new Error(\"Never!!!\");\n        }\n\n        const {\n          declaration\n        } = functionScope;\n\n        if (declaration === undefined) {\n          throw new Error(\"Never!!!\");\n        }\n\n        const declarationType = declaration.type instanceof _genericType.GenericType ? declaration.type.subordinateType : declaration.type;\n\n        if (declarationType instanceof _objectType.ObjectType) {\n          throw new Error(\"Never!!!\");\n        }\n\n        if (!isTypeDefinitions && (functionScope.throwable == undefined || functionScope.throwable.length === 0) && declarationType.throwable !== undefined) {\n          throw new _errors2.default(`Function should throw \"${String(declarationType.throwable.name)}\" but throws nothing`, currentNode.returnType ? currentNode.returnType.loc : currentNode.loc);\n        }\n\n        if (functionScope.throwable != undefined && functionScope.throwable.length !== 0 && declarationType.throwable === undefined) {\n          const throwableType = (0, _errorType.inferenceErrorType)(currentNode, moduleScope);\n\n          const fnName = _functionType.FunctionType.getName(declarationType.argumentsTypes, declarationType.returnType, declaration.type instanceof _genericType.GenericType ? declaration.type.genericArguments : [], declarationType.isAsync, throwableType);\n\n          let newFunctionType = _functionType.FunctionType.term(fnName, {}, declarationType.argumentsTypes, declarationType.returnType, declarationType.isAsync);\n\n          newFunctionType.throwable = throwableType;\n\n          if (declaration.type instanceof _genericType.GenericType && newFunctionType instanceof _functionType.FunctionType) {\n            newFunctionType = _genericType.GenericType.new(fnName, {}, declaration.type.genericArguments, declaration.type.localTypeScope, newFunctionType);\n          }\n\n          declaration.type = newFunctionType;\n        }\n\n        const fnType = functionScope.declaration && functionScope.declaration.type;\n\n        if (fnType instanceof _genericType.GenericType && functionScope.type === _variableScope.VariableScope.FUNCTION_TYPE && fnType.subordinateType instanceof _functionType.FunctionType) {\n          // $FlowIssue - Type refinements\n          (0, _functionType2.prepareGenericFunctionType)(functionScope);\n\n          if (fnType.genericArguments.some(a => !a.isUserDefined)) {\n            (0, _functionType2.inferenceFunctionTypeByScope)( // $FlowIssue - Type refinements\n            functionScope, typeScope, moduleScope);\n          }\n        }\n\n        if (currentNode.exportAs) {\n          // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n          moduleScope.exports.set(currentNode.exportAs, declaration);\n        }\n\n        break;\n\n      case _nodes2.default.TS_EXPORT_ASSIGNMENT:\n        let whatWillBeExported = (0, _call.addCallToTypeGraph)(currentNode.expression, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute).result;\n\n        if (whatWillBeExported instanceof _type.Type) {\n          whatWillBeExported = new _variableInfo.VariableInfo(whatWillBeExported, moduleScope);\n        }\n\n        moduleScope.exports.set(\"default\", whatWillBeExported);\n        const exportedType = whatWillBeExported.type;\n\n        if (exportedType instanceof _objectType.ObjectType) {\n          exportedType.properties.forEach((value, key) => {\n            moduleScope.exports.set(key, value);\n          });\n        }\n\n        break;\n\n      default:\n        if (currentNode.exportAs) {\n          const value = (0, _call.addCallToTypeGraph)(currentNode, moduleScope, currentScope, parentNode, precompute, middlecompute, postcompute, {\n            isTypeDefinitions\n          }).result;\n          moduleScope.exports.set(currentNode.exportAs, value instanceof _variableInfo.VariableInfo ? value : new _variableInfo.VariableInfo(value, currentScope, new _meta.Meta(currentNode.loc)));\n        }\n\n        break;\n    }\n\n    if (currentNode.type === _nodes2.default.THROW_STATEMENT || currentNode.type === _nodes2.default.RETURN_STATEMENT) {\n      throw new _errors.UnreachableError(currentNode.loc);\n    }\n  };\n};\n\nasync function createModuleScope(file, globalErrors, getModuleTypeGraph, globalModule, isTypeDefinitions, withPositions = true) {\n  const errors = _ignore.IgnorableArray.withIgnoring(file.comments);\n\n  const ast = file.program;\n  const typeScope = new _typeScope.TypeScope(globalModule.typeScope);\n  const module = new (withPositions ? _moduleScope.PositionedModuleScope : _moduleScope.ModuleScope)(file.path, new Map(), globalModule, typeScope);\n  await (0, _imports2.default)(ast, file.path, errors, module, typeScope, getModuleTypeGraph, isTypeDefinitions);\n\n  try {\n    (0, _traverse2.default)(ast, fillModuleScope(module, errors, isTypeDefinitions), middlefillModuleScope(module, errors, isTypeDefinitions), afterFillierActions(module, errors, isTypeDefinitions));\n  } catch (e) {\n    if (!(e instanceof _errors2.default) && !Array.isArray(e)) {\n      throw e;\n    }\n\n    if (Array.isArray(e)) {\n      errors.push(...e.map(e => Object.assign(e, {\n        source: file.path\n      })));\n    } else {\n      e.source = file.path;\n      errors.push(e);\n    }\n  }\n\n  module.scopes.forEach(scope => (0, _checking2.default)(file.path, scope, typeScope, errors));\n  (0, _checking2.default)(file.path, module, typeScope, errors);\n  globalErrors.push(...errors);\n  return module;\n}\n\nasync function createGlobalScope(files, getModuleTypeGraph, isTypeDefinitions = false, mixTypeDefinitions = a => {}, withPositions = false) {\n  const errors = [];\n  const globalModule = new _moduleScope.ModuleScope(\"#global\");\n  _type.Type.prettyMode = withPositions;\n  (0, _hierarchy.setupBaseHierarchy)(globalModule.typeScope);\n  (0, _globals2.default)(globalModule);\n  (0, _utilityTypes2.default)(globalModule);\n  await mixTypeDefinitions(globalModule);\n  (0, _hierarchy.setupFullHierarchy)(globalModule.typeScope);\n  (0, _operators2.default)(globalModule);\n\n  const createDependencyModuleScope = (file, isTypeDefinitions) => createModuleScope(file, errors, getModuleFromString, globalModule, isTypeDefinitions);\n\n  const getModuleFromString = (path, currentPath, loc) => getModuleTypeGraph(path, currentPath, loc, createDependencyModuleScope);\n\n  const modules = await Promise.all(files.map(module => createModuleScope(module, errors, getModuleFromString, globalModule, isTypeDefinitions, withPositions)));\n  (0, _hierarchy.dropAllGlobals)();\n  return [modules, errors, globalModule];\n}\n\nexports.default = createGlobalScope;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeScope = undefined;\n\nvar _type = require(\"./types/type\");\n\nvar _scope = require(\"./scope\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass TypeScope {\n  constructor(parent) {\n    _defineProperty(this, \"priority\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"body\", new Map());\n\n    this.parent = parent === undefined ? null : parent;\n    this.priority = parent === undefined ? TypeScope.GLOBAL_SCOPE_PRIORITY : parent.priority + 1;\n  }\n\n  makeCustom() {\n    this.priority += 100;\n  }\n\n  findTypeWithName(name, ...rest) {\n    let currentTypeScope = this;\n    let existedType = undefined;\n\n    while (currentTypeScope !== null) {\n      existedType = currentTypeScope.body.get(name);\n\n      if (existedType !== undefined) {\n        if (existedType instanceof _type.Type) {\n          return _type.Type.getTypeRoot(existedType);\n        }\n\n        if (_scope.Scope.canTraverseFunction(rest)) {\n          // $FlowIssue\n          let result = _scope.Scope.addAndTraverseNodeWithType( // $FlowIssue\n          undefined, existedType, ...rest);\n\n          result = result === undefined ? this.findTypeWithName(name) : result.type;\n\n          if (result !== undefined) {\n            return _type.Type.getTypeRoot(result);\n          }\n        }\n      }\n\n      currentTypeScope = currentTypeScope.parent;\n    }\n\n    return undefined;\n  }\n\n}\n\nexports.TypeScope = TypeScope;\n\n_defineProperty(TypeScope, \"GLOBAL_SCOPE_PRIORITY\", 0);\n\n_defineProperty(TypeScope, \"MODULE_SCOPE_PRIORITY\", 1);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$BottomType = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _functionType = require(\"./function-type\");\n\nclass $BottomType extends _type.Type {\n  static get name() {\n    return \"$BottomType\";\n  }\n\n  static getParent(meta, _, genericArguments = []) {\n    return genericArguments.reduce((parent, type) => parent.priority < type.parent.priority ? type.parent : parent, meta.parent || _type.Type.GlobalTypeScope);\n  }\n\n  static new(name, meta = {}, ...args) {\n    const parent = this.getParent(meta, ...args);\n    const newMeta = { ...meta,\n      parent\n    };\n    const newType = new this(newMeta, ...args);\n    parent.body.set(name, newType);\n    return newType;\n  }\n\n  static getName(name, parameters) {\n    name = name.replace(/<.+>/g, \"\");\n\n    if (parameters.length === 0) {\n      return String(name);\n    }\n\n    return `${String(name)}<${parameters.reduce((res, t) => `${res}${res ? \", \" : \"\"}${String(_type.Type.getTypeRoot(t).name)}`, \"\")}>`;\n  }\n\n  constructor(meta, subordinateMagicType, genericArguments = [], loc) {\n    meta = { ...meta,\n      parent: $BottomType.getParent(meta, subordinateMagicType, genericArguments)\n    };\n    super($BottomType.getName(subordinateMagicType.name, genericArguments), meta);\n    this.subordinateMagicType = subordinateMagicType;\n    this.genericArguments = genericArguments;\n    this.loc = loc;\n    this.priority = subordinateMagicType.priority + 1;\n    this.isForAssign = meta.isForAssign;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n    let includedUndefined = false;\n    let includedBottom = false;\n    let includedTypeVar = false;\n    const includedSelfIndex = sourceTypes.findIndex(t => this.equalsTo(t));\n\n    if (includedSelfIndex !== -1) {\n      return this.endChanges(targetTypes[includedSelfIndex]);\n    }\n\n    const mapper = argument => {\n      if (argument instanceof $BottomType) {\n        const newType = argument.changeAll(sourceTypes, targetTypes, typeScope);\n        includedBottom = true;\n        return newType !== argument ? newType : undefined;\n      }\n\n      if (argument instanceof _typeVar.TypeVar) {\n        const argumentIndex = sourceTypes.findIndex(a => argument instanceof $BottomType ? argument.subordinateType === a : a.equalsTo(argument));\n        const result = argumentIndex === -1 ? undefined : targetTypes[argumentIndex];\n\n        if (result === undefined) {\n          includedUndefined = true;\n        }\n\n        if (result instanceof _typeVar.TypeVar && !_typeVar.TypeVar.isSelf(result)) {\n          includedTypeVar = true;\n        }\n\n        return result;\n      }\n\n      if (argument instanceof _unionType.UnionType) {\n        const newType = argument.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (newType.parent.priority > _typeScope.TypeScope.MODULE_SCOPE_PRIORITY) {\n          includedTypeVar = true;\n        }\n\n        return newType;\n      }\n\n      return argument;\n    };\n\n    try {\n      const appliedParameters = this.genericArguments.map(mapper);\n\n      if (appliedParameters.every(a => a === undefined)) {\n        return this.endChanges(this);\n      }\n\n      if (includedUndefined) {\n        const type = this.subordinateMagicType.changeAll(sourceTypes, targetTypes, typeScope);\n        return this.endChanges(new $BottomType({}, type, type.genericArguments, this.loc));\n      }\n\n      if (includedBottom || includedTypeVar) {\n        return this.endChanges(new $BottomType({}, this.subordinateMagicType, appliedParameters, this.loc));\n      }\n\n      const target = this.subordinateMagicType instanceof _typeVar.TypeVar && this.subordinateMagicType.root != undefined ? this.subordinateMagicType.root : this.subordinateMagicType;\n      return this.endChanges(target.applyGeneric(appliedParameters, this.loc, false, false, this.isForASsign));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  unpack(loc = this.loc) {\n    const target = this.subordinateMagicType instanceof _typeVar.TypeVar && this.subordinateMagicType.root != undefined ? _type.Type.getTypeRoot(this.subordinateMagicType) : this.subordinateMagicType;\n\n    if (\"subordinateType\" in target) {\n      const parameters = this.genericArguments.map(t => {\n        if (t instanceof $BottomType) {\n          t = t.unpack(loc);\n        }\n\n        if (t instanceof _typeVar.TypeVar && t.root !== undefined) {\n          t = _type.Type.getTypeRoot(t);\n        }\n\n        return t;\n      });\n      return target.applyGeneric(parameters, loc, true, true, this.isForAssign);\n    }\n\n    throw new Error(`Never!!! ${target.constructor.name}`);\n  }\n\n  isPrincipalTypeFor(other) {\n    if (this._alreadyProcessedWith === other || this.equalsTo(other)) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = other;\n    const self = this.unpack();\n\n    if (self instanceof $BottomType) {\n      return super.isPrincipalTypeFor(other);\n    }\n\n    const result = self.isPrincipalTypeFor(other);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize, isCalledAsBottom, ...args) {\n    const returnType = parameters.some(p => p instanceof _typeVar.TypeVar && p.isUserDefined) ? new $BottomType({}, this.subordinateMagicType, parameters, loc) : this.subordinateMagicType.applyGeneric(parameters, loc, shouldBeMemoize, true, this.isForAssign);\n    return _functionType.FunctionType.term(_functionType.FunctionType.getName(parameters, returnType), {}, parameters, returnType);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    if (type instanceof _typeVar.TypeVar) {\n      return [{\n        root: this,\n        variable: type\n      }];\n    }\n\n    if (type instanceof $BottomType) {\n      type = type.subordinateMagicType;\n    }\n\n    const subordinate = this.getOponentType(this.subordinateMagicType);\n    this._alreadyProcessedWith = type;\n    const diff = subordinate.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return \"genericArguments\" in subordinate ? diff.map(diff => {\n      const index = subordinate.genericArguments.indexOf(diff.variable);\n\n      if (index === -1) {\n        return diff;\n      }\n\n      return {\n        variable: this.genericArguments[index],\n        root: diff.root\n      };\n    }) : diff;\n  }\n\n  getRootedSubordinateType() {\n    const {\n      subordinateMagicType\n    } = this;\n\n    if (\"subordinateType\" in subordinateMagicType) {\n      subordinateMagicType.genericArguments.forEach((arg, index) => {\n        arg.root = this.genericArguments[index];\n      });\n    }\n\n    return subordinateMagicType;\n  }\n\n  unrootSubordinateType() {\n    const {\n      subordinateMagicType\n    } = this;\n\n    if (\"subordinateType\" in subordinateMagicType) {\n      subordinateMagicType.genericArguments.forEach((arg, index) => {\n        arg.root = undefined;\n      });\n    }\n  }\n\n  equalsTo(type) {\n    if (this.referenceEqualsTo(type)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === type) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = type;\n\n    const result = type instanceof $BottomType && this.canContain(type) && this.genericArguments.length === type.genericArguments.length && this.genericArguments.every((arg, i) => arg.equalsTo(type.genericArguments[i])) && _type.Type.getTypeRoot(this.subordinateMagicType) === _type.Type.getTypeRoot(type.subordinateMagicType);\n\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = this.genericArguments.some(a => a.contains(type)) || this.subordinateMagicType.contains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = this.genericArguments.some(a => a.weakContains(type)) || this.subordinateMagicType.weakContains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  makeNominal() {\n    this.subordinateMagicType.makeNominal();\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [...this.genericArguments].map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.$BottomType = $BottomType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Class = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Class extends _genericType.GenericType {\n  static get name() {\n    return \"$Class\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Class\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType && realTarget.classType !== null)) {\n      throw new _errors2.default(\"Cannot apply $Class to non-class instance type\", loc);\n    }\n\n    return realTarget.classType;\n  }\n\n}\n\nexports.$Class = $Class;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Collection = exports.CollectionType = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass CollectionType extends _type.Type {\n  static get name() {\n    return \"CollectionType\";\n  }\n\n  static term(name, meta = {}, keyType, valueType, ...args) {\n    let parent = meta.parent;\n\n    if (parent === undefined || keyType.parent.priority > parent.priority) {\n      parent = keyType.parent;\n    }\n\n    if (parent === undefined || valueType.parent.priority > parent.priority) {\n      parent = valueType.parent;\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, keyType, valueType, ...args);\n  }\n\n  static getName(keyType, valueType) {\n    return `{ [key: ${String(_type.Type.getTypeRoot(keyType).name)}]: ${String(_type.Type.getTypeRoot(valueType).name)} }`;\n  }\n\n  constructor(name, meta = {}, keyType, valueType) {\n    super(name, meta);\n\n    _defineProperty(this, \"keyType\", void 0);\n\n    _defineProperty(this, \"valueType\", void 0);\n\n    _defineProperty(this, \"priority\", 2);\n\n    this.keyType = keyType;\n    this.valueType = valueType;\n    this.onlyLiteral = true;\n  }\n\n  getPropertyType(propertyName, isForAssign = false) {\n    const result = super.getPropertyType(propertyName);\n\n    if (result !== null) {\n      return result;\n    }\n\n    if (typeof propertyName === this.keyType.name || propertyName === this.keyType.name) {\n      if (isForAssign) {\n        return this.valueType;\n      }\n\n      const result = this.valueType instanceof _unionType.UnionType && this.valueType.variants.some(a => a.equalsTo(_type.Type.Undefined)) ? this.valueType : _unionType.UnionType.term(null, {}, [this.valueType, _type.Type.Undefined]);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return null;\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType, true, false);\n\n    if (this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    if (\"readonly\" in anotherType && this.equalsTo( // $FlowIssue ReadonlyArray is always GenericType\n    _tupleType.TupleType.ReadonlyArray.root.applyGeneric([this.valueType]).readonly) && this === anotherType.readonly) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = anotherType instanceof CollectionType && super.equalsTo(anotherType) && this.canContain(anotherType) && this.keyType.equalsTo(anotherType.keyType) && this.valueType.equalsTo(anotherType.valueType);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    const selfNameWithoutApplying = _genericType.GenericType.getNameWithoutApplying(this.name);\n\n    const otherfNameWithoutApplying = _genericType.GenericType.getNameWithoutApplying(anotherType.name);\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = anotherType instanceof CollectionType && selfNameWithoutApplying === otherfNameWithoutApplying && this.keyType.equalsTo(anotherType.keyType) && this.valueType.isPrincipalTypeFor(anotherType.valueType) || anotherType instanceof _tupleType.TupleType && (this.equalsTo( // $FlowIssue Array is always GenericType\n    CollectionType.Array.root.applyGeneric([this.valueType])) || this.equalsTo( // $FlowIssue ReadonlyArray is always GenericType\n    _tupleType.TupleType.ReadonlyArray.root.applyGeneric([this.valueType]))) && anotherType.items.every(t => this.valueType.isPrincipalTypeFor(t));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      const newValueType = this.valueType.changeAll(sourceTypes, targetTypes, typeScope);\n      const isSubtypeOf = this.isSubtypeOf && this.isSubtypeOf.changeAll(sourceTypes, targetTypes, typeScope);\n      return this.endChanges(newValueType === this.valueType && isSubtypeOf === this.isSubtypeOf ? this : CollectionType.term(this.getChangedName(sourceTypes, targetTypes), {\n        isSubtypeOf\n      }, this.keyType, newValueType));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    type = this.getOponentType(type);\n\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof _tupleType.TupleType) {\n      // $FlowIssue\n      type = type.isSubtypeOf;\n    }\n\n    if (type instanceof CollectionType) {\n      const keyDiff = this.keyType.getDifference(type.keyType, withReverseUnion);\n      const valueDiff = this.valueType.getDifference(type.valueType, withReverseUnion);\n      this._alreadyProcessedWith = null;\n      return keyDiff.concat(valueDiff);\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.keyType.contains(type) || this.valueType.contains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.keyType.weakContains(type) || this.valueType.weakContains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  makeNominal() {\n    // $FlowIssue\n    this.isSubtypeOf.makeNominal();\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [this.keyType, this.valueType].map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.CollectionType = CollectionType;\n\n_defineProperty(CollectionType, \"Array\", new _typeVar.TypeVar(\"Array\"));\n\nclass $Collection extends _genericType.GenericType {\n  static get name() {\n    return \"$Collection\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Collection\", meta, [_typeVar.TypeVar.term(\"key\", {\n      parent\n    }), _typeVar.TypeVar.term(\"value\", {\n      parent\n    })], parent, // $FlowIssue\n    null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [key, value] = parameters;\n    return CollectionType.term(`$Collection<${String(key.name)}, ${String(value.name)}>`, {}, key, value);\n  }\n\n}\n\nexports.$Collection = $Collection;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Entries = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Entries extends _genericType.GenericType {\n  static get name() {\n    return \"$Entries\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Entries\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    super.assertParameters(parameters, loc);\n    const [currentTarget] = parameters;\n    const realTarget = this.getOponentType(currentTarget);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType) && !(realTarget instanceof _collectionType.CollectionType)) {\n      throw new _errors2.default(\"First parameter should be an object or collection type\", loc);\n    }\n\n    if (realTarget instanceof _collectionType.CollectionType) {\n      return _tupleType.TupleType.term(null, {}, [realTarget.keyType, realTarget.valueType]);\n    }\n\n    const values = [...realTarget.properties.entries()];\n    const variants = values.map(([key, value]) => _tupleType.TupleType.term(null, {}, [_type.Type.term(`'${key}'`, {\n      isSubtypeOf: _type.Type.String\n    }), value.type]));\n\n    if (!realTarget.isStrict) {\n      variants.push(_type.Type.Unknown);\n    }\n\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n}\n\nexports.$Entries = $Entries;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Exclude = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Exclude extends _genericType.GenericType {\n  static get name() {\n    return \"$Exclude\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Exclude\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    }), _typeVar.TypeVar.term(\"properties\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target, whichShouldBeExclude] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _unionType.UnionType)) {\n      throw new _errors2.default(\"First parameter should be an union type\", loc);\n    }\n\n    const picks = whichShouldBeExclude instanceof _unionType.UnionType ? whichShouldBeExclude.variants : [whichShouldBeExclude];\n    const pickedVariants = target.variants.filter(variant => picks.find(pick => pick.equalsTo(variant)) === undefined);\n    return _unionType.UnionType.term(null, {}, pickedVariants);\n  }\n\n}\n\nexports.$Exclude = $Exclude;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FunctionType = exports.RestArgument = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _constants = require(\"../constants\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass RestArgument extends _type.Type {\n  static get name() {\n    return \"RestArgument\";\n  }\n\n  static term(name, meta = {}, type, ...args) {\n    name = name == null ? this.getName(type) : name;\n    const newMeta = { ...meta,\n      parent: meta.parent === undefined || type.parent.priority > meta.parent.priority ? type.parent : meta.parent\n    };\n    return super.term(name, newMeta, type, ...args);\n  }\n\n  static getName(type) {\n    return `...${String(type.name)}`;\n  }\n\n  constructor(name, meta = {}, type) {\n    name = name == null ? RestArgument.getName(type) : name;\n    super(name, meta);\n\n    _defineProperty(this, \"type\", void 0);\n\n    this.type = type;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.name, this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      const newType = this.type.changeAll(sourceTypes, targetTypes, typeScope);\n      return this.endChanges(this.type === newType ? this : RestArgument.term(null, {}, newType));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  isType(action, anotherType) {\n    if (!(anotherType instanceof RestArgument)) {\n      return false;\n    }\n\n    const selfType = this.getOponentType(this.type, false);\n    const otherType = this.getOponentType(anotherType.type, false);\n\n    if (!(\"valueType\" in selfType && \"valueType\" in otherType)) {\n      return false;\n    } // $FlowIssue\n\n\n    return selfType.valueType[action](otherType.valueType);\n  }\n\n  equalsTo(anotherType) {\n    return this.isType(\"equalsTo\", anotherType);\n  }\n\n  isSuperTypeFor(anotherType) {\n    return this.isType(\"isSuperTypeFor\", anotherType);\n  }\n\n  contains(type) {\n    return this.type.contains(type);\n  }\n\n  weakContains(type) {\n    return this.type.weakContains(type);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    // $FlowIssue\n    return this.getOponentType(this.type).getDifference(type, withReverseUnion);\n  }\n\n}\n\nexports.RestArgument = RestArgument;\n\nclass FunctionType extends _type.Type {\n  static get name() {\n    return \"FunctionType\";\n  }\n\n  static term(name, meta = {}, argumentsTypes, returnType, ...args) {\n    let parent = meta.parent;\n    const searchingItems = argumentsTypes.concat([returnType]);\n    const length = searchingItems.length;\n\n    for (let i = 0; i < length; i++) {\n      const item = searchingItems[i];\n\n      if (item instanceof _type.Type && (parent === undefined || parent.priority < item.parent.priority)) {\n        parent = item.parent;\n      }\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, argumentsTypes, returnType, ...args);\n  }\n\n  static getName(params, returnType, genericParams = [], isAsync = false, throws) {\n    const asyncPart = this.getAsyncPart(isAsync);\n    const genericPart = this.getGenericPart(genericParams, this.prettyMode && genericParams.length >= 4);\n    const argsPart = this.getArgumentsPart(params, this.prettyMode && (params.length >= 4 || params.some(param => String(param.name).includes(\"\\n\")) && params.length !== 1));\n    const throwsPart = this.getThrowsPart(throws);\n    const returnPart = this.getReturnPart(returnType);\n    return this.prettyMode ? this.multyLine(asyncPart, genericPart, argsPart, throwsPart, returnPart) : this.oneLine(asyncPart, genericPart, argsPart, throwsPart, returnPart);\n  }\n\n  static oneLine(asyncPart, genericPart, argsPart, throwsPart, returnPart) {\n    return `${asyncPart}${genericPart}${argsPart} => ${returnPart}${throwsPart}`;\n  }\n\n  static multyLine(asyncPart, genericPart, argsPart, throwsPart, returnPart) {\n    return `${asyncPart}${genericPart}${argsPart} => ${returnPart.replace(/\\n/g, \"\\n\\t\")}${throwsPart}`;\n  }\n\n  static getAsyncPart(isAsync) {\n    return isAsync ? \"async \" : \"\";\n  }\n\n  static getGenericPart(genericParams = [], isMultyLine = false) {\n    return genericParams.length === 0 ? \"\" : `<${genericParams.reduce((res, t) => `${res}${res ? `,${isMultyLine ? \"\\n\\t\" : \" \"}` : \"\"}${String(t.name)}${t.constraint ? `: ${String(t.constraint.name)}` : \"\"}`, \"\")}>`;\n  }\n\n  static getArgumentsPart(args = [], isMultyLine = false) {\n    return `(${isMultyLine ? \"\\n\\t\" : \"\"}${args.map(param => {\n      const isRest = param instanceof RestArgument; // $FlowIssue\n\n      param = _type.Type.getTypeRoot(isRest ? param.type : param);\n      const t = String(param.name);\n      const name = isRest ? `...${t}` : t;\n      return isMultyLine ? name.replace(/\\n/g, \"\\n\\t\") : name;\n    }).join(isMultyLine ? \",\\n\\t\" : \", \")}${isMultyLine ? \"\\n\" : \"\"})`;\n  }\n\n  static getThrowsPart(throws) {\n    return throws !== undefined ? ` throws ${String(throws.name)}` : \"\";\n  }\n\n  static getReturnPart(returnType) {\n    return String(returnType.name);\n  }\n\n  constructor(name, typeMeta = {}, argumentsTypes, returnType, isAsync = false) {\n    super(name, {\n      isSubtypeOf: FunctionType.Function,\n      ...typeMeta\n    });\n\n    _defineProperty(this, \"argumentsTypes\", void 0);\n\n    _defineProperty(this, \"returnType\", void 0);\n\n    _defineProperty(this, \"throwable\", void 0);\n\n    _defineProperty(this, \"isAsync\", void 0);\n\n    _defineProperty(this, \"priority\", 2);\n\n    this.argumentsTypes = argumentsTypes;\n    this.returnType = returnType;\n    this.isAsync = isAsync;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n    let isArgumentsChanged = false;\n\n    try {\n      const newArguments = this.argumentsTypes.map(t => {\n        const newT = t.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (newT === t) {\n          return t;\n        }\n\n        isArgumentsChanged = true;\n        return newT;\n      });\n      const newReturn = this.returnType.changeAll(sourceTypes, targetTypes, typeScope);\n\n      if (newReturn === this.returnType && !isArgumentsChanged) {\n        return this.endChanges(this);\n      }\n\n      const result = FunctionType.term(FunctionType.getName(newArguments, newReturn, undefined, this.isAsync), {}, newArguments, newReturn);\n      result.isAsync = this.isAsync;\n      return this.endChanges(result);\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = anotherType instanceof FunctionType && super.equalsTo(anotherType) && this.canContain(anotherType) && this.returnType.equalsTo(anotherType.returnType) && (this.throwable === anotherType.throwable || this.throwable !== undefined && anotherType.throwable !== undefined && this.throwable.equalsTo(anotherType.throwable)) && this.argumentsTypes.length === anotherType.argumentsTypes.length && this.argumentsTypes.every((arg, i) => // $FlowIssue\n    arg.equalsTo(anotherType.argumentsTypes[i]));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n\n    if (!(anotherType instanceof FunctionType)) {\n      anotherType = anotherType.getPropertyType(_constants.CALLABLE);\n\n      if (anotherType === null) {\n        this._alreadyProcessedWith = null;\n        return false;\n      }\n    }\n\n    const anotherTypeRequiredArguments = anotherType.argumentsTypes.filter(a => !a.isPrincipalTypeFor(_type.Type.Undefined));\n    const result = this.returnType.isPrincipalTypeFor(anotherType.returnType) && (this.throwable === undefined || anotherType.throwable !== undefined && this.throwable.isPrincipalTypeFor(anotherType.throwable)) && this.argumentsTypes.length >= anotherTypeRequiredArguments.length && anotherType.argumentsTypes.every((arg, i) => {\n      const anotherArgument = this.argumentsTypes[i] || _type.Type.Undefined;\n      return arg.onlyLiteral ? arg.equalsTo(anotherArgument) : arg.isPrincipalTypeFor(anotherArgument);\n    });\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (\"subordinateType\" in type && // $FlowIssue\n    type.subordinateType instanceof FunctionType) {\n      type = type.subordinateType;\n    }\n\n    if (type instanceof FunctionType) {\n      const {\n        argumentsTypes,\n        returnType\n      } = type; // $FlowIssue\n\n      const argumentsDiff = this.argumentsTypes.flatMap((arg, i) => argumentsTypes[i] ? arg.getDifference(argumentsTypes[i], withReverseUnion) : []);\n      const returnDiff = this.returnType.getDifference(returnType, withReverseUnion);\n      this._alreadyProcessedWith = null;\n      return argumentsDiff.concat(returnDiff);\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.argumentsTypes.some(a => a.contains(type)) || this.returnType.contains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.weakContains(type) || this.argumentsTypes.some(a => a.weakContains(type)) || this.returnType.weakContains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  generalize(types, typeScope) {\n    const localTypeScope = new _typeScope.TypeScope(typeScope);\n    const newArguments = this.argumentsTypes.map(arg => arg.generalize(types, localTypeScope));\n    const newReturnType = this.returnType.generalize(types, localTypeScope);\n    const maybeGenericTypes = newArguments.concat(newReturnType);\n    const newGenericArguments = types.filter(type => maybeGenericTypes.some(arg => arg.weakContains(type) && !arg.containsAsGeneric(type)));\n\n    if (this.argumentsTypes.every((arg, i) => arg === newArguments[i]) && this.returnType === newReturnType && newGenericArguments.length === 0) {\n      return this;\n    }\n\n    const fnName = FunctionType.getName(newArguments, newReturnType, newGenericArguments);\n    const newFnType = FunctionType.term(fnName, {}, newArguments, newReturnType);\n\n    if (newGenericArguments.length === 0) {\n      return newFnType;\n    }\n\n    return _genericType.GenericType.new(fnName, {\n      parent: typeScope\n    }, newGenericArguments, localTypeScope, newFnType);\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = this.argumentsTypes.concat([this.returnType]).map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.FunctionType = FunctionType;\n\n_defineProperty(FunctionType, \"Function\", new _typeVar.TypeVar(\"Function\"));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GenericType = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass GenericType extends _type.Type {\n  static get name() {\n    return \"GenericType\";\n  }\n\n  static new(name, meta = {}, ...args) {\n    const [, localTypeScope, subordinateType] = args;\n    const declaratedParent = meta.parent || _type.Type.GlobalTypeScope;\n    const subordinateParent = subordinateType.getNextParent(localTypeScope);\n    const parent = declaratedParent.priority > subordinateParent.priority ? declaratedParent : subordinateParent;\n    return super.new(name, { ...meta,\n      parent\n    }, ...args);\n  }\n\n  static term(name, meta = {}, ...args) {\n    const [, localTypeScope, subordinateType] = args;\n    const declaratedParent = meta.parent || _type.Type.GlobalTypeScope;\n    const subordinateParent = subordinateType.getNextParent(localTypeScope.priority);\n    const parent = declaratedParent.priority > subordinateParent.priority ? declaratedParent : subordinateParent;\n    return super.term(name, { ...meta,\n      parent\n    }, ...args);\n  }\n\n  static getNameWithoutApplying(name) {\n    const match = /^(\\$Immutable<)?([\\w_$]+)</gi.exec(String(name));\n    const matchedName = match !== null ? match[2] : name;\n    return matchedName || name;\n  }\n\n  static getName(name, parameters) {\n    if (parameters.length === 0) {\n      return String(name);\n    }\n\n    const isMultyLine = this.prettyMode && parameters.length >= 4;\n    const isSplitterPresented = isMultyLine || parameters.some(a => a instanceof _unionType.UnionType && a.variants.length >= 4);\n    return `${String(name)}<${isSplitterPresented ? \"\\n\\t\" : \"\"}${this.getParametersPart(parameters, isMultyLine)}${isSplitterPresented ? \"\\n\" : \"\"}>`;\n  }\n\n  static getParametersPart(parameters, isMultyLine = false) {\n    return parameters.reduce((res, t) => `${res}${res ? `,${isMultyLine ? \"\\n\\t\" : \" \"}` : \"\"}${String(t.name).replace(/\\n/g, \"\\n\\t\")}`, \"\");\n  }\n\n  constructor(name, meta = {}, genericArguments, typeScope, type) {\n    super(name, meta);\n\n    _defineProperty(this, \"genericArguments\", void 0);\n\n    _defineProperty(this, \"subordinateType\", void 0);\n\n    _defineProperty(this, \"localTypeScope\", void 0);\n\n    this.subordinateType = type;\n    this.localTypeScope = typeScope;\n    this.genericArguments = genericArguments;\n  }\n\n  isSuperTypeFor(anotherType) {\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const otherType = anotherType instanceof GenericType ? anotherType.subordinateType : anotherType;\n    const result = this.subordinateType.isSuperTypeFor(otherType);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  assertParameters(parameters, loc, ignoreLength = false) {\n    const requiredParams = this.genericArguments.filter(t => t.defaultType === undefined);\n\n    if (parameters.length < requiredParams.length) {\n      throw new _errors2.default(`Generic \"${String(this.name)}\" called with wrong number of arguments. Expect: ${requiredParams.length}, Actual: ${parameters.length}`, loc);\n    }\n\n    const genericArguments = this.genericArguments.map(a => a.constraint !== undefined ? new _typeVar.TypeVar(String(a.name), {\n      isSubtypeOf: a.isSubtypeOf,\n      parent: a.parent\n    }, // $FlowIssue\n    a.constraint.changeAll(this.genericArguments, parameters), a.defaultType, a.isUserDefined) : a);\n    const wrongArgumentIndex = genericArguments.findIndex((arg, i) => {\n      const parameter = parameters[i];\n      return parameter === undefined && arg.defaultType === undefined || (parameter instanceof _typeVar.TypeVar ? !arg.isPrincipalTypeFor(parameter) : arg.constraint !== undefined && !arg.constraint.isPrincipalTypeFor(parameter));\n    });\n\n    if (wrongArgumentIndex !== -1) {\n      const parameter = parameters[wrongArgumentIndex];\n      const typeVar = genericArguments[wrongArgumentIndex];\n      throw new _errors2.default(`Parameter \"${String(parameter.name)}\" is incompatible with restriction ${typeVar.constraint ? `\"${String(typeVar.constraint.name)}` : `of type \"${String(typeVar.name)}\"`}\"`, loc);\n    }\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    [sourceTypes, targetTypes] = sourceTypes.reduce(([newSourceTypes, newTargetTypes], sourceType, index) => this.genericArguments.find(a => sourceType.contains(a)) !== undefined ? [newSourceTypes, newTargetTypes] : [[...newSourceTypes, sourceType], [...newTargetTypes, targetTypes[index]]], [[], []]);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      const newSubordinateType = this.subordinateType.changeAll(sourceTypes, targetTypes, typeScope);\n\n      if (newSubordinateType === this.subordinateType) {\n        return this.endChanges(this);\n      }\n\n      const newGenericArguments = this.genericArguments.filter(arg => newSubordinateType.contains(arg));\n\n      if (newGenericArguments.length === 0) {\n        return this.endChanges(newSubordinateType);\n      }\n\n      const newName = \"argumentsTypes\" in newSubordinateType ? newSubordinateType.constructor.getName(newSubordinateType.argumentsTypes, newSubordinateType.returnType, newGenericArguments) : GenericType.getName(newSubordinateType.name, newGenericArguments);\n      const theMostCloseParent = targetTypes.reduce((parent, type) => newSubordinateType.contains(type) && (parent === undefined || parent.priority <= type.parent.priority) ? type.parent : parent, undefined);\n      return this.endChanges(GenericType.term(newName, {\n        parent: theMostCloseParent\n      }, newGenericArguments, this.localTypeScope, newSubordinateType));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  bottomizeWith(parameters, parent, loc) {\n    return new _bottomType.$BottomType({\n      parent\n    }, this, parameters, loc);\n  }\n\n  applyGeneric(appliedParameters, loc, shouldBeMemoize = true) {\n    this.assertParameters(appliedParameters, loc);\n    let isBottomPresented = false;\n    const parameters = this.genericArguments.map((t, i) => {\n      const appliedType = appliedParameters[i];\n\n      if (appliedType instanceof _bottomType.$BottomType) {\n        isBottomPresented = true;\n      }\n\n      if (appliedType === undefined) {\n        if (t.defaultType === undefined) {\n          throw new Error(\"Never!\");\n        }\n\n        return t.defaultType;\n      } // Needed for type inferencing\n\n\n      if (appliedType instanceof _typeVar.TypeVar && !appliedType.isUserDefined && t.isUserDefined && appliedType.constraint !== t.constraint) {\n        return t;\n      }\n\n      if (t.constraint instanceof _unionType.UnionType && appliedType instanceof _unionType.UnionType && appliedType.equalsTo(t.constraint)) {\n        return appliedType;\n      }\n\n      if (t.constraint instanceof _unionType.UnionType) {\n        const variant = t.constraint.variants.find(v => v.isPrincipalTypeFor(appliedType));\n\n        if (variant !== undefined) {\n          return variant;\n        }\n      }\n\n      return appliedType;\n    });\n    let appliedTypeName = this.getChangedName(this.genericArguments, parameters);\n\n    if (appliedTypeName === this.name) {\n      appliedTypeName = GenericType.getName(this.name, parameters);\n    }\n\n    const oldAppliedSelf = new _bottomType.$BottomType({\n      parent: this.subordinateType.parent\n    }, this, this.genericArguments);\n    const theMostPriorityParent = parameters.reduce((parent, type) => parent === undefined || parent.priority < type.parent.priority ? type.parent : parent, this.parent);\n\n    const appliedSelf = _typeVar.TypeVar.term(appliedTypeName, {\n      parent: theMostPriorityParent,\n      isSubtypeOf: _typeVar.TypeVar.Self\n    }, undefined, undefined, true);\n\n    if (!(appliedSelf instanceof _typeVar.TypeVar)) {\n      return appliedSelf;\n    }\n\n    if (isBottomPresented) {\n      return this.bottomizeWith(parameters, theMostPriorityParent, loc);\n    }\n\n    try {\n      const result = this.subordinateType.changeAll([...this.genericArguments, oldAppliedSelf], [...parameters, appliedSelf], theMostPriorityParent);\n      result.name = result.name === undefined ? appliedTypeName : result.name;\n      appliedSelf.root = result;\n      result.priority = this.subordinateType.priority + 1;\n      return result.save();\n    } catch (e) {\n      e.loc = loc;\n      throw e;\n    }\n  }\n\n  getPropertyType(propertyName) {\n    const result = this.subordinateType.getPropertyType(propertyName);\n\n    if (result === null && this.isSubtypeOf != null) {\n      return this.isSubtypeOf.getPropertyType(propertyName);\n    }\n\n    return result;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    if (this.subordinateType === null) {\n      return type instanceof _typeVar.TypeVar ? [{\n        root: this,\n        variable: type\n      }] : [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof GenericType) {\n      const result = this.subordinateType.getDifference(type.subordinateType, withReverseUnion) // $FlowIssue\n      .filter(a => !type.genericArguments.includes(a.variable));\n      this._alreadyProcessedWith = null;\n      return result;\n    }\n\n    if (type instanceof _typeVar.TypeVar) {\n      const result = super.getDifference(type, withReverseUnion);\n      this._alreadyProcessedWith = null;\n      return result;\n    }\n\n    const result = this.subordinateType.getDifference(type, withReverseUnion).filter(a => !this.genericArguments.includes(a.variable));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.subordinateType.contains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.subordinateType.weakContains(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  makeNominal() {\n    this.subordinateType.makeNominal();\n  }\n\n  containsAsGeneric(type) {\n    return this.genericArguments.includes(type);\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null || this.subordinateType == null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const result = this.subordinateType.getNextParent(typeScope);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  canContain(type) {\n    return this.subordinateType !== null && this.subordinateType.canContain(type);\n  }\n\n  asUserDefined() {\n    this.genericArguments.forEach(t => {\n      t._isUserDefined = true;\n      t.root = undefined;\n    });\n    return this;\n  }\n\n  asNotUserDefined() {\n    this.genericArguments.forEach(t => t._isUserDefined = false);\n    return this;\n  }\n\n}\n\nexports.GenericType = GenericType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Immutable = exports.$AppliedImmutable = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass $AppliedImmutable extends _type.Type {\n  static get name() {\n    return \"$AppliedImmutable\";\n  }\n\n  static term(name, meta = {}, readonly, ...args) {\n    name = name || this.getName(readonly);\n    let parent = meta.parent;\n\n    if (parent === undefined || readonly.parent.priority > parent.priority) {\n      parent = readonly.parent;\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, readonly, ...args);\n  }\n\n  static getName(type) {\n    return `$Immutable<${String(type.name)}>`;\n  }\n\n  constructor(name, meta = {}, type) {\n    name = name || this.getName(type);\n\n    if (type instanceof _collectionType.CollectionType && _collectionType.CollectionType.Array.root !== undefined && type.equalsTo(_collectionType.CollectionType.Array.root.applyGeneric([type.valueType]))) {\n      type = _tupleType.TupleType.ReadonlyArray.root.applyGeneric([type.valueType]);\n    }\n\n    if (type.isSimpleType()) {\n      meta = { ...meta,\n        isSubtypeOf: type\n      };\n    }\n\n    super(name, meta);\n\n    _defineProperty(this, \"readonly\", void 0);\n\n    this.readonly = type;\n  }\n\n  equalsTo(type) {\n    if (type.referenceEqualsTo(this) || type instanceof _collectionType.CollectionType && type.equalsTo(_tupleType.TupleType.ReadonlyArray.root.applyGeneric([type.valueType]))) {\n      return true;\n    }\n\n    if (type instanceof $AppliedImmutable) {\n      return type instanceof $AppliedImmutable && this.readonly.equalsTo(type.readonly);\n    }\n\n    return this.readonly.isPrincipalTypeFor(type);\n  }\n\n  isSuperTypeFor(type) {\n    if (type.onlyLiteral || type instanceof $AppliedImmutable) {\n      return type instanceof $AppliedImmutable && this.readonly.isSuperTypeFor(type.readonly);\n    }\n\n    return this.readonly.isSuperTypeFor(type);\n  }\n\n  contains(type) {\n    return this.readonly.contains(type);\n  }\n\n  weakContains(type) {\n    return this.readonly.contains(type);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    return this.readonly.getDifference(type, withReverseUnion);\n  }\n\n  changeAll(...args) {\n    const changed = this.readonly.changeAll(...args);\n\n    if (changed === this.readonly) {\n      return this;\n    }\n\n    return $AppliedImmutable.term(null, {}, changed);\n  }\n\n  getPropertyType(propertyName) {\n    const propertyType = this.readonly.getPropertyType(propertyName);\n\n    if (propertyType === null || propertyType instanceof $AppliedImmutable) {\n      return propertyType;\n    }\n\n    return $AppliedImmutable.term(null, {}, propertyType);\n  }\n\n}\n\nexports.$AppliedImmutable = $AppliedImmutable;\n\nclass $Immutable extends _genericType.GenericType {\n  static get name() {\n    return \"$Immutable\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Immutable\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo(type) {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    return $AppliedImmutable.term(null, {\n      parent: target.parent\n    }, target);\n  }\n\n}\n\nexports.$Immutable = $Immutable;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$InstanceOf = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $InstanceOf extends _genericType.GenericType {\n  static get name() {\n    return \"$InstanceOf\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$InstanceOf\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    let [target, ...genericParameters] = parameters;\n    target = this.getOponentType(target);\n\n    if (target instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, target.parent, loc);\n    }\n\n    const oldGenericArguments = this.genericArguments;\n\n    if (!(target instanceof _objectType.ObjectType && target.instanceType !== null)) {\n      throw new _errors2.default(\"Cannot apply $InstanceOf to non-class type\", loc);\n    }\n\n    let instanceType = target.instanceType;\n\n    if (instanceType instanceof _bottomType.$BottomType) {\n      this.genericArguments = this.genericArguments.concat(instanceType.genericArguments);\n      instanceType = instanceType.subordinateMagicType.applyGeneric(genericParameters, loc);\n    }\n\n    try {\n      super.assertParameters(parameters, loc);\n      return instanceType;\n    } finally {\n      this.genericArguments = oldGenericArguments;\n    }\n  }\n\n}\n\nexports.$InstanceOf = $InstanceOf;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Intersection = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nvar _immutableType = require(\"./immutable-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Intersection extends _genericType.GenericType {\n  static get name() {\n    return \"$Intersection\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Intersection\", meta, [], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(objects, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    if (objects.length < 2) {\n      throw new _errors2.default(\"$Intersection required at minimum 2 type parameters.\", loc);\n    }\n\n    let containsVariable = false;\n    let theMostPriorityParent = objects[0].parent;\n    const objectTypes = objects.map((obj, i) => {\n      const isVar = obj instanceof _typeVar.TypeVar;\n\n      if (isVar) {\n        containsVariable = true;\n        theMostPriorityParent = theMostPriorityParent.priority < obj.parent.priority ? obj.parent : theMostPriorityParent;\n\n        if (!obj.isUserDefined) {\n          obj.constraint = _objectType.ObjectType.Object;\n        }\n      }\n\n      return i !== 0 && \"readonly\" in obj ? obj.readonly : obj;\n    });\n\n    if (containsVariable) {\n      return this.bottomizeWith(objects, theMostPriorityParent, loc);\n    }\n\n    const wrongIndex = objectTypes.findIndex(a => !(a instanceof _objectType.ObjectType));\n\n    if (wrongIndex !== -1) {\n      throw new _errors2.default(`All parameters should be an object type. Only first parameter should mutable object type. ${wrongIndex} is not.`, loc);\n    }\n\n    const [firstObject, ...restObjects] = objectTypes;\n    const newProperties = [...firstObject.properties];\n\n    for (const obj of restObjects) {\n      for (const [key, variable] of obj.properties.entries()) {\n        const existed = firstObject.properties.get(key);\n\n        if (existed !== undefined && existed.type instanceof _immutableType.$AppliedImmutable) {\n          throw new _errors2.default(`Attempt to mutate immutable property \"${key}\" in \"${String(firstObject.name)}\" type`, loc);\n        }\n\n        newProperties.push([key, variable]);\n      }\n    }\n\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties), {}, newProperties);\n  }\n\n}\n\nexports.$Intersection = $Intersection;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Keys = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nvar _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Keys extends _genericType.GenericType {\n  static get name() {\n    return \"$Keys\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Keys\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [currentTarget] = parameters;\n    const realTarget = this.getOponentType(currentTarget);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, currentTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType) && !(realTarget instanceof _tupleType.TupleType) && !(realTarget instanceof _collectionType.CollectionType)) {\n      throw new _errors2.default(\"First parameter should be an object or collection type\", loc);\n    }\n\n    if (realTarget instanceof _tupleType.TupleType) {\n      return realTarget.isSubtypeOf.keyType;\n    }\n\n    if (realTarget instanceof _collectionType.CollectionType) {\n      return realTarget.keyType;\n    }\n\n    const variants = [];\n\n    for (const property of realTarget.properties.keys()) {\n      if (property !== _constants.CALLABLE && property !== _constants.CONSTRUCTABLE && property !== _constants.INDEXABLE) {\n        variants.push(_type.Type.term(`'${property}'`, {\n          isSubtypeOf: _type.Type.String\n        }));\n      }\n    }\n\n    if (!realTarget.isStrict) {\n      variants.push(_type.Type.Unknown);\n    }\n\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n}\n\nexports.$Keys = $Keys;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObjectType = undefined;\n\nvar _type = require(\"./type\");\n\nvar _common = require(\"../../utils/common\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _functionType = require(\"./function-type\");\n\nvar _variableInfo = require(\"../variable-info\");\n\nvar _constants = require(\"../constants\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass ObjectType extends _type.Type {\n  static get name() {\n    return \"ObjectType\";\n  }\n\n  static term(name, meta = {}, properties, ...args) {\n    name = name == undefined ? // $FlowIssue\n    ObjectType.getName(properties, undefined, meta.isSoft) : name;\n    let parent = meta.parent || _type.Type.GlobalTypeScope;\n    const length = properties.length;\n\n    for (let i = 0; i < length; i++) {\n      const property = properties[i][1];\n\n      if (property instanceof _variableInfo.VariableInfo) {\n        const propertyType = property.type;\n\n        if (parent === undefined || parent.priority < propertyType.parent.priority) {\n          parent = propertyType.parent;\n        }\n      }\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, properties, ...args);\n  }\n\n  static getName(params, type, isSoft = false) {\n    if (type !== undefined && String(type.name)[0] !== \"{\") {\n      return undefined;\n    }\n\n    const filteredProperties = params ? (0, _common.unique)(params, ([key]) => key) : [];\n    const properties = filteredProperties.sort(([name1], [name2]) => String(name1).localeCompare(String(name2)));\n    return this.prettyMode && filteredProperties.length > 2 ? this.multyLine(properties, isSoft) : this.oneLine(properties, isSoft);\n  }\n\n  static oneLine(properties, isSoft) {\n    return `{ ${properties.map(([name, type]) => `${name}: ${String(_type.Type.getTypeRoot(type instanceof _variableInfo.VariableInfo ? type.type : type).name)}`).join(\", \")}${properties.length > 0 && isSoft ? \", \" : \"\"}${isSoft ? \"...\" : \"\"} }`;\n  }\n\n  static multyLine(properties, isSoft) {\n    return `{\\n${properties.map(([name, type]) => `\\t${name}: ${String(_type.Type.getTypeRoot(type instanceof _variableInfo.VariableInfo ? type.type : type).name).replace(/\\n/g, \"\\n\\t\")}`).join(\",\\n\")}${properties.length > 0 ? \"\\n\" : \"\"}${isSoft ? \"\\t...\\n\" : \"\"}}`;\n  }\n\n  constructor(name, options = {}, properties) {\n    name = name == undefined ? // $FlowIssue\n    ObjectType.getName(properties, undefined, options.isSoft) : name;\n    super(name, {\n      isSubtypeOf: name === \"Object\" ? undefined : ObjectType.Object,\n      ...options\n    });\n\n    _defineProperty(this, \"isNominal\", void 0);\n\n    _defineProperty(this, \"properties\", void 0);\n\n    _defineProperty(this, \"instanceType\", null);\n\n    _defineProperty(this, \"classType\", null);\n\n    _defineProperty(this, \"isStrict\", true);\n\n    _defineProperty(this, \"priority\", 2);\n\n    _defineProperty(this, \"onlyLiteral\", true);\n\n    this.isNominal = Boolean(options.isNominal);\n    const filteredProperties = properties ? (0, _common.unique)(properties, ([key]) => key) : [];\n    this.properties = new Map(filteredProperties);\n    this.onlyLiteral = true;\n    this.isStrict = !options.isSoft;\n  }\n\n  getPropertyType(property, _ = false, isForInit = false) {\n    const propertyName = String(property);\n    let fieldOwner = this;\n    let field = undefined;\n\n    while (fieldOwner) {\n      // $FlowIssue\n      field = fieldOwner.properties.get(propertyName);\n\n      if (field || !(fieldOwner.isSubtypeOf && fieldOwner.isSubtypeOf instanceof ObjectType)) {\n        break;\n      }\n\n      fieldOwner = fieldOwner.isSubtypeOf;\n    }\n\n    if (field === undefined) {\n      return null;\n    }\n\n    if (isForInit && fieldOwner === this && this.properties.has(propertyName) && !field.hasInitializer) {\n      field.hasInitializer = true;\n    }\n\n    if (!(field.type instanceof _type.Type)) {\n      return field;\n    }\n\n    if (field.isPrivate && !this.properties.has(propertyName)) {\n      return null;\n    }\n\n    return field.type;\n  }\n\n  isAllProperties(predicate, anotherType) {\n    for (const [key, {\n      type\n    }] of this.properties) {\n      if (typeof type !== \"object\" || [_constants.CALLABLE, _constants.INDEXABLE, _constants.CONSTRUCTABLE].includes(key)) {\n        continue;\n      }\n\n      const existedAnotherProperty = anotherType.properties.get(key); // $FlowIssue\n\n      const maybeUnion = \"readonly\" in type ? type.readonly : type;\n\n      if (!existedAnotherProperty && !(maybeUnion instanceof _unionType.UnionType && maybeUnion.variants.some(variant => variant !== _type.Type.Undefined))) {\n        return false;\n      }\n\n      const anotherProperty = existedAnotherProperty || {\n        type: _type.Type.Undefined\n      };\n      /* $FlowIssue - flow doesn't type methods by name */\n\n      if (!type[predicate](anotherProperty.type)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      const newName = this.getChangedName(sourceTypes, targetTypes);\n      const name = String(this.name);\n      return name[0] === \"{\" || newName === name ? this : // $FlowIssue\n      Object.assign(new ObjectType(\"\", {}, this.properties), this, {\n        name: newName\n      });\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n    let isAnyPropertyChanged = false;\n\n    try {\n      const newProperties = [];\n      this.properties.forEach((vInfo, key) => {\n        if (!(vInfo instanceof _variableInfo.VariableInfo)) {\n          return;\n        }\n\n        const newType = vInfo.type.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (vInfo.type === newType) {\n          return newProperties.push([key, vInfo]);\n        }\n\n        isAnyPropertyChanged = true;\n        newProperties.push([key, new _variableInfo.VariableInfo(newType, vInfo.parent, vInfo.meta)]);\n      });\n      const isSubtypeOf = this.isSubtypeOf === null || this.isSubtypeOf === ObjectType.Object ? this.isSubtypeOf : this.isSubtypeOf.changeAll(sourceTypes, targetTypes, typeScope);\n\n      if (!isAnyPropertyChanged && this.isSubtypeOf === isSubtypeOf) {\n        return this.endChanges(this);\n      }\n\n      const isSoft = !this.isStrict;\n      const result = ObjectType.term(ObjectType.getName(newProperties, this, isSoft) || this.getChangedName(sourceTypes, targetTypes), {\n        isSubtypeOf,\n        isSoft\n      }, newProperties);\n      return this.endChanges(result);\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType, true, false);\n\n    if (this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (!(anotherType instanceof ObjectType) || this.isStrict && anotherType.properties.size !== this.properties.size || this.isNominal && !super.equalsTo(anotherType) || !this.canContain(anotherType)) {\n      return false;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = this.isAllProperties(\"equalsTo\", anotherType);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  isInHierarchyOf(anotherType) {\n    do {\n      if (this === anotherType) {\n        return true;\n      } // $FlowIssue\n\n\n      anotherType = anotherType.isSubtypeOf;\n    } while (anotherType && anotherType.isSubtypeOf);\n\n    return false;\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (anotherType instanceof ObjectType && this === ObjectType.Object.root || this.isInHierarchyOf(anotherType)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const requiredProperties = [...this.properties.values()].filter(({\n      type\n    }) => {\n      type = // $FlowIssue\n      typeof type === \"object\" && \"readonly\" in type ? type.readonly : type;\n      return !(type instanceof _unionType.UnionType) || !type.variants.some(t => t.equalsTo(_type.Type.Undefined));\n    });\n    const result = anotherType instanceof ObjectType && !this.isNominal ? anotherType.properties.size >= requiredProperties.length && (!this.isStrict || this.hasTheSameKeysAs(anotherType)) && this.isAllProperties(\"isPrincipalTypeFor\", anotherType) : anotherType.isSubtypeOf != undefined && this.isPrincipalTypeFor(anotherType.isSubtypeOf);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  hasTheSameKeysAs(anotherType) {\n    for (const [key] of anotherType.properties) {\n      if (!this.properties.has(key)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof ObjectType) {\n      let differences = [];\n      const {\n        properties\n      } = type;\n      this.properties.forEach(({\n        type\n      }, key) => {\n        const other = properties.get(key);\n\n        if (other === undefined) {\n          return;\n        }\n\n        differences = differences.concat(type.getDifference(other.type, withReverseUnion));\n      });\n      this._alreadyProcessedWith = null;\n      return differences;\n    }\n\n    if (type instanceof _functionType.FunctionType) {\n      const callable = this.properties.get(_constants.CALLABLE);\n\n      if (callable !== undefined) {\n        const result = callable.type.getDifference(type, withReverseUnion);\n        this._alreadyProcessedWith = null;\n        return result;\n      }\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    if (super.contains(type)) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = type;\n\n    for (const [_, property] of this.properties) {\n      if (property instanceof _variableInfo.VariableInfo && property.type.contains(type)) {\n        this._alreadyProcessedWith = null;\n        return true;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return false;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.equalsTo(type);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [...this.properties].filter(([_, v]) => v instanceof _variableInfo.VariableInfo).map(([_, {\n      type\n    }]) => type.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.ObjectType = ObjectType;\n\n_defineProperty(ObjectType, \"Object\", new _typeVar.TypeVar(\"Object\"));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Omit = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Omit extends _genericType.GenericType {\n  static get name() {\n    return \"$Omit\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Omit\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    }), _typeVar.TypeVar.term(\"properties\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target, properties] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"First parameter should be an object type\", loc);\n    }\n\n    const picks = properties instanceof _unionType.UnionType ? properties.variants : [properties];\n    const pickedProperties = picks.map(variant => {\n      if (variant.isSubtypeOf && variant.isSubtypeOf.equalsTo(_type.Type.String)) {\n        return variant.name;\n      }\n\n      throw new _errors2.default(\"The second parameter should be an string literals type\");\n    });\n    const oldProperties = [...realTarget.properties.entries()];\n    const newProperties = oldProperties.filter(([name]) => !pickedProperties.includes(`'${name}'`));\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties), {}, newProperties);\n  }\n\n}\n\nexports.$Omit = $Omit;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Partial = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _variableInfo = require(\"../variable-info\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Partial extends _genericType.GenericType {\n  static get name() {\n    return \"$Partial\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Partial\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"First parameter should be an object type\", loc);\n    }\n\n    const oldProperties = [...realTarget.properties.entries()];\n    const newProperties = oldProperties.map(([name, property]) => {\n      const variants = [_type.Type.Undefined, ...(property.type instanceof _unionType.UnionType ? property.type.variants : [property.type])];\n\n      const newType = _unionType.UnionType.term(null, {}, variants);\n\n      return [name, new _variableInfo.VariableInfo(newType, property.parent, property.meta)];\n    });\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties, undefined, !realTarget.isStrict), {\n      isSoft: !realTarget.isStrict\n    }, newProperties);\n  }\n\n}\n\nexports.$Partial = $Partial;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Pick = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Pick extends _genericType.GenericType {\n  static get name() {\n    return \"$Pick\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Pick\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    }), _typeVar.TypeVar.term(\"properties\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target, properties] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"First parameter should be an object type\", loc);\n    }\n\n    const picks = properties instanceof _unionType.UnionType ? properties.variants : [properties];\n    const pickedProperties = picks.map(variant => {\n      if (variant.isSubtypeOf && variant.isSubtypeOf.equalsTo(_type.Type.String)) {\n        return variant.name;\n      }\n\n      throw new _errors2.default(\"The second parameter should be an string literals type\");\n    });\n    const oldProperties = [...realTarget.properties.entries()];\n    const newProperties = oldProperties.filter(([name]) => pickedProperties.includes(`'${name}'`));\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties), {}, newProperties);\n  }\n\n}\n\nexports.$Pick = $Pick;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$PropertyType = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _keysType = require(\"./keys-type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _variableInfo = require(\"../variable-info\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $PropertyType extends _genericType.GenericType {\n  static get name() {\n    return \"$PropertyType\";\n  }\n\n  constructor(_, meta = {}, isForInit = false) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$PropertyType\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    }), _typeVar.TypeVar.term(\"property\", {\n      parent\n    })], parent, null);\n    this.isForInit = isForInit;\n  }\n\n  findRealTarget(target, loc) {\n    if (target instanceof _unionType.UnionType) {\n      return target;\n    }\n\n    let obj = target;\n\n    while (obj !== null && !(obj instanceof _objectType.ObjectType)) {\n      obj = obj.isSubtypeOf;\n    }\n\n    return obj;\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false, initializing = false) {\n    super.assertParameters(parameters, loc);\n    const [currentTarget, property] = parameters;\n    const realTarget = this.getOponentType(currentTarget);\n    const realProperty = this.getOponentType(property);\n    const propertyName = realProperty.isSubtypeOf && realProperty.isSubtypeOf.name === \"string\" ? realProperty.name.slice(1, -1) : realProperty.name;\n    const isTargetVariable = realTarget instanceof _typeVar.TypeVar;\n    const isPropertyVariable = realProperty instanceof _typeVar.TypeVar;\n\n    if (isTargetVariable && !realTarget.isUserDefined) {\n      if (realTarget.constraint === undefined) {\n        if (isPropertyVariable) {\n          realTarget.constraint = _objectType.ObjectType.Object.root;\n        } else {\n          const props = [[propertyName, new _variableInfo.VariableInfo(_typeVar.TypeVar.term(`${realTarget.name}0`, {\n            parent: realTarget.parent\n          }))]];\n          realTarget.constraint = _objectType.ObjectType.term(null, {\n            isSoft: true\n          }, props);\n        }\n      } else if (realTarget.constraint instanceof _objectType.ObjectType && !isPropertyVariable && !realTarget.constraint.properties.has(propertyName)) {\n        const props = [...realTarget.constraint.properties, [propertyName, new _variableInfo.VariableInfo(_typeVar.TypeVar.term(`${realTarget.name}${realTarget.constraint.properties.size}`, {\n          parent: realTarget.parent\n        }))]];\n        realTarget.constraint = _objectType.ObjectType.term(null, {\n          isSoft: true\n        }, props);\n      }\n    }\n\n    if (isPropertyVariable && !realProperty.isUserDefined && realProperty.constraint === undefined) {\n      let constraint = undefined;\n\n      if (realTarget instanceof _collectionType.CollectionType) {\n        constraint = realTarget.keyType;\n      } else if (realTarget instanceof _tupleType.TupleType) {\n        constraint = Array.from({\n          length: realTarget.items.length\n        }).map((_, i) => _type.Type.term(i + 1, {\n          isSubtypeOf: _type.Type.Number\n        }));\n      } else if (realTarget instanceof _objectType.ObjectType) {\n        constraint = _unionType.UnionType.term(null, {}, [...realTarget.properties].map(([key]) => _type.Type.term(`'${key}'`, {\n          isSubtypeOf: _type.Type.String\n        })));\n      } else if (isTargetVariable) {\n        constraint = new _bottomType.$BottomType({}, new _keysType.$Keys(), [realTarget]);\n      }\n\n      realProperty.constraint = constraint;\n    }\n\n    if (isTargetVariable && !realTarget.isUserDefined && !isPropertyVariable) {\n      return realTarget.constraint.properties.get(propertyName).type;\n    }\n\n    if (isPropertyVariable) {\n      return this.bottomizeWith([realTarget, realProperty], realTarget.parent, loc);\n    }\n\n    if (realProperty instanceof _unionType.UnionType) {\n      try {\n        const variants = realProperty.variants.map(p => this.applyGeneric([realTarget, p], loc, shouldBeMemoize, isCalledAsBottom));\n        return _unionType.UnionType.term(null, {}, variants);\n      } catch {\n        throw new _errors2.default(`Property \"${propertyName}\" does not exist in \"${currentTarget.name}\"`, loc);\n      }\n    }\n\n    if (realTarget instanceof _unionType.UnionType) {\n      try {\n        const variants = realTarget.variants.map(v => this.applyGeneric([v, realProperty], loc, shouldBeMemoize, isCalledAsBottom));\n        return _unionType.UnionType.term(null, {}, variants);\n      } catch {\n        throw new _errors2.default(`Property \"${propertyName}\" does not exist in \"${currentTarget.name}\"`, loc);\n      }\n    }\n\n    const fieldType = realTarget.getPropertyType(propertyName, initializing, this.isForInit);\n\n    if (!realProperty.isSubtypeOf && !isCalledAsBottom) {\n      throw new _errors2.default(\"Second parameter should be an literal\", loc);\n    }\n\n    if (fieldType !== null) {\n      return fieldType;\n    }\n\n    throw new _errors2.default(`Property \"${propertyName}\" does not exist in \"${currentTarget.name}\"`, loc);\n  }\n\n}\n\nexports.$PropertyType = $PropertyType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Refinemented = undefined;\n\nvar _type = require(\"./type\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass $Refinemented extends _type.Type {\n  static get name() {\n    return \"$Refinemented\";\n  }\n\n  constructor(refinemented, from) {\n    super(refinemented.name, {\n      parent: refinemented.parent\n    });\n\n    _defineProperty(this, \"refinemented\", void 0);\n\n    _defineProperty(this, \"from\", void 0);\n\n    this.refinemented = refinemented;\n    this.from = from;\n  }\n\n  equalsTo(type) {\n    if (type.referenceEqualsTo(this)) {\n      return true;\n    }\n\n    return type instanceof $Refinemented ? this.refinemented.equalsTo(type.refinemented) : this.refinemented.isPrincipalTypeFor(type);\n  }\n\n  isSuperTypeFor(type) {\n    if (type instanceof $Refinemented) {\n      return this.refinemented.isSuperTypeFor(type.refinemented);\n    }\n\n    return this.refinemented.isSuperTypeFor(type);\n  }\n\n  contains(type) {\n    return this.refinemented.contains(type);\n  }\n\n  weakContains(type) {\n    return this.refinemented.contains(type);\n  }\n\n  changeAll(...args) {\n    return this.refinemented.changeAll(...args);\n  }\n\n  getPropertyType(propertyName) {\n    return this.refinemented.getPropertyType(propertyName);\n  }\n\n}\n\nexports.$Refinemented = $Refinemented;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$ReturnType = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _functionType = require(\"./function-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $ReturnType extends _genericType.GenericType {\n  static get name() {\n    return \"$ReturnType\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$ReturnType\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    let [target, ...genericParameters] = parameters;\n    const oldGenericArguments = this.genericArguments;\n\n    if (target instanceof _genericType.GenericType) {\n      this.genericArguments = this.genericArguments.concat(target.genericArguments);\n      target = target.applyGeneric(genericParameters, loc);\n    }\n\n    try {\n      super.assertParameters(parameters, loc);\n      const realTarget = target.constraint || target;\n\n      if (!(realTarget instanceof _functionType.FunctionType)) {\n        throw new _errors2.default(\"First parameter should be an function type\", loc);\n      }\n\n      return realTarget.returnType;\n    } finally {\n      this.genericArguments = oldGenericArguments;\n    }\n  }\n\n}\n\nexports.$ReturnType = $ReturnType;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Soft = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Soft extends _genericType.GenericType {\n  static get name() {\n    return \"$Soft\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Soft\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"Parameter should be an object type\", loc);\n    }\n\n    const properties = [...realTarget.properties.entries()];\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(properties, undefined, true), {\n      isSoft: true\n    }, properties);\n  }\n\n}\n\nexports.$Soft = $Soft;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Strict = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Strict extends _genericType.GenericType {\n  static get name() {\n    return \"$Strict\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Strict\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    const realTarget = this.getOponentType(target);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType)) {\n      throw new _errors2.default(\"First parameter should be an object type\", loc);\n    }\n\n    const properties = [...realTarget.properties.entries()];\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(properties, undefined, false), {\n      isSoft: false\n    }, properties);\n  }\n\n}\n\nexports.$Strict = $Strict;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Throws = exports.$ThrowsResult = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _genericType = require(\"./generic-type\");\n\nclass $ThrowsResult extends _type.Type {\n  static get name() {\n    return \"$ThrowsResult\";\n  }\n\n  static term(name, meta = {}, errorType, ...args) {\n    name = name === null ? $ThrowsResult.getName(errorType) : name;\n    const scope = meta.parent || _type.Type.GlobalTypeScope;\n    const existed = scope.findTypeWithName(name);\n\n    if (this.shouldBeReplaced(existed, name, meta, errorType, ...args)) {\n      return this.new(name, meta, errorType, ...args);\n    }\n\n    return existed;\n  }\n\n  static getName(errorType) {\n    return `$Throws<${String(errorType.name)}>`;\n  }\n\n  constructor(name, meta = {}, errorType) {\n    name = name === null ? $ThrowsResult.getName(errorType) : name;\n    super(name, meta);\n    this.errorType = errorType;\n  }\n\n}\n\nexports.$ThrowsResult = $ThrowsResult;\n\nclass $Throws extends _genericType.GenericType {\n  static get name() {\n    return \"$Throws\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Throws\", meta, [_typeVar.TypeVar.term(\"errors\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc, shouldBeMemoize = true, isCalledAsBottom = false) {\n    super.assertParameters(parameters, loc);\n    const [error] = parameters;\n    return $ThrowsResult.term(null, {\n      parent: error.parent\n    }, error);\n  }\n\n}\n\nexports.$Throws = $Throws;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TupleType = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _bottomType = require(\"./bottom-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass TupleType extends _type.Type {\n  static get name() {\n    return \"TupleType\";\n  }\n\n  static term(name, meta = {}, items, ...args) {\n    let parent = meta.parent;\n    const length = items.length;\n\n    for (let i = 0; i < length; i++) {\n      const item = items[i];\n\n      if (item instanceof _type.Type && (parent === undefined || parent.priority < item.parent.priority)) {\n        // $FlowIssue\n        parent = item.parent;\n      }\n    }\n\n    name = name === null ? TupleType.getName(items) : name;\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, items, ...args);\n  }\n\n  static getName(params) {\n    if (params instanceof _type.Type) {\n      return String(params.name);\n    }\n\n    const isMultyLine = this.prettyMode && params.length >= 4;\n    return `[${isMultyLine ? \"\\n\\t\" : \"\"}${params.reduce((res, t) => `${res}${res ? `,${isMultyLine ? \"\\n\\t\" : \" \"}` : \"\"}${String(_type.Type.getTypeRoot(t).name).replace(/\\n/g, \"\\n\\t\")}`, \"\")}${isMultyLine ? \"\\n\" : \"\"}]`;\n  }\n\n  constructor(name, meta = {}, items) {\n    const arrayValue = [items.length !== 0 ? _unionType.UnionType.term(null, {}, items) : _type.Type.Unknown];\n    const isSubtypeOf = TupleType.ReadonlyArray.root === undefined ? new _bottomType.$BottomType({}, TupleType.ReadonlyArray, arrayValue) : // $FlowIssue ReadonlyArray is always GenericType\n    TupleType.ReadonlyArray.root.applyGeneric(arrayValue);\n    super(name, { ...meta,\n      isSubtypeOf\n    });\n\n    _defineProperty(this, \"items\", void 0);\n\n    _defineProperty(this, \"onlyLiteral\", true);\n\n    this.items = items;\n    this.priority = items.length * 10;\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      let isItemsChanged = false;\n      const newItems = this.items.map(t => {\n        const newT = t.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (newT === t) {\n          return t;\n        }\n\n        isItemsChanged = true;\n        return newT;\n      });\n      const isSubtypeOf = this.isSubtypeOf && this.isSubtypeOf.changeAll(sourceTypes, targetTypes, typeScope);\n      return this.endChanges(!isItemsChanged && isSubtypeOf === this.isSubtypeOf ? this : TupleType.term(null, {\n        isSubtypeOf\n      }, newItems));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const result = anotherType instanceof TupleType && anotherType.items.length === this.items.length && //$FlowIssue - instanceof type refinement\n    this.items.every((t, i) => t.isPrincipalTypeFor(anotherType.items[i]));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const anotherVariants = anotherType instanceof TupleType ? anotherType.items : [];\n    const result = anotherType instanceof TupleType && super.equalsTo(anotherType) && this.canContain(anotherType) && this.items.length === anotherVariants.length && this.items.every((type, index) => type.equalsTo(anotherVariants[index]));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getPropertyType(propertyIndex) {\n    if (typeof propertyIndex === \"number\") {\n      return propertyIndex < this.items.length ? this.items[propertyIndex] : null;\n    }\n\n    if (propertyIndex === \"length\") {\n      return _type.Type.term(this.items.length, {\n        isSubtypeOf: _type.Type.Number\n      });\n    }\n\n    if (this.isSubtypeOf instanceof _bottomType.$BottomType) {\n      const unpacked = this.isSubtypeOf.unpack();\n\n      if (TupleType.ReadonlyArray.root !== undefined) {\n        this.isSubtypeOf = unpacked;\n      }\n\n      return unpacked.getPropertyType(propertyIndex);\n    }\n\n    return super.getPropertyType(propertyIndex);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof TupleType) {\n      let differences = [];\n      const {\n        items\n      } = type;\n      this.items.forEach((type, index) => {\n        const other = items[index];\n\n        if (other === undefined) {\n          return;\n        }\n\n        differences = differences.concat(type.getDifference(other, withReverseUnion));\n      });\n      this._alreadyProcessedWith = null;\n      return differences;\n    }\n\n    if (type instanceof _collectionType.CollectionType) {\n      // $FlowIssue\n      const result = this.isSubtypeOf.getDifference(type, withReverseUnion);\n      this._alreadyProcessedWith = null;\n      return result;\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.items.some(i => i.contains(type));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.items.some(i => i.weakContains(type));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [...this.items].map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.TupleType = TupleType;\n\n_defineProperty(TupleType, \"ReadonlyArray\", new _typeVar.TypeVar(\"ReadonlyArray\"));","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$TypeOf = undefined;\n\nvar _typeVar = require(\"./type-var\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _genericType = require(\"./generic-type\");\n\nclass $TypeOf extends _genericType.GenericType {\n  static get name() {\n    return \"$TypeOf\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$TypeOf\", {}, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null, meta);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    super.assertParameters(parameters, loc);\n    const [target] = parameters;\n    return target.type;\n  }\n\n}\n\nexports.$TypeOf = $TypeOf;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypeVar = undefined;\n\nvar _type = require(\"./type\");\n\nvar _constants = require(\"../constants\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass TypeVar extends _type.Type {\n  static get name() {\n    return \"TypeVar\";\n  }\n\n  static isSelf(type) {\n    return type.isSubtypeOf === this.Self;\n  }\n\n  static createSelf(name, parent) {\n    // $FlowIssue\n    return new this(name, {\n      parent,\n      isSubtypeOf: TypeVar.Self\n    });\n  }\n\n  get isUserDefined() {\n    return this._isUserDefined;\n  }\n\n  set isUserDefined(isUserDefined) {\n    this._isUserDefined = this._isUserDefined || isUserDefined;\n  }\n\n  constructor(name, meta = {}, constraint, defaultType, isUserDefined = false) {\n    super(name, meta);\n\n    _defineProperty(this, \"constraint\", void 0);\n\n    _defineProperty(this, \"root\", void 0);\n\n    _defineProperty(this, \"defaultType\", void 0);\n\n    _defineProperty(this, \"_isUserDefined\", void 0);\n\n    _defineProperty(this, \"priority\", 0);\n\n    this.name = name;\n    this.constraint = constraint;\n    this.defaultType = defaultType;\n    this._isUserDefined = isUserDefined;\n  }\n\n  equalsTo(anotherType, strict = false, withoutRoot = false) {\n    const isDifferenceInDefinition = this.isUserDefined && anotherType instanceof TypeVar && !anotherType.isUserDefined && !strict;\n\n    if (isDifferenceInDefinition || this.referenceEqualsTo(anotherType)) {\n      return true;\n    }\n\n    if (this.root != undefined) {\n      // $FlowIssue\n      return this.root.equalsTo(anotherType, strict, withoutRoot);\n    }\n\n    if (anotherType instanceof TypeVar && anotherType.constraint !== undefined && this.constraint !== undefined) {\n      return super.equalsTo(anotherType) && this.constraint.equalsTo(anotherType.constraint) || this.constraint.equalsTo(anotherType);\n    }\n\n    return anotherType instanceof TypeVar && this.constraint === anotherType.constraint && super.equalsTo(anotherType);\n  }\n\n  isPrincipalTypeFor(type) {\n    if (type === this) {\n      return true;\n    }\n\n    if (this.root !== undefined) {\n      return this.root.isPrincipalTypeFor(type);\n    }\n\n    if (TypeVar.strictEquality && (!(type instanceof TypeVar) || this.parent.findTypeWithName(type.name) === type)) {\n      return false;\n    }\n\n    return super.isPrincipalTypeFor(type);\n  }\n\n  isSuperTypeFor(type) {\n    if (this.root !== undefined) {\n      return this.root.isSuperTypeFor(type);\n    }\n\n    if (this.constraint === undefined) {\n      return true;\n    }\n\n    if (type instanceof TypeVar) {\n      return type.constraint !== undefined ? this.constraint.isPrincipalTypeFor(type.constraint) : !type._isUserDefined;\n    }\n\n    return this.constraint.isPrincipalTypeFor(type);\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    const indexOfNewRootType = sourceTypes.findIndex( // $FlowIssue\n    a => a.equalsTo(this, true, true));\n\n    if (indexOfNewRootType !== -1) {\n      return targetTypes[indexOfNewRootType];\n    }\n\n    if (this.root !== undefined) {\n      return this.root.changeAll(sourceTypes, targetTypes, typeScope);\n    }\n\n    let defaultType = this.defaultType;\n    let constraint = this.constraint;\n\n    if (defaultType !== undefined) {\n      defaultType = defaultType.changeAll(sourceTypes, targetTypes, typeScope);\n    }\n\n    if (constraint !== undefined) {\n      constraint = constraint.changeAll(sourceTypes, targetTypes, typeScope);\n    }\n\n    if (this.constraint !== constraint || this.defaultType !== defaultType) {\n      return new TypeVar(String(this.name), {\n        parent: this.parent\n      }, constraint, defaultType, this.isUserDefined);\n    }\n\n    return this;\n  }\n\n  applyGeneric() {\n    return this;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n    let result = [];\n\n    if (this.root !== undefined) {\n      result = this.root.getDifference(type, withReverseUnion);\n    } else if (type instanceof TypeVar && this !== type) {\n      result = [{\n        root: this,\n        variable: type\n      }];\n    } else if (\"variants\" in type) {\n      result = super.getDifference(type, withReverseUnion);\n    }\n\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  contains(type) {\n    return this.constraint != undefined && this.constraint.contains(type) || this.equalsTo(type, true, true);\n  }\n\n  getPropertyType(propertyName) {\n    const target = this.root || this.constraint;\n\n    if (target !== undefined) {\n      return target.getPropertyType(propertyName);\n    }\n\n    return super.getPropertyType(propertyName);\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n\n    if (this.root !== undefined || this.constraint !== undefined) {\n      const target = this.root || this.constraint; // $FlowIssue\n\n      const result = target.getNextParent(typeScope);\n      this._alreadyProcessedWith = null;\n      return result;\n    }\n\n    this._alreadyProcessedWith = null;\n\n    if (this.parent.priority <= typeScope.priority && this.parent !== typeScope) {\n      return this.parent;\n    }\n\n    return _type.Type.GlobalTypeScope;\n  }\n\n  applyGeneric(...args) {\n    return this.root !== undefined && typeof \"applyGeneric\" in this.root ? // $FlowIssue GenericType by duck typing, can't import GenericType because of cycled dependecy\n    this.root.applyGeneric(...args) : this;\n  }\n\n}\n\nexports.TypeVar = TypeVar;\n\n_defineProperty(TypeVar, \"Self\", new TypeVar(_constants.THIS_TYPE));\n\n_defineProperty(TypeVar, \"strictEquality\", false);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Type = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass Type {\n  static get name() {\n    return \"Type\";\n  }\n\n  static find(name, meta = {}, ...args) {\n    const scope = meta.parent || Type.GlobalTypeScope; // $FlowIssue\n\n    const existed = scope.findTypeWithName(name, ...args);\n\n    if (existed === undefined) {\n      throw new _errors2.default(`Type \"${String(name)}\" does not exist`, meta.loc);\n    }\n\n    return existed;\n  }\n\n  static new(name, meta = {}, ...args) {\n    let scope = meta.parent || Type.GlobalTypeScope;\n    const suptypeParent = meta.isSubtypeOf && meta.isSubtypeOf.parent;\n\n    if (suptypeParent && // $FlowIssue\n    meta.isSubtypeOf.name !== _constants.THIS_TYPE && suptypeParent.priority > scope.priority) {\n      scope = suptypeParent;\n    }\n\n    const newType = new this(name, { ...meta,\n      parent: scope\n    }, ...args);\n    scope.body.set(name, newType);\n    return newType;\n  }\n\n  static term(name, meta = {}, ...args) {\n    const scope = meta.parent || Type.GlobalTypeScope;\n    const existed = scope.findTypeWithName(name);\n\n    if (this.shouldBeReplaced(existed, name, meta, ...args)) {\n      return this.new(name, meta, ...args);\n    }\n\n    return existed;\n  }\n\n  static shouldBeReplaced(type, name, meta, ...args) {\n    return type === undefined || !(type instanceof this || this.name === \"TypeVar\");\n  }\n\n  static getTypeRoot(type, stepBeforeNonVariableRoot = false) {\n    let potentialRoot = type;\n\n    while (\"root\" in potentialRoot && // $FlowIssue\n    potentialRoot.root != undefined && ( // $FlowIssue\n    !stepBeforeNonVariableRoot || \"root\" in potentialRoot.root)) {\n      // $FlowIssue\n      potentialRoot = potentialRoot.root;\n    }\n\n    return potentialRoot;\n  }\n\n  constructor(name, meta = {}) {\n    _defineProperty(this, \"name\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"shouldBeUsedAsGeneric\", void 0);\n\n    _defineProperty(this, \"isSubtypeOf\", void 0);\n\n    _defineProperty(this, \"_alreadyProcessedWith\", null);\n\n    _defineProperty(this, \"_processingType\", null);\n\n    _defineProperty(this, \"_changeStack\", null);\n\n    _defineProperty(this, \"onlyLiteral\", false);\n\n    _defineProperty(this, \"priority\", 1);\n\n    const {\n      parent = Type.GlobalTypeScope,\n      isSubtypeOf = null,\n      shouldBeUsedAsGeneric = false\n    } = meta;\n    this.name = name;\n    this.isSubtypeOf = isSubtypeOf;\n    this.parent = parent;\n    this.shouldBeUsedAsGeneric = shouldBeUsedAsGeneric;\n  }\n\n  getChangedName(sourceTypes, targetTypes) {\n    let pattern = \"\";\n    const map = sourceTypes.reduce((map, type, index) => {\n      const name = String(type.name).replace(/[()]/g, bracket => `\\\\${bracket}`);\n      map.set(name, String(targetTypes[index].name));\n      pattern += (pattern && \"|\") + name.replace(/\\|/g, \"\\\\|\");\n      return map;\n    }, new Map());\n    const template = new RegExp(`\\\\b(${pattern})\\\\b`, \"gm\");\n    return String(this.name).replace(template, typeName => map.get(typeName) || \"\");\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    const indexOfNewType = sourceTypes.indexOf(this);\n    return indexOfNewType === -1 ? this : targetTypes[indexOfNewType];\n  }\n\n  save() {\n    const existed = this.parent.body.get(this.name);\n\n    if (existed === undefined || !(existed instanceof this.constructor)) {\n      this.parent.body.set(this.name, this);\n    }\n\n    return this;\n  }\n\n  referenceEqualsTo(anotherType) {\n    return this === anotherType;\n  }\n\n  equalsTo(anotherType) {\n    return this.referenceEqualsTo(anotherType) || this.name === anotherType.name;\n  }\n\n  isSuperTypeFor(type) {\n    if (this._alreadyProcessedWith === type) {\n      return true;\n    }\n\n    if (type.isSubtypeOf === null || !this.canContain(type.isSubtypeOf)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = this.isPrincipalTypeFor(type.isSubtypeOf);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getPropertyType(propertyName) {\n    if (this.isSubtypeOf != null) {\n      return this.isSubtypeOf.getPropertyType(propertyName);\n    }\n\n    return null;\n  }\n\n  isPrincipalTypeFor(type) {\n    if (\"variants\" in type) {\n      // $FlowIssue\n      return type.variants.every(variant => this.isPrincipalTypeFor(variant));\n    }\n\n    if (this._processingType === type) {\n      return false;\n    }\n\n    this._processingType = type;\n    const isPrincipal = this.equalsTo(Type.Unknown) || this.equalsTo(type) || this.isSuperTypeFor(type);\n    this._processingType = null;\n\n    if (isPrincipal || type.constructor !== Type) {\n      return isPrincipal;\n    }\n\n    const typeWrapper = type.getWrapperType();\n    return typeWrapper !== undefined && typeWrapper !== this && this.isSuperTypeFor(typeWrapper);\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    if (\"readonly\" in type) {\n      // $FlowIssue\n      type = type.readonly;\n    }\n\n    if (\"variants\" in type) {\n      // $FlowIssue\n      const variants = [...type.variants].sort((t1, t2) => t2.priority - t1.priority);\n\n      for (const variant of variants) {\n        const diff = this.getDifference(variant, withReverseUnion);\n\n        if (diff.length !== 0 || variant.isPrincipalTypeFor(this)) {\n          return diff;\n        }\n      }\n    }\n\n    if (\"constraint\" in type && type.isSubtypeOf === null) {\n      const constraint = // $FlowIssue\n      type.constraint instanceof Type ? type.constraint : undefined;\n\n      if (constraint !== undefined && !(\"subordinateMagicType\" in constraint) && constraint.isPrincipalTypeFor(this)) {\n        return [{\n          root: this,\n          variable: type\n        }, ...this.getDifference(constraint)];\n      }\n\n      return [{\n        root: this,\n        variable: type\n      }];\n    }\n\n    if (\"subordinateMagicType\" in type) {\n      // $FlowIssue\n      const unpacked = type.unpack();\n\n      if (!(\"subordinateMagicType\" in unpacked)) {\n        return this.getDifference(unpacked, withReverseUnion);\n      }\n    }\n\n    const wrapper = this.isSubtypeOf || this.getWrapperType();\n\n    if (type.parent !== undefined && type.parent.priority > 1 && wrapper !== undefined) {\n      return wrapper.getDifference(type).map(d => d.root === wrapper && d.variable === type ? {\n        variable: type,\n        root: this\n      } : d);\n    }\n\n    return [];\n  }\n\n  contains(type) {\n    return this === type;\n  }\n\n  weakContains(type) {\n    return this.contains(type);\n  }\n\n  getOponentType(type, withUnpack = true, withReadonly = true) {\n    if (\"root\" in type) {\n      type = Type.getTypeRoot(type);\n    }\n\n    if (withReadonly && \"readonly\" in type) {\n      // $FlowIssue\n      type = type.readonly;\n    }\n\n    if (\"unpack\" in type) {\n      // $FlowIssue\n      type = withUnpack ? type.unpack() : type.subordinateMagicType;\n    }\n\n    if (\"root\" in type) {\n      type = Type.getTypeRoot(type);\n    } // $FlowIssue\n\n\n    if (\"subordinateType\" in type && type.subordinateType !== null) {\n      // $FlowIssue\n      type = type.subordinateType;\n    }\n\n    if (\"root\" in type) {\n      type = Type.getTypeRoot(type);\n    }\n\n    if (withReadonly && \"readonly\" in type) {\n      // $FlowIssue\n      type = type.readonly;\n    }\n\n    return type;\n  }\n\n  makeNominal() {}\n\n  setInitialized(propertyName) {}\n\n  generalize(types, typeScope) {\n    return this;\n  }\n\n  containsAsGeneric(type) {\n    return false;\n  }\n\n  promisify() {\n    const Promise = Type.find(\"Promise\");\n    return Promise.applyGeneric([this]);\n  }\n\n  isPromise() {\n    const name = String(this.name);\n    return /^Promise/.test(name);\n  }\n\n  canContain(type) {\n    return this.parent.priority >= type.parent.priority;\n  }\n\n  endChanges(result) {\n    if (this._changeStack === null) {\n      return result;\n    }\n\n    const last = this._changeStack.pop();\n\n    if (last === undefined) {\n      this._changeStack = null;\n      return result;\n    } // $FlowIssue\n\n\n    last.root = result;\n    last.name = result.name;\n\n    if (this._changeStack !== null && this._changeStack.length === 0) {\n      this._changeStack = null;\n    }\n\n    return result;\n  }\n\n  getNextParent(typeScope) {\n    return Type.GlobalTypeScope;\n  }\n\n  findPrincipal(type) {\n    let principal = {\n      isSubtypeOf: this\n    };\n    let isPrincipalFound = false;\n\n    while ((principal.isSubtypeOf != undefined || principal === Type.True || principal === Type.False) && !isPrincipalFound) {\n      // $FlowIssue We mutate static field Boolean in src/type-graph/types/union-type.js so Boolean should exists in Type\n      principal = principal.isSubtypeOf || Type.Boolean;\n      isPrincipalFound = principal.isPrincipalTypeFor(type);\n    }\n\n    return isPrincipalFound ? principal : undefined;\n  }\n\n  asUserDefined() {\n    return this;\n  }\n\n  asNotUserDefined() {\n    return this;\n  }\n\n  getWrapperType() {\n    if (Type.GlobalTypeScope === undefined) {\n      return;\n    }\n\n    if (this === Type.String || this.isSubtypeOf === Type.String) {\n      return Type.GlobalTypeScope.body.get(\"String\");\n    }\n\n    if (this === Type.Number || this.isSubtypeOf === Type.Number) {\n      return Type.GlobalTypeScope.body.get(\"Number\");\n    } // $FlowIssue We mutate static field Boolean in src/type-graph/types/union-type.js so Boolean should exists in Type\n\n\n    if (this === Type.Boolean || this === Type.True || this === Type.False) {\n      return Type.GlobalTypeScope.body.get(\"Boolean\");\n    }\n\n    if (this === Type.Symbol || this.isSubtypeOf === Type.Symbol) {\n      return Type.GlobalTypeScope.body.get(\"Symbol\");\n    }\n\n    if (this === Type.BigInt || this.isSubtypeOf === Type.BigInt) {\n      return Type.GlobalTypeScope.body.get(\"BigInt\");\n    }\n  }\n\n  isSimpleType() {\n    return this === Type.String || this.isSubtypeOf === Type.String || this === Type.Number || this.isSubtypeOf === Type.Number || this === Type.BigInt || this.isSubtypeOf === Type.BigInt || this === Type.Boolean || this === Type.True || this === Type.False || this === Type.Symbol || this.isSubtypeOf === Type.Symbol || this === Type.Null || this === Type.Undefined;\n  }\n\n}\n\nexports.Type = Type;\n\n_defineProperty(Type, \"GlobalTypeScope\", void 0);\n\n_defineProperty(Type, \"Undefined\", new Type(\"undefined\"));\n\n_defineProperty(Type, \"Null\", new Type(null));\n\n_defineProperty(Type, \"String\", new Type(\"string\"));\n\n_defineProperty(Type, \"Symbol\", new Type(\"symbol\"));\n\n_defineProperty(Type, \"True\", new Type(true));\n\n_defineProperty(Type, \"False\", new Type(false));\n\n_defineProperty(Type, \"Number\", new Type(\"number\"));\n\n_defineProperty(Type, \"BigInt\", new Type(\"bigint\"));\n\n_defineProperty(Type, \"Unknown\", new Type(\"unknown\"));\n\n_defineProperty(Type, \"Never\", new Type(\"never\"));\n\n_defineProperty(Type, \"prettyMode\", false);","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnionType = undefined;\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// $FlowIssue\nclass UnionType extends _type.Type {\n  static get name() {\n    return \"UnionType\";\n  }\n\n  static term(name, meta = {}, variants, ...args) {\n    variants = UnionType.flatten(variants);\n    variants = UnionType.rollup(variants);\n\n    if (variants.length === 1) {\n      return variants[0];\n    }\n\n    name = name == null ? UnionType.getName(variants) : name;\n    let parent = meta.parent;\n    const length = variants.length;\n\n    for (let i = 0; i < length; i++) {\n      const variant = variants[i];\n\n      if (variant instanceof _type.Type && (parent === undefined || parent.priority < variant.parent.priority)) {\n        parent = variant.parent;\n      }\n    }\n\n    const newMeta = { ...meta,\n      parent\n    };\n    return super.term(name, newMeta, variants, ...args);\n  }\n\n  static getName(params) {\n    const isMultyLine = this.prettyMode && params.length >= 4;\n    const isBooleanExist = params.some(p => p === _type.Type.True) && params.some(p => p === _type.Type.False);\n\n    if (isBooleanExist) {\n      params = params.filter(p => p !== _type.Type.True && p !== _type.Type.False).concat(UnionType.Boolean);\n    }\n\n    return `${params.sort((t1, t2) => String(t1.name).localeCompare(String(t2.name))).reduce((res, t) => {\n      const isFunction = \"argumentsTypes\" in t || // $FlowIssue\n      \"subordinateType\" in t && \"argumentsTypes\" in t.subordinateType;\n      let typeName = String(t.name);\n\n      if (isFunction) {\n        typeName = `(${typeName})`;\n      }\n\n      return isMultyLine ? this.multyLine(res, typeName) : this.oneLine(res, typeName);\n    }, \"\")}`;\n  }\n\n  static oneLine(res, typeName) {\n    return `${res}${res ? \" | \" : \"\"}${typeName}`;\n  }\n\n  static multyLine(res, typeName) {\n    return `${res}${res ? \"\\n| \" : \"  \"}${typeName}`;\n  }\n\n  static flatten(variants) {\n    // $FlowIssue\n    return variants.flatMap(variant => variant instanceof UnionType ? this.flatten(variant.variants) : [_type.Type.getTypeRoot(variant)]);\n  }\n\n  static shouldBeSkipped(variant) {\n    return \"subordinateMagicType\" in variant || variant instanceof _typeVar.TypeVar || variant === _type.Type.Unknown;\n  }\n\n  static uniqueVariants(set) {\n    let unique = [];\n\n    for (let i = 0; i < set.length; i++) {\n      const currentType = set[i];\n\n      if (unique.includes(currentType)) {\n        continue;\n      }\n\n      if (this.shouldBeSkipped(currentType)) {\n        unique.push(currentType);\n        continue;\n      }\n\n      if (!unique.some(existed => !this.shouldBeSkipped(existed) && existed.isPrincipalTypeFor(currentType))) {\n        unique = [...unique.filter(t => this.shouldBeSkipped(t) || !currentType.isPrincipalTypeFor(t)), currentType];\n      }\n    }\n\n    return unique;\n  }\n\n  static rollup(variants) {\n    return variants.length === 1 ? [variants[0]] : this.uniqueVariants(variants);\n  }\n\n  constructor(name, meta = {}, variants) {\n    variants = UnionType.flatten(variants);\n    variants = UnionType.rollup(variants);\n\n    if (variants.length === 1) {\n      return variants[0];\n    }\n\n    name = name == null ? UnionType.getName(variants) : name;\n    super(name, meta);\n\n    _defineProperty(this, \"variants\", void 0);\n\n    this.variants = variants.sort((t1, t2) => String(t1.name).localeCompare(String(t2.name)));\n  }\n\n  changeAll(sourceTypes, targetTypes, typeScope) {\n    if (sourceTypes.every(type => !this.canContain(type))) {\n      return this;\n    }\n\n    const currentSelf = _typeVar.TypeVar.createSelf(this.getChangedName(sourceTypes, targetTypes), this.parent);\n\n    if (this._changeStack !== null && this._changeStack.find(a => a.equalsTo(currentSelf))) {\n      return currentSelf;\n    }\n\n    this._changeStack = this._changeStack === null ? [currentSelf] : [...this._changeStack, currentSelf];\n\n    try {\n      let isVariantsChanged = false;\n      const newVariants = this.variants.map(t => {\n        const newT = t.changeAll(sourceTypes, targetTypes, typeScope);\n\n        if (newT === t) {\n          return t;\n        }\n\n        isVariantsChanged = true;\n        return newT;\n      });\n      return this.endChanges(!isVariantsChanged ? this : UnionType.term(null, {}, newVariants));\n    } catch (e) {\n      this._changeStack = null;\n      throw e;\n    }\n  }\n\n  equalsTo(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this.referenceEqualsTo(anotherType) || this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n    const anotherVariants = anotherType instanceof UnionType ? anotherType.variants : [];\n    const result = anotherType instanceof UnionType && super.equalsTo(anotherType) && this.canContain(anotherType) && this.variants.length === anotherVariants.length && this.variants.every((type, index) => type.equalsTo(anotherVariants[index]));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  isSuperTypeFor(anotherType) {\n    anotherType = this.getOponentType(anotherType);\n\n    if (this._alreadyProcessedWith === anotherType) {\n      return true;\n    }\n\n    this._alreadyProcessedWith = anotherType;\n\n    if (anotherType instanceof UnionType) {\n      for (const variantType of anotherType.variants) {\n        if (!this.variants.some(type => type.isPrincipalTypeFor(variantType))) {\n          this._alreadyProcessedWith = null;\n          return false;\n        }\n      }\n\n      this._alreadyProcessedWith = null;\n      return true;\n    }\n\n    const result = this.variants.some(type => type.isPrincipalTypeFor(anotherType));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getPropertyType(propertyName) {\n    return null;\n  }\n\n  contains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.variants.some(v => v.contains(type));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  getDifference(type, withReverseUnion = false) {\n    if (this._alreadyProcessedWith === type || this.referenceEqualsTo(type)) {\n      return [];\n    }\n\n    this._alreadyProcessedWith = type;\n\n    if (type instanceof UnionType || withReverseUnion) {\n      // $FlowIssue\n      const diff = this.variants.flatMap(variant => variant.getDifference(type, withReverseUnion));\n      const reducer = new Map();\n\n      for (const {\n        root,\n        variable\n      } of diff) {\n        const existed = reducer.get(variable) || [];\n        existed.push(root);\n        reducer.set(variable, existed);\n      }\n\n      const aggregatedDiff = [];\n\n      for (const [variable, variants] of reducer) {\n        aggregatedDiff.push({\n          variable,\n          root: variants.length === 1 ? variants[0] : UnionType.term(null, {}, variants)\n        });\n      }\n\n      this._alreadyProcessedWith = null;\n      return aggregatedDiff;\n    }\n\n    const result = super.getDifference(type, withReverseUnion);\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  weakContains(type) {\n    if (this._alreadyProcessedWith === type || !this.canContain(type)) {\n      return false;\n    }\n\n    this._alreadyProcessedWith = type;\n    const result = super.contains(type) || this.variants.some(v => v.weakContains(type));\n    this._alreadyProcessedWith = null;\n    return result;\n  }\n\n  generalize(types, typeScope) {\n    const variants = this.variants.map(v => v.generalize(types, typeScope));\n\n    if (this.variants.every((v, i) => v === variants[i])) {\n      return this;\n    }\n\n    return UnionType.term(null, {}, variants);\n  }\n\n  containsAsGeneric(type) {\n    return this.variants.some(v => v.containsAsGeneric(type));\n  }\n\n  getNextParent(typeScope) {\n    if (this._alreadyProcessedWith !== null) {\n      return _type.Type.GlobalTypeScope;\n    }\n\n    this._alreadyProcessedWith = this;\n    const sortedParents = [...this.variants].map(a => a.getNextParent(typeScope)).sort((a, b) => b.priority - a.priority);\n\n    for (const parent of sortedParents) {\n      if (parent.priority <= typeScope.priority && parent !== typeScope) {\n        this._alreadyProcessedWith = null;\n        return parent;\n      }\n    }\n\n    this._alreadyProcessedWith = null;\n    return _type.Type.GlobalTypeScope;\n  }\n\n}\n\nexports.UnionType = UnionType; // $FlowIssue We need it to have access to Boolean type inside src/type-graph/types/type.js otherwise - circular dependency\n\n_defineProperty(UnionType, \"Boolean\", new UnionType(\"boolean\", {}, [_type.Type.True, _type.Type.False]));\n\n_type.Type.Boolean = UnionType.Boolean;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.$Values = undefined;\n\nvar _errors = require(\"../../utils/errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _type = require(\"./type\");\n\nvar _typeVar = require(\"./type-var\");\n\nvar _tupleType = require(\"./tuple-type\");\n\nvar _typeScope = require(\"../type-scope\");\n\nvar _unionType = require(\"./union-type\");\n\nvar _objectType = require(\"./object-type\");\n\nvar _genericType = require(\"./generic-type\");\n\nvar _collectionType = require(\"./collection-type\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass $Values extends _genericType.GenericType {\n  static get name() {\n    return \"$Values\";\n  }\n\n  constructor(_, meta = {}) {\n    const parent = new _typeScope.TypeScope(meta.parent);\n    super(\"$Values\", meta, [_typeVar.TypeVar.term(\"target\", {\n      parent\n    })], parent, null);\n  }\n\n  isPrincipalTypeFor() {\n    return false;\n  }\n\n  equalsTo() {\n    return false;\n  }\n\n  isSuperTypeFor() {\n    return false;\n  }\n\n  applyGeneric(parameters, loc) {\n    super.assertParameters(parameters, loc);\n    const [currentTarget] = parameters;\n    const realTarget = this.getOponentType(currentTarget);\n\n    if (realTarget instanceof _typeVar.TypeVar) {\n      return this.bottomizeWith(parameters, realTarget.parent, loc);\n    }\n\n    if (!(realTarget instanceof _objectType.ObjectType) && !(realTarget instanceof _tupleType.TupleType) && !(realTarget instanceof _collectionType.CollectionType)) {\n      throw new _errors2.default(\"First parameter should be an object or collection type\", loc);\n    }\n\n    if (realTarget instanceof _tupleType.TupleType) {\n      return realTarget.isSubtypeOf.valueType;\n    }\n\n    if (realTarget instanceof _collectionType.CollectionType) {\n      return realTarget.valueType;\n    }\n\n    const values = [...realTarget.properties.values()];\n    const variants = values.map(value => value.type);\n\n    if (!realTarget.isStrict) {\n      variants.push(_type.Type.Unknown);\n    }\n\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n}\n\nexports.$Values = $Values;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableInfo = undefined;\n\nvar _meta = require(\"./meta/meta\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass VariableInfo {\n  constructor(type, parent, meta = new _meta.Meta(), isConstant = false, isInferenced = false, isPrivate = false) {\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"isConstant\", false);\n\n    _defineProperty(this, \"hasInitializer\", false);\n\n    _defineProperty(this, \"isInferenced\", false);\n\n    _defineProperty(this, \"isPrivate\", false);\n\n    _defineProperty(this, \"meta\", void 0);\n\n    this.type = type;\n    this.parent = parent;\n    this.meta = meta;\n    this.isConstant = isConstant;\n    this.isInferenced = isInferenced;\n    this.isPrivate = isPrivate;\n  }\n\n}\n\nexports.VariableInfo = VariableInfo;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableScope = undefined;\n\nvar _scope = require(\"./scope\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n// $FlowIssue\nclass VariableScope extends _scope.Scope {\n  constructor(type, parent, declaration, creator, skipCalls = false) {\n    super(parent);\n\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"parent\", void 0);\n\n    _defineProperty(this, \"calls\", []);\n\n    _defineProperty(this, \"throwable\", void 0);\n\n    _defineProperty(this, \"declaration\", void 0);\n\n    _defineProperty(this, \"skipCalls\", void 0);\n\n    _defineProperty(this, \"isProcessed\", false);\n\n    _defineProperty(this, \"body\", void 0);\n\n    _defineProperty(this, \"creator\", void 0);\n\n    this.parent = parent;\n    this.type = type;\n    this.declaration = declaration;\n    this.skipCalls = skipCalls;\n    this.creator = creator;\n    this.body = new Map();\n  }\n\n}\n\nexports.VariableScope = VariableScope;\n\n_defineProperty(VariableScope, \"BLOCK_TYPE\", \"block\");\n\n_defineProperty(VariableScope, \"FUNCTION_TYPE\", \"function\");\n\n_defineProperty(VariableScope, \"OBJECT_TYPE\", \"object\");\n\n_defineProperty(VariableScope, \"CLASS_TYPE\", \"class\");","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addThisToClassScope = addThisToClassScope;\nexports.addClassScopeToTypeGraph = addClassScopeToTypeGraph;\nexports.addPropertyNodeToThis = addPropertyNodeToThis;\nexports.addObjectToTypeGraph = addObjectToTypeGraph;\nexports.addClassToTypeGraph = addClassToTypeGraph;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"./errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _callMeta = require(\"../type-graph/meta/call-meta\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _bottomType = require(\"../type-graph/types/bottom-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _variableUtils = require(\"./variable-utils\");\n\nvar _call = require(\"../type-graph/call\");\n\nvar _functionUtils = require(\"./function-utils\");\n\nvar _typeUtils = require(\"./type-utils\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nvar _common = require(\"./common\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addThisToClassScope(currentNode, parentNode, typeScope, typeGraph, precompute, middlecompute, postcompute) {\n  parentNode = currentNode.parentNode;\n  currentNode = currentNode.definition;\n  const classScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n  if (classScope === undefined) {\n    throw new Error(\"Never!!!\");\n  }\n\n  if (classScope.declaration !== undefined) {\n    return;\n  }\n\n  const parentTypeScope = (0, _scopeUtils.findNearestTypeScope)(classScope, typeGraph);\n  const localTypeScope = new _typeScope.TypeScope(parentTypeScope);\n  const genericArguments = currentNode.typeParameters && currentNode.typeParameters.params.map(typeAnnotation => (0, _typeUtils.getTypeFromTypeAnnotation)({\n    typeAnnotation\n  }, localTypeScope, classScope.parent, true, null, parentNode, typeGraph, precompute, middlecompute, postcompute));\n  const name = currentNode.id != undefined ? (0, _common.getDeclarationName)(currentNode) : \"{ }\";\n  const isGenericType = genericArguments != undefined;\n  const typeName = isGenericType ? _genericType.GenericType.getName(name, genericArguments) : name;\n\n  const selfObject = _objectType.ObjectType.term(typeName, {\n    parent: isGenericType ? localTypeScope : typeScope,\n    isNominal: currentNode.type === _nodes2.default.CLASS_EXPRESSION || currentNode.type === _nodes2.default.CLASS_DECLARATION\n  }, []);\n\n  const self = currentNode.typeParameters === undefined ? selfObject : new _bottomType.$BottomType({}, _genericType.GenericType.new(typeName, {\n    parent: typeScope\n  }, genericArguments, localTypeScope, selfObject), genericArguments);\n  let superClass;\n\n  if (currentNode.superClass != null) {\n    superClass = (0, _call.addCallToTypeGraph)(currentNode.superClass, typeGraph, classScope.parent, parentNode, precompute, middlecompute, postcompute).result;\n    superClass = superClass instanceof _variableInfo.VariableInfo ? superClass.type : superClass;\n\n    if (!(superClass instanceof _objectType.ObjectType && superClass.instanceType !== null)) {\n      throw new _errors2.default(\"Cannot extend class from non-class type\", currentNode.superClass.loc);\n    }\n\n    const superType = superClass.instanceType;\n\n    if (superType instanceof _genericType.GenericType && currentNode.superTypeParameters == null) {\n      throw new _errors2.default(`Generic type \"${String(superType.name)}\" should be used with type paramteres!`, currentNode.superClass.loc);\n    }\n\n    const superFunctionType = (0, _functionUtils.functionWithReturnType)( // $FlowIssue\n    superClass.properties.get(_constants.CONSTRUCTABLE).type, self);\n    const $super = new _objectType.ObjectType(String(superClass.name), {\n      isSubtypeOf: superType\n    }, [[_constants.CALLABLE, new _variableInfo.VariableInfo(superFunctionType, classScope)]]);\n    const genericParams = (currentNode.superTypeParameters || []).map(arg => (0, _typeUtils.getTypeFromTypeAnnotation)({\n      typeAnnotation: arg\n    }, typeScope, classScope.parent, true, null, parentNode, typeGraph, precompute, middlecompute, postcompute));\n    selfObject.isSubtypeOf = superType instanceof _genericType.GenericType ? superType.applyGeneric(genericParams, currentNode.superClass.loc) : superClass.instanceType;\n    classScope.body.set(\"super\", new _variableInfo.VariableInfo($super, classScope));\n  }\n\n  const selfVar = new _variableInfo.VariableInfo(self, classScope);\n  classScope.body.set(_constants.THIS_TYPE, selfVar);\n\n  if (currentNode.type === _nodes2.default.CLASS_EXPRESSION || currentNode.type === _nodes2.default.CLASS_DECLARATION) {\n    const typeInTypeScope = selfVar.type instanceof _bottomType.$BottomType ? selfVar.type.subordinateMagicType : selfVar.type;\n    parentTypeScope.body.set(name, typeInTypeScope);\n\n    if (typeInTypeScope instanceof _genericType.GenericType) {\n      typeInTypeScope.shouldBeUsedAsGeneric = true;\n    }\n\n    const staticName = getClassName(currentNode);\n    const options = {\n      isNominal: true,\n      parent: typeScope\n    };\n\n    if (superClass !== undefined) {\n      // $FlowIssue\n      options.isSubtypeOf = superClass;\n    }\n\n    const staticSelfObject = _objectType.ObjectType.term(staticName, options, []);\n\n    const staticSelfVar = new _variableInfo.VariableInfo(staticSelfObject, classScope.parent); // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n\n    classScope.parent.body.set(name, staticSelfVar);\n    classScope.declaration = staticSelfVar;\n    staticSelfObject.instanceType = self;\n    selfObject.classType = staticSelfObject;\n    const isConstructorPresented = currentNode.body.body.some(m => m.kind === \"constructor\");\n\n    if (!isConstructorPresented) {\n      const $super = classScope.body.get(\"super\");\n      const parentConstructor = $super !== undefined && $super.type instanceof _objectType.ObjectType ? $super.type.properties.get(_constants.CALLABLE) : undefined;\n      const constructor = parentConstructor && (parentConstructor.type instanceof _functionType.FunctionType || parentConstructor.type instanceof _genericType.GenericType && parentConstructor.type.subordinateType instanceof _functionType.FunctionType) ? parentConstructor : new _variableInfo.VariableInfo(_functionType.FunctionType.new(`() => ${name}`, {\n        parent: self.parent\n      }, [], self), classScope, new _meta.Meta(currentNode.loc));\n\n      if (!constructor.hasInitializer) {\n        constructor.hasInitializer = true;\n      }\n\n      let type = constructor.type instanceof _genericType.GenericType ? constructor.type.subordinateType : constructor.type;\n      type.returnType = (type.returnType instanceof _objectType.ObjectType || type.returnType instanceof _collectionType.CollectionType) && _objectType.ObjectType.Object.isPrincipalTypeFor(type.returnType) ? type.returnType : self;\n\n      if (self instanceof _bottomType.$BottomType) {\n        const localTypeScope = constructor.type instanceof _genericType.GenericType ? constructor.type.localTypeScope : self.subordinateMagicType.localTypeScope;\n        const addition = constructor.type instanceof _genericType.GenericType ? constructor.type.genericArguments : [];\n        const genericArguments = Array.from(new Set([...self.genericArguments, addition]));\n        type = _genericType.GenericType.new(`constructor ${String(self.name)}`, {}, genericArguments, localTypeScope, type);\n      }\n\n      constructor.type = type;\n      staticSelfObject.properties.set(_constants.CONSTRUCTABLE, constructor);\n    }\n  }\n\n  if (currentNode.implements) {\n    const localTypeScope = self instanceof _bottomType.$BottomType ? self.subordinateMagicType.localTypeScope : typeScope;\n    currentNode.implements = currentNode.implements.map(typeAnnotation => {\n      const typeForImplementation = (0, _typeUtils.getTypeFromTypeAnnotation)({\n        typeAnnotation\n      }, localTypeScope, classScope.parent, true, null, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n      if (!(typeForImplementation instanceof _objectType.ObjectType) || typeForImplementation.isStrict) {\n        throw new _errors2.default(\"Type which should be implemented should be an soft objecty type\", typeAnnotation.loc);\n      }\n\n      currentNode.body.body.forEach(node => {\n        if (node.type !== _nodes2.default.CLASS_PROPERTY && node.type !== _nodes2.default.CLASS_PRIVATE_PROPERTY && node.type !== _nodes2.default.CLASS_METHOD && node.type !== _nodes2.default.CLASS_PRIVATE_METHOD) {\n          return;\n        }\n\n        const propertyName = (0, _variableUtils.getPropertyName)(node);\n        const existedProperty = typeForImplementation.properties.get(propertyName);\n\n        if (existedProperty === undefined) {\n          return;\n        }\n\n        node.expected = existedProperty.type;\n      });\n      return {\n        loc: typeAnnotation.loc,\n        id: typeAnnotation.id,\n        typeForImplementation\n      };\n    });\n  }\n}\n\nfunction addThisToObjectScope(objectScope, currentNode) {\n  const properties = currentNode.expected instanceof _objectType.ObjectType ? [...currentNode.expected.properties] : [];\n  const self = new _objectType.ObjectType(\"{  }\", {}, properties);\n  const selfVar = new _variableInfo.VariableInfo(self, objectScope);\n  objectScope.body.set(_constants.THIS_TYPE, selfVar);\n}\n\nfunction addClassScopeToTypeGraph(currentNode, parentNode, typeGraph) {\n  const scopeName = _variableScope.VariableScope.getName(currentNode);\n\n  const existed = typeGraph.scopes.get(scopeName);\n\n  if (existed !== undefined) {\n    return existed;\n  }\n\n  const name = currentNode.id != undefined ? (0, _common.getDeclarationName)(currentNode) : (0, _common.getAnonymousKey)(currentNode);\n  const scope = (0, _scopeUtils.getScopeFromNode)(currentNode, parentNode, typeGraph);\n  const parentTypeScope = (0, _scopeUtils.findNearestTypeScope)(scope, typeGraph);\n  parentTypeScope.body.set(name, currentNode);\n  typeGraph.scopes.set(scopeName, scope);\n\n  if (scope.type === _variableScope.VariableScope.OBJECT_TYPE) {\n    addThisToObjectScope(scope, currentNode);\n  } else {\n    currentNode.body.body.unshift({\n      type: _nodes2.default.THIS_TYPE_DEFINITION,\n      parentNode,\n      definition: currentNode,\n      loc: currentNode.loc\n    });\n  }\n\n  return scope;\n}\n\nfunction addPropertyNodeToThis(currentNode, parentNode, typeGraph, pre, middle, post) {\n  const propertyName = (0, _variableUtils.getPropertyName)(currentNode); // $FlowIssue\n\n  const currentClassScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, typeGraph);\n\n  if (currentClassScope.isProcessed) {\n    return;\n  } // $FlowIssue\n\n\n  const self = currentNode.static || propertyName === _constants.CONSTRUCTABLE ? currentClassScope.declaration : currentClassScope.findVariable({\n    name: _constants.THIS_TYPE\n  }, parentNode, typeGraph, pre, middle, post);\n  const selfType = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (!(selfType instanceof _objectType.ObjectType)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const existedProperty = selfType.properties.get(propertyName);\n\n  if (existedProperty !== undefined && (currentClassScope.type === _variableScope.VariableScope.CLASS_TYPE || existedProperty instanceof _variableInfo.VariableInfo && existedProperty.hasInitializer)) {\n    throw new _errors2.default(\"Duplicated property definition!\", currentNode.loc);\n  }\n\n  if (!(existedProperty instanceof _variableInfo.VariableInfo)) {\n    selfType.properties.set(propertyName, currentNode);\n  }\n}\n\nfunction addObjectToTypeGraph(currentNode, typeGraph) {\n  const objectScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(currentNode));\n\n  if (objectScope === undefined) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const self = objectScope.body.get(_constants.THIS_TYPE);\n\n  if (!(self instanceof _variableInfo.VariableInfo)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  let selfType = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (!(selfType instanceof _objectType.ObjectType)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const properties = [];\n\n  for (const [key, property] of selfType.properties.entries()) {\n    if (property.hasInitializer) {\n      properties.push([key, property]);\n    }\n  }\n\n  const name = _objectType.ObjectType.getName(properties, selfType);\n\n  selfType = _objectType.ObjectType.term(name, {}, properties);\n  self.type = selfType;\n  objectScope.isProcessed = true;\n  return self;\n}\n\nfunction addClassToTypeGraph(classNode, typeScope, typeGraph, parentNode, pre, middle, post, isTypeDefinitions) {\n  const classScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(classNode));\n  const name = classNode.id != undefined ? (0, _common.getDeclarationName)(classNode) : (0, _common.getAnonymousKey)(classNode);\n\n  if (!(classScope instanceof _variableScope.VariableScope)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  const self = classScope.findVariable({\n    name: _constants.THIS_TYPE\n  }, parentNode, typeGraph, pre, middle, post); // $FlowIssue\n\n  const {\n    properties\n  } = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (self.type.name === \"{  }\") {\n    self.type.name = _objectType.ObjectType.getName([...properties]);\n  }\n\n  const superType = classScope.body.get(\"super\");\n  typeScope.body.set(name, self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType : self.type);\n  const selfObject = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.subordinateType : self.type;\n\n  if (!(selfObject instanceof _objectType.ObjectType)) {\n    throw new Error(\"Never!!!\");\n  }\n\n  selfObject.parent = [...selfObject.properties].reduce((parent, [_, {\n    type\n  }]) => type !== undefined && parent.priority < type.parent.priority ? type.parent : parent, selfObject.parent);\n  const existedConstructor = classNode.body.body.find(m => m.kind === \"constructor\");\n\n  if (existedConstructor && !isTypeDefinitions) {\n    const constructorScope = typeGraph.scopes.get(_variableScope.VariableScope.getName(existedConstructor));\n\n    if (!(constructorScope instanceof _variableScope.VariableScope)) {\n      throw new Error(\"Never!!!\");\n    }\n\n    if (constructorScope.calls.find(call => call.targetName === \"return\") === undefined) {\n      const callMeta = new _callMeta.CallMeta(new _functionType.FunctionType(\"\", {}, [self.type], self.type), [self], // $FlowIssue\n      constructorScope.declaration.meta.loc, \"return\", self.type.parent, false, true);\n      constructorScope.calls.push(callMeta);\n    }\n\n    if (superType !== undefined) {\n      const superCallIndex = constructorScope.calls.findIndex(call => call.targetName === \"super\");\n      const thisCallIndex = constructorScope.calls.findIndex(call => call.targetName === \"this\");\n\n      if (superCallIndex === -1) {\n        throw new _errors2.default('Constructor must contain \"super\" call super inside', // $FlowIssue\n        constructorScope.declaration.meta.loc);\n      }\n\n      if (thisCallIndex !== -1 && superCallIndex > thisCallIndex) {\n        throw new _errors2.default('\"super\" must be called before accessing \"this\"', constructorScope.calls[thisCallIndex].loc);\n      }\n    }\n  }\n\n  if (classNode.implements) {\n    const localTypeScope = self.type instanceof _bottomType.$BottomType ? self.type.subordinateMagicType.localTypeScope : typeScope;\n    classNode.implements.forEach(({\n      typeForImplementation,\n      id,\n      loc\n    }) => {\n      if (!typeForImplementation.isPrincipalTypeFor(self.type)) {\n        throw new _errors2.default(`Wrong implementation for type \"${id.name}\"`, loc);\n      }\n    });\n  }\n\n  const {\n    declaration\n  } = classScope;\n\n  if (!isTypeDefinitions && declaration !== undefined && declaration.type instanceof _objectType.ObjectType) {\n    const errors = [];\n    [...properties, ...declaration.type.properties].forEach(([key, property]) => {\n      if (!property.hasInitializer && !property.type.contains(_type.Type.Undefined)) {\n        errors.push(new _errors2.default(`Property \"${key}\" has a type, but doesn't have an initializer!`, property.meta.loc));\n      }\n    });\n\n    if (errors.length !== 0) {\n      throw errors;\n    }\n  }\n\n  classScope.isProcessed = true; // $FlowIssue\n\n  return classScope.declaration;\n}\n\nfunction getClassName(classNode) {\n  if (classNode.id !== null) {\n    return `class ${classNode.id.name}`;\n  }\n\n  return `Anonymous Class [${classNode.loc.start.line}:${classNode.loc.end.line}]`;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDeclarationName = exports.getAnonymousKey = undefined;\nexports.unique = unique;\nexports.intersection = intersection;\nexports.union = union;\nexports.getMemberExressionTarget = getMemberExressionTarget;\nexports.ensureArray = ensureArray;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst getAnonymousKey = exports.getAnonymousKey = node => `[[Anonymuos${node.loc.start.line}-${node.loc.start.column}]]`;\n\nconst getDeclarationName = exports.getDeclarationName = node => node.id.name;\n\nfunction unique(arr, getKey = x => x) {\n  const filterObject = {};\n\n  for (let i = 0; i < arr.length; i++) {\n    const key = getKey(arr[i]);\n    filterObject[key] = arr[i];\n  }\n\n  return Object.values(filterObject);\n}\n\nfunction intersection(arr1, arr2, isEquals = (a, b) => a === b) {\n  const intersectionResult = [];\n  const exclusiveOr = [];\n\n  for (let i = 0; i < arr1.length; i++) {\n    for (let j = 0; j < arr2.length; j++) {\n      if (!isEquals(arr1[i], arr2[j])) {\n        exclusiveOr.push(arr1[i], arr2[j]);\n        continue;\n      }\n\n      intersectionResult.push(arr2[j]);\n    }\n  }\n\n  return [intersectionResult, exclusiveOr];\n}\n\nfunction union(arr1, arr2, isEquals = (a, b) => a === b) {\n  const unionResult = [];\n\n  for (let i = 0; i < arr1.length; i++) {\n    for (let j = 0; j < arr2.length; j++) {\n      if (isEquals(arr1[i], arr2[j])) {\n        unionResult.push(arr2[j]);\n        continue;\n      }\n\n      unionResult.push(arr2[j]);\n    }\n  }\n\n  return unionResult;\n}\n\nfunction getMemberExressionTarget(node) {\n  let target = node;\n\n  do {\n    target = target.object;\n  } while (target.type === _nodes2.default.MEMBER_EXPRESSION);\n\n  return target;\n}\n\nfunction ensureArray(value) {\n  if (value === undefined || value === null) {\n    return [];\n  } // $FlowIssue\n\n\n  return Array.isArray(value) ? value : [value];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass HegelError extends Error {\n  constructor(message, loc, source = \"\") {\n    super(message);\n\n    _defineProperty(this, \"loc\", void 0);\n\n    _defineProperty(this, \"source\", void 0);\n\n    this.source = source;\n    this.loc = loc && {\n      end: loc.end,\n      start: loc.start\n    };\n  }\n\n}\n\nexports.default = HegelError;\n\nclass UnreachableError extends Error {\n  constructor(loc) {\n    super(\"\");\n\n    _defineProperty(this, \"loc\", void 0);\n\n    this.loc = {\n      end: loc.end,\n      start: loc.start\n    };\n  }\n\n}\n\nexports.UnreachableError = UnreachableError;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addFunctionScopeToTypeGraph = addFunctionScopeToTypeGraph;\nexports.addFunctionNodeToTypeGraph = addFunctionNodeToTypeGraph;\nexports.addFunctionToTypeGraph = addFunctionToTypeGraph;\nexports.isCallableType = isCallableType;\nexports.isSideEffectCall = isSideEffectCall;\nexports.functionWithReturnType = functionWithReturnType;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _variableUtils = require(\"./variable-utils\");\n\nvar _inference = require(\"../inference\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _common = require(\"./common\");\n\nvar _scopeUtils = require(\"../utils/scope-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addFunctionScopeToTypeGraph(currentNode, parentNode, moduleScope, variableInfo) {\n  const scope = (0, _scopeUtils.getScopeFromNode)(currentNode, parentNode, moduleScope, variableInfo);\n  scope.throwable = [];\n  moduleScope.scopes.set(_variableScope.VariableScope.getName(currentNode), scope);\n\n  if (currentNode.type === _nodes2.default.FUNCTION_EXPRESSION && currentNode.id) {\n    // $FlowIssue In Flow VariableInfo<ObjectType> is incompatible with VariableInfo<Type> even if you don't mutate argument\n    scope.body.set((0, _common.getDeclarationName)(currentNode), variableInfo);\n  }\n\n  return scope;\n}\n\nfunction addFunctionNodeToTypeGraph(currentNode, parentNode, moduleScope) {\n  const name = (0, _common.getDeclarationName)(currentNode);\n  const currentScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, moduleScope);\n  currentScope.body.set(name, currentNode);\n}\n\nfunction addFunctionToTypeGraph(currentNode, parentNode, moduleScope, pre, middle, post, isTypeDefinitions) {\n  const name = currentNode.type === _nodes2.default.FUNCTION_DECLARATION || currentNode.type === _nodes2.default.TS_FUNCTION_DECLARATION ? (0, _common.getDeclarationName)(currentNode) : (0, _common.getAnonymousKey)(currentNode);\n  const variableInfo = (0, _variableUtils.addVariableToGraph)(currentNode, parentNode, moduleScope, pre, middle, post, name);\n  variableInfo.isInferenced = currentNode.returnType === undefined;\n  const currentTypeScope = (0, _scopeUtils.findNearestTypeScope)(variableInfo.parent, moduleScope);\n  const scope = isTypeDefinitions ? new _variableScope.VariableScope(_variableScope.VariableScope.FUNCTION_TYPE, variableInfo.parent) : addFunctionScopeToTypeGraph(currentNode, parentNode, moduleScope, variableInfo);\n  variableInfo.type = (0, _inference.inferenceTypeForNode)(currentNode, currentTypeScope, variableInfo.parent, moduleScope, parentNode, pre, middle, post, isTypeDefinitions);\n  const expected = currentNode.expected;\n  const expectedType = expected instanceof _genericType.GenericType ? expected.subordinateType : expected;\n  let functionType = variableInfo.type instanceof _genericType.GenericType ? variableInfo.type.subordinateType : variableInfo.type;\n  let genericArgumentsTypes = variableInfo.type instanceof _genericType.GenericType ? variableInfo.type.genericArguments : [];\n\n  if (expected instanceof _genericType.GenericType) {\n    genericArgumentsTypes = [...genericArgumentsTypes, ...expected.genericArguments];\n  }\n\n  if (expectedType instanceof _functionType.FunctionType) {\n    const inferencedArgumentsTypes = functionType.argumentsTypes;\n    const expectedArgumentsTypes = expectedType.argumentsTypes;\n    const argumentsTypes = Array.from({\n      length: Math.max(inferencedArgumentsTypes.length, expectedArgumentsTypes.length)\n    });\n    let wereArgumentsChanged = false;\n    const newArgumentsTypes = argumentsTypes.reduce((res, _, i) => {\n      const expectedArgumentType = expectedArgumentsTypes[i];\n      const inferencedArgumentType = inferencedArgumentsTypes[i];\n\n      if (inferencedArgumentType instanceof _typeVar.TypeVar && !inferencedArgumentType.isUserDefined && expectedArgumentType !== undefined) {\n        wereArgumentsChanged = true;\n        return [...res, expectedArgumentType];\n      }\n\n      if (inferencedArgumentType !== undefined) {\n        return [...res, inferencedArgumentType];\n      }\n\n      return res;\n    }, []);\n    const newReturnType = functionType.returnType instanceof _typeVar.TypeVar && !functionType.returnType.isUserDefined && expectedType.returnType.parent.priority <= 1 ? expectedType.returnType : functionType.returnType;\n\n    if (wereArgumentsChanged || newReturnType !== functionType.returnType) {\n      const functionTypeName = _functionType.FunctionType.getName(newArgumentsTypes, newReturnType, genericArgumentsTypes, currentNode.async, functionType.throwable);\n\n      functionType = _functionType.FunctionType.term(functionTypeName, {}, newArgumentsTypes, newReturnType);\n      variableInfo.isInferenced = false;\n      variableInfo.type = genericArgumentsTypes.length > 0 ? _genericType.GenericType.new(functionTypeName, {}, genericArgumentsTypes, // $FlowIssue\n      variableInfo.type.localTypeScope, functionType) : functionType;\n    }\n  }\n\n  const withPositions = moduleScope instanceof _moduleScope.PositionedModuleScope;\n  const argumentsTypes = functionType.argumentsTypes;\n  currentNode.params.forEach((param, index) => {\n    let type = argumentsTypes[index];\n\n    if (type === undefined) {\n      type = argumentsTypes[argumentsTypes.length - 1];\n\n      if (!(type instanceof _functionType.RestArgument)) {\n        type = _type.Type.Undefined;\n      }\n    }\n\n    const id = param.left || param.argument || param;\n\n    if (param.left != undefined && type instanceof _unionType.UnionType) {\n      const types = type.variants.filter(a => a !== _type.Type.Undefined);\n      type = _unionType.UnionType.term(null, {\n        parent: currentTypeScope\n      }, types);\n    }\n\n    if (type instanceof _functionType.RestArgument) {\n      if (param.argument != undefined) {\n        type = type.type;\n      } else {\n        type = type.type.getPropertyType(index);\n      }\n    }\n\n    let varInfo = scope.body.get(id.name);\n\n    if (varInfo !== undefined) {\n      varInfo.type = type;\n      varInfo.parent = scope;\n    } else {\n      varInfo = new _variableInfo.VariableInfo(type, scope, new _meta.Meta(id.loc));\n      scope.body.set(id.name, varInfo);\n    }\n\n    if (withPositions) {\n      // $FlowIssue\n      moduleScope.addPosition(id, varInfo);\n    }\n  });\n\n  if (withPositions && currentNode.id != null) {\n    // $FlowIssue\n    moduleScope.addPosition(currentNode.id, variableInfo);\n  }\n\n  return variableInfo;\n}\n\nfunction isCallableType(a) {\n  if (a instanceof _genericType.GenericType) {\n    a = a.subordinateType;\n  }\n\n  return a instanceof _functionType.FunctionType;\n}\n\nfunction isSideEffectCall(node, invocationResult) {\n  return node.type === _nodes2.default.EXPRESSION_STATEMENT && // i.e we don't assign a return value of it to any variable\n  node.expression != null && //\n  node.expression.type === _nodes2.default.CALL_EXPRESSION && // if we call a function like a side effect.\n  !invocationResult.equalsTo(_type.Type.Undefined) && // but call of this function actually return something.\n  !invocationResult.equalsTo(_type.Type.Undefined.promisify()) // but call of this function actually return something.\n  ;\n}\n\nfunction functionWithReturnType(functionType, newReturnType) {\n  const oldFunctionType = functionType instanceof _genericType.GenericType ? functionType.subordinateType : functionType;\n  const newFunctionArguments = [...oldFunctionType.argumentsTypes];\n  const newFunctionGenericArguments = functionType instanceof _genericType.GenericType ? [...functionType.genericArguments] : [];\n\n  const newFunctionType = _functionType.FunctionType.term(_functionType.FunctionType.getName(newFunctionArguments, newReturnType, newFunctionGenericArguments, oldFunctionType.isAsync), {}, newFunctionArguments, newReturnType);\n\n  if (!(functionType instanceof _genericType.GenericType) || newFunctionType instanceof _genericType.GenericType) {\n    return newFunctionType;\n  }\n\n  return _genericType.GenericType.new(newFunctionType.name, {}, newFunctionGenericArguments, functionType.localTypeScope, newFunctionType);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nconst mixBaseGlobals = moduleScope => {\n  const typeScope = moduleScope.typeScope;\n  const globalTypes = [[\"unknown\", _type.Type.Unknown], [\"never\", _type.Type.Never], [\"undefined\", _type.Type.Undefined], [null, _type.Type.Null], [\"number\", _type.Type.Number], [\"bigint\", _type.Type.BigInt], [\"string\", _type.Type.String], [true, _type.Type.True], [false, _type.Type.False], [\"boolean\", _unionType.UnionType.Boolean], [\"symbol\", _type.Type.Symbol]];\n  const globals = [[\"undefined\", new _variableInfo.VariableInfo(_type.Type.Undefined)]];\n\n  for (const [name, type] of globalTypes) {\n    typeScope.body.set(name, type);\n    type.parent = typeScope;\n  }\n\n  for (const [name, variable] of globals) {\n    moduleScope.body.set(name, variable);\n    variable.parent = moduleScope;\n  }\n};\n\nexports.default = mixBaseGlobals;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupBaseHierarchy = setupBaseHierarchy;\nexports.setupFullHierarchy = setupFullHierarchy;\nexports.dropAllGlobals = dropAllGlobals;\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nfunction setupBaseHierarchy(globalTypeScope) {\n  _type.Type.GlobalTypeScope = globalTypeScope;\n  _type.Type.Undefined.parent = globalTypeScope;\n  _type.Type.Null.parent = globalTypeScope;\n  _type.Type.String.parent = globalTypeScope;\n  _type.Type.Symbol.parent = globalTypeScope;\n  _type.Type.True.parent = globalTypeScope;\n  _type.Type.False.parent = globalTypeScope;\n  _unionType.UnionType.Boolean.parent = globalTypeScope;\n  _type.Type.Number.parent = globalTypeScope;\n  _type.Type.BigInt.parent = globalTypeScope;\n  _type.Type.Unknown.parent = globalTypeScope;\n  _type.Type.Never.parent = globalTypeScope;\n  _objectType.ObjectType.Object.parent = globalTypeScope;\n  _functionType.FunctionType.Function.parent = globalTypeScope;\n  _tupleType.TupleType.ReadonlyArray.parent = globalTypeScope;\n  _collectionType.CollectionType.Array.parent = globalTypeScope;\n  _typeVar.TypeVar.Self.parent = globalTypeScope;\n}\n\nfunction setupFullHierarchy(globalTypeScope) {\n  _objectType.ObjectType.Object.root = _objectType.ObjectType.term(\"Object\", {}, []);\n  globalTypeScope.body.set(\"Object\", _objectType.ObjectType.Object);\n  _functionType.FunctionType.Function.root = _objectType.ObjectType.term(\"Function\", {}, []);\n  globalTypeScope.body.set(\"Function\", _functionType.FunctionType.Function);\n  const readonlyArrayLocal = new _typeScope.TypeScope(globalTypeScope);\n  _tupleType.TupleType.ReadonlyArray.root = _genericType.GenericType.term(\"ReadonlyArray\", {}, [_typeVar.TypeVar.new(\"T\", {\n    parent: readonlyArrayLocal\n  })], readonlyArrayLocal, _objectType.ObjectType.new(\"ReadonlyArray<T>\", {\n    parent: readonlyArrayLocal\n  }, []));\n  _tupleType.TupleType.ReadonlyArray.name = \"$Immutable<Array<T>>\";\n  _tupleType.TupleType.ReadonlyArray.root.name = \"$Immutable<Array<T>>\";\n  _tupleType.TupleType.ReadonlyArray.root.subordinateType.name = \"$Immutable<Array<T>>\";\n  const arrayLocal = new _typeScope.TypeScope(globalTypeScope);\n  _collectionType.CollectionType.Array.root = _genericType.GenericType.term(\"Array\", {}, [_typeVar.TypeVar.new(\"T\", {\n    parent: arrayLocal\n  })], arrayLocal, _objectType.ObjectType.new(\"Array<T>\", {\n    parent: arrayLocal\n  }, []));\n}\n\nfunction dropAllGlobals() {\n  _objectType.ObjectType.Object.root = undefined;\n  _functionType.FunctionType.Function.root = undefined;\n  _tupleType.TupleType.ReadonlyArray.root = undefined;\n  _collectionType.CollectionType.Array.root = undefined;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst IGNORE_COMMENT = \"@hegel-issue\";\n\nclass IgnorableArray extends Array {\n  static withIgnoring(comments) {\n    const ignored = new Set(comments.filter(comment => comment.value.trim() === IGNORE_COMMENT).map(comment => comment.loc.end.line + 1));\n    return new IgnorableArray(ignored);\n  }\n\n  constructor(ignored) {\n    super();\n\n    _defineProperty(this, \"_ignored\", void 0);\n\n    this._ignored = ignored;\n  }\n\n  push(...elements) {\n    elements.forEach(element => {\n      if (element.loc === undefined || !this._ignored.has(element.loc.start.line)) {\n        super.push(element);\n      }\n    }); // It's needed for backward compatibility with Array\n\n    return 0;\n  }\n\n}\n\nexports.IgnorableArray = IgnorableArray;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importDependencies = importDependencies;\nexports.default = mixImportedDependencies;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"./errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getImportName(specifier) {\n  if (specifier.type === _nodes2.default.IMPORT_SPECIFIER) {\n    return specifier.imported.name;\n  }\n\n  if (specifier.type === _nodes2.default.IMPORT_DEFAULT_SPECIFIER) {\n    return \"default\";\n  }\n\n  return null;\n}\n\nfunction importDependencies(modulePath, importNode, sourceModuleTypeGraph, currentModuleTypeGraph, currentModuleTypeScope, isTypeDefinitions) {\n  const {\n    exports,\n    exportsTypes\n  } = sourceModuleTypeGraph;\n  const importSource = importNode.importKind === \"type\" || isTypeDefinitions ? exportsTypes : exports;\n  const importTarget = importNode.importKind === \"type\" || isTypeDefinitions ? currentModuleTypeScope : currentModuleTypeGraph;\n  const importEntries = [...importSource.entries()].map(([key, a]) => [key, a instanceof _variableInfo.VariableInfo ? a : new _variableInfo.VariableInfo(a, sourceModuleTypeGraph)]);\n  const withPositions = currentModuleTypeGraph instanceof _moduleScope.PositionedModuleScope;\n  const shouldBeVariable = importTarget instanceof _moduleScope.ModuleScope;\n  importNode.specifiers.forEach(specifier => {\n    const importName = getImportName(specifier);\n    let importElement = importName ? importSource.get(importName) || exports.get(importName) : _objectType.ObjectType.term(_objectType.ObjectType.getName(importEntries), {\n      typeScope: currentModuleTypeScope\n    }, importEntries);\n\n    if (importElement === undefined) {\n      throw new _errors2.default(`Module \"${importNode.source.value}\" hasn't \"${importName || \"*\"}\" export`, specifier.loc, modulePath);\n    }\n\n    if (importElement instanceof _objectType.ObjectType && importElement.instanceType !== null) {\n      currentModuleTypeScope.body.set(importName, importElement.instanceType);\n    }\n\n    if (shouldBeVariable && !(importElement instanceof _variableInfo.VariableInfo)) {\n      importElement = new _variableInfo.VariableInfo(importElement, // $FlowIssue\n      importTarget, new _meta.Meta(specifier.loc));\n    }\n\n    let finalImportVariable = importElement;\n\n    if (importNode.importKind !== \"type\" && !isTypeDefinitions && importElement instanceof _type.Type) {\n      finalImportVariable = new _variableInfo.VariableInfo(importElement, currentModuleTypeGraph);\n    }\n\n    if ((importNode.importKind === \"type\" || isTypeDefinitions) && importElement instanceof _variableInfo.VariableInfo) {\n      finalImportVariable = importElement.type;\n    } // $FlowIssue\n\n\n    importTarget.body.set(specifier.local.name, finalImportVariable);\n\n    if (withPositions) {\n      // $FlowIssue\n      currentModuleTypeGraph.addPosition(specifier, finalImportVariable);\n    }\n  });\n}\n\nasync function mixImportedDependencies(ast, path, errors, currentModuleScope, currentTypeScope, getModuleTypeGraph, isTypeDefinitions) {\n  const importRequests = [];\n  let importCount = 0;\n\n  for (importCount = 0; importCount < ast.body.length; importCount++) {\n    const node = ast.body[importCount];\n\n    if (node.type === _nodes2.default.INTERPRETER_DIRECTIVE) {\n      continue;\n    }\n\n    if (!_nodes2.default.isImport(node)) {\n      break;\n    }\n\n    importRequests.push(Promise.all([node, getModuleTypeGraph(node.source.value, path, node.loc).then(module => {\n      if (errors.some(error => error.source === module.path) && currentModuleScope instanceof _moduleScope.PositionedModuleScope) {\n        errors.push(new _errors2.default(`There are problems inside \"${node.source.value}\"`, node.loc, currentModuleScope.path));\n      }\n\n      return module;\n    })]));\n  }\n\n  if (importCount !== 0) {\n    ast.body.splice(0, importCount);\n  }\n\n  const importedTypeGraphs = await Promise.all(importRequests);\n\n  for (let i = 0; i < importedTypeGraphs.length; i++) {\n    try {\n      const [importNode, moduleTypeGraph] = importedTypeGraphs[i];\n      importDependencies(path, importNode, moduleTypeGraph, currentModuleScope, currentTypeScope, isTypeDefinitions);\n    } catch (e) {\n      if (!(e instanceof _errors2.default)) {\n        throw e;\n      }\n\n      errors.push(e);\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypesFromVariants = getTypesFromVariants;\nexports.getPropertyChaining = getPropertyChaining;\nexports.mergeRefinementsVariants = mergeRefinementsVariants;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _typeUtils = require(\"./type-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getTypesFromVariants(_refinementedVariants, _alternateVariants, typeScope) {\n  // $FlowIssue\n  const refinementedVariants = _refinementedVariants.filter(a => a != undefined); // $FlowIssue\n\n\n  const alternateVariants = _alternateVariants.filter(a => a != undefined);\n\n  return [refinementedVariants.length ? _unionType.UnionType.term(null, {}, refinementedVariants) : undefined, alternateVariants.length ? _unionType.UnionType.term(null, {}, alternateVariants) : undefined];\n}\n\nfunction getPropertyChaining(node) {\n  let memberPointer = node;\n  const chaining = [];\n\n  do {\n    if (memberPointer.property.type !== _nodes2.default.IDENTIFIER || memberPointer.computed) {\n      return;\n    }\n\n    chaining.unshift(memberPointer.property.name || memberPointer.property.value);\n    memberPointer = memberPointer.object;\n  } while (memberPointer.type === _nodes2.default.MEMBER_EXPRESSION);\n\n  return chaining;\n}\n\nfunction mergeRefinementsVariants(refinementedType, alternateType, originalProperty, propertyName, typeScope) {\n  const nestedRefinementedType = refinementedType && (0, _typeUtils.createObjectWith)(propertyName, refinementedType, typeScope, originalProperty.meta);\n  const nestedAlternateType = alternateType && (0, _typeUtils.createObjectWith)(propertyName, alternateType, typeScope, originalProperty.meta);\n  return [nestedRefinementedType && (0, _typeUtils.mergeObjectsTypes)( // $FlowIssue\n  originalProperty.type, nestedRefinementedType, typeScope), nestedAlternateType && // $FlowIssue\n  (0, _typeUtils.mergeObjectsTypes)(originalProperty.type, nestedAlternateType, typeScope)];\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst DECLARATION_TYPES = exports.DECLARATION_TYPES = {\n  VARIABLE_DECLARATOR: \"VariableDeclarator\",\n  VARIABLE_DECLARATION: \"VariableDeclaration\",\n  FUNCTION_DECLARATION: \"FunctionDeclaration\",\n  TS_FUNCTION_DECLARATION: \"TSDeclareFunction\",\n  TS_CALL_SIGNATURE_DECLARATION: \"TSCallSignatureDeclaration\",\n  TS_TYPE_QUERY: \"TSTypeQuery\",\n  CLASS_DECLARATION: \"ClassDeclaration\",\n  VARIABLE_DECLARATOR: \"VariableDeclarator\",\n  VARIABLE_DECLARATOR: \"VariableDeclarator\",\n  TYPE_ALIAS: \"TypeAlias\",\n  TS_TYPE_ALIAS: \"TSTypeAliasDeclaration\",\n  TS_DECLARE_METHOD: \"TSDeclareMethod\",\n  TS_INTERFACE_DECLARATION: \"TSInterfaceDeclaration\",\n  INTERFACE_DECLARATION: \"InterfaceDeclaration\",\n  TYPE_PARAMETER: \"TypeParameter\",\n  TYPE_PARAMETER_DECLARATION: \"TypeParameterDeclaration\",\n  TS_TYPE_PARAMETER_DECLARATION: \"TSTypeParameterDeclaration\",\n  TS_TYPE_PARAMETER: \"TSTypeParameter\",\n  EXPORT_LIST: \"ExportList\",\n  EXPORT_SPECIFIER: \"ExportSpecifier\",\n  EXPORT_NAMED_DECLARATION: \"ExportNamedDeclaration\",\n  EXPORT_DEFAULT_DECLARATION: \"ExportDefaultDeclaration\",\n  IMPORT_DECLARATION: \"ImportDeclaration\"\n};\nconst STATEMENTS_TYPES = exports.STATEMENTS_TYPES = {\n  PURE_KEY: \"PureKeyStatement\",\n  PURE_VALUE: \"PureValueStatement\",\n  VALUE: \"WeakValueStatement\",\n  BLOCK_STATEMENT: \"BlockStatement\",\n  IF_STATEMENT: \"IfStatement\",\n  WHILE_STATEMENT: \"WhileStatement\",\n  DO_WHILE_STATEMENT: \"DoWhileStatement\",\n  FOR_STATEMENT: \"ForStatement\",\n  FOR_IN_STATEMENT: \"ForInStatement\",\n  FOR_OF_STATEMENT: \"ForOfStatement\",\n  EXPRESSION_STATEMENT: \"ExpressionStatement\",\n  RETURN_STATEMENT: \"ReturnStatement\",\n  EMPTY_STATEMENT: \"EmptyStatement\",\n  TRY_STATEMENT: \"TryStatement\",\n  THROW_STATEMENT: \"ThrowStatement\",\n  BREAK_STATEMENT: \"BreakStatement\",\n  CONTINUE_STATEMENT: \"ContinueStatement\",\n  CATCH_CLAUSE: \"CatchClause\",\n  SWITCH_STATEMENT: \"SwitchStatement\",\n  SWITCH_CASE: \"SwitchCase\",\n  INTERPRETER_DIRECTIVE: \"InterpreterDirective\"\n};\nconst EXPRESSIONS_TYPES = exports.EXPRESSIONS_TYPES = {\n  SUPER: \"Super\",\n  ARRAY_EXPRESSION: \"ArrayExpression\",\n  SEQUENCE_EXPRESSION: \"SequenceExpression\",\n  FUNCTION_EXPRESSION: \"FunctionExpression\",\n  ARROW_FUNCTION_EXPRESSION: \"ArrowFunctionExpression\",\n  OBJECT_EXPRESSION: \"ObjectExpression\",\n  CLASS_EXPRESSION: \"ClassExpression\",\n  ASSIGNMENT_EXPRESSION: \"AssignmentExpression\",\n  TS_EXPORT_ASSIGNMENT: \"TSExportAssignment\",\n  ASSIGNMENT_PATTERN: \"AssignmentPattern\",\n  BINARY_EXPRESSION: \"BinaryExpression\",\n  UNARY_EXPRESSION: \"UnaryExpression\",\n  CONDITIONAL_EXPRESSION: \"ConditionalExpression\",\n  AWAIT_EXPRESSION: \"AwaitExpression\",\n  LOGICAL_EXPRESSION: \"LogicalExpression\",\n  CALL_EXPRESSION: \"CallExpression\",\n  MEMBER_EXPRESSION: \"MemberExpression\",\n  UPDATE_EXPRESSION: \"UpdateExpression\",\n  NEW_EXPRESSION: \"NewExpression\",\n  THIS_EXPRESSION: \"ThisExpression\",\n  TS_EXPRESSION_WITH_TYPE_ARGUMENTS: \"TSExpressionWithTypeArguments\",\n  REST_ELEMENT: \"RestElement\"\n};\nconst OBJECT_PROPERTIES = exports.OBJECT_PROPERTIES = {\n  OBJECT_EXPRESSION: \"ObjectExpression\",\n  OBJECT_METHOD: \"ObjectMethod\",\n  TS_OBJECT_METHOD: \"TSMethodSignature\",\n  OBJECT_PROPERTY: \"ObjectProperty\",\n  TS_OBJECT_PROPERTY: \"TSPropertySignature\",\n  TS_INDEX_PROPERTY: \"TSIndexSignature\",\n  TS_CONSTRUCT_SIGNATURE_DECLARATION: \"TSConstructSignatureDeclaration\"\n};\nconst CLASS_PROPERTIES = exports.CLASS_PROPERTIES = {\n  CLASS_METHOD: \"ClassMethod\",\n  CLASS_PRIVATE_METHOD: \"ClassPrivateMethod\",\n  CLASS_PROPERTY: \"ClassProperty\",\n  CLASS_PRIVATE_PROPERTY: \"ClassPrivateProperty\",\n  PRIVATE_NAME: \"PrivateName\"\n};\nconst LITERAL_TYPES = exports.LITERAL_TYPES = {\n  NUMERIC_LITERAL: \"NumericLiteral\",\n  BIGINT_LITERAL: \"BigIntLiteral\",\n  STRING_LITERAL: \"StringLiteral\",\n  BOOLEAN_LITERAL: \"BooleanLiteral\",\n  NULL_LITERAL: \"NullLiteral\",\n  REG_EXP_LITERAL: \"RegExpLiteral\",\n  TS_LITERAL_TYPE: \"TSLiteralType\",\n  TEMPLATE_LITERAL: \"TemplateLiteral\"\n};\nconst ANNOTATION_TYPES = exports.ANNOTATION_TYPES = {\n  FUNCTION_TYPE_ANNOTATION: \"FunctionTypeAnnotation\",\n  CLASS_IMPLEMENTS: \"ClassImplements\",\n  ANY_TYPE_ANNOTATION: \"AnyTypeAnnotation\",\n  VOID_TYPE_ANNOTATION: \"VoidTypeAnnotation\",\n  BOOLEAN_TYPE_ANNOTATION: \"BooleanTypeAnnotation\",\n  MIXED_TYPE_ANNOTATION: \"MixedTypeAnnotation\",\n  EMPTY_TYPE_ANNOTATION: \"EmptyTypeAnnotation\",\n  NUMBER_TYPE_ANNOTATION: \"NumberTypeAnnotation\",\n  STRING_TYPE_ANNOTATION: \"StringTypeAnnotation\",\n  NULL_LITERAL_TYPE_ANNOTATION: \"NullLiteralTypeAnnotation\",\n  GENERIC_TYPE_ANNOTATION: \"GenericTypeAnnotation\",\n  NUMBER_LITERAL_TYPE_ANNOTATION: \"NumberLiteralTypeAnnotation\",\n  BOOLEAN_LITERAL_TYPE_ANNOTATION: \"BooleanLiteralTypeAnnotation\",\n  STRING_LITERAL_TYPE_ANNOTATION: \"StringLiteralTypeAnnotation\",\n  OBJECT_TYPE_ANNOTATION: \"ObjectTypeAnnotation\",\n  OBJECT_TYPE_PROPERTY: \"ObjectTypeProperty\",\n  OBJECT_TYPE_SPREAD_PROPERTY: \"ObjectTypeSpreadProperty\",\n  UNION_TYPE_ANNOTATION: \"UnionTypeAnnotation\",\n  NULLABLE_TYPE_ANNOTATION: \"NullableTypeAnnotation\",\n  TUPLE_TYPE_ANNOTATION: \"TupleTypeAnnotation\",\n  BIGINT_LITERAL_TYPE_ANNOTATION: \"BigIntLiteralTypeAnnotation\",\n  TS_PARENTHESIZED_TYPE: \"TSParenthesizedType\",\n  TS_FUNCTION_TYPE_ANNOTATION: \"TSFunctionType\",\n  TS_ANY_TYPE_ANNOTATION: \"TSAnyKeyword\",\n  SYMBOL_TYPE_ANNOTATION: \"SymbolTypeAnnotation\",\n  TS_SYMBOL_TYPE_ANNOTATION: \"TSSymbolKeyword\",\n  TS_VOID_TYPE_ANNOTATION: \"TSVoidKeyword\",\n  TS_BOOLEAN_TYPE_ANNOTATION: \"TSBooleanKeyword\",\n  TS_UNKNOWN_TYPE_ANNOTATION: \"TSUnknownKeyword\",\n  TS_NEVER_TYPE_ANNOTATION: \"TSNeverKeyword\",\n  TS_NUMBER_TYPE_ANNOTATION: \"TSNumberKeyword\",\n  TS_BIGINT_TYPE_ANNOTATION: \"TSBigIntKeyword\",\n  TS_STRING_TYPE_ANNOTATION: \"TSStringKeyword\",\n  TS_NULL_LITERAL_TYPE_ANNOTATION: \"TSNullKeyword\",\n  TS_OBJECT_KEYWORD: \"TSObjectKeyword\",\n  TS_TYPE_OPERATOR: \"TSTypeOperator\",\n  TS_GENERIC_TYPE_ANNOTATION: \"TSTypeReference\",\n  TS_OBJECT_TYPE_ANNOTATION: \"TSTypeLiteral\",\n  TS_UNION_TYPE_ANNOTATION: \"TSUnionType\",\n  TS_TUPLE_TYPE_ANNOTATION: \"TSTupleType\",\n  TS_TYPE_ANNOTATION: \"TSTypeAnnotation\",\n  TS_TYPE_REFERENCE_ANNOTATION: \"TSTypeReference\",\n  THIS_TYPE_ANNOTATION: \"ThisTypeAnnotation\",\n  TS_THIS_TYPE_ANNOTATION: \"TSThisType\",\n  TS_UNDEFINED_TYPE_ANNOTATION: \"TSUndefinedKeyword\",\n  TS_ARRAY_TYPE_ANNOTATION: \"TSArrayType\",\n  ARRAY_TYPE_ANNOTATION: \"ArrayTypeAnnotation\",\n  TS_INTERSECTION_TYPE: \"TSIntersectionType\",\n  TYPEOF_TYPE_ANNOTATION: \"TypeofTypeAnnotation\",\n  TYPE_CAST: \"TypeCastExpression\",\n  TYPE_GUARD: \"TSTypePredicate\"\n};\nconst INITIALIZATION_TYPES = exports.INITIALIZATION_TYPES = {\n  IDENTIFIER: \"Identifier\",\n  PROGRAM: \"Program\"\n};\nconst DECLARATION_KINDS = exports.DECLARATION_KINDS = {\n  VAR: \"var\",\n  CONST: \"const\",\n  LET: \"let\"\n};\nconst SPECIFIERS_TYPES = exports.SPECIFIERS_TYPES = {\n  IMPORT_DEFAULT_SPECIFIER: \"ImportDefaultSpecifier\",\n  IMPORT_NAMESPACE_SPECIFIER: \"ImportNamespaceSpecifier\",\n  IMPORT_SPECIFIER: \"ImportSpecifier\"\n};\nconst SPECIAL_TYPES = exports.SPECIAL_TYPES = {\n  THIS_TYPE_DEFINITION: \"ThisTypeDefinition\"\n};\n\nconst isUnscopableDeclaration = exports.isUnscopableDeclaration = ({\n  kind\n}) => kind === DECLARATION_KINDS.VAR;\n\nconst isObject = exports.isObject = node => node.type === OBJECT_PROPERTIES.OBJECT_EXPRESSION;\n\nconst isScopeCreator = exports.isScopeCreator = node => [INITIALIZATION_TYPES.PROGRAM, OBJECT_PROPERTIES.OBJECT_METHOD, CLASS_PROPERTIES.CLASS_METHOD, DECLARATION_TYPES.CLASS_DECLARATION, EXPRESSIONS_TYPES.CLASS_EXPRESSION, EXPRESSIONS_TYPES.OBJECT_EXPRESSION, STATEMENTS_TYPES.BLOCK_STATEMENT, EXPRESSIONS_TYPES.FUNCTION_EXPRESSION, DECLARATION_TYPES.FUNCTION_DECLARATION, ANNOTATION_TYPES.FUNCTION_TYPE_ANNOTATION, EXPRESSIONS_TYPES.ARROW_FUNCTION_EXPRESSION].includes(node.type);\n\nconst isFunction = exports.isFunction = node => [DECLARATION_TYPES.FUNCTION_DECLARATION, EXPRESSIONS_TYPES.FUNCTION_EXPRESSION, EXPRESSIONS_TYPES.ARROW_FUNCTION_EXPRESSION, ANNOTATION_TYPES.FUNCTION_TYPE_ANNOTATION, OBJECT_PROPERTIES.OBJECT_METHOD, CLASS_PROPERTIES.CLASS_METHOD].includes(node.type);\n\nconst isImport = exports.isImport = node => node.type === DECLARATION_TYPES.IMPORT_DECLARATION;\n\nexports.default = {\n  isImport,\n  isObject,\n  isFunction,\n  isScopeCreator,\n  isUnscopableDeclaration,\n  ...DECLARATION_TYPES,\n  ...STATEMENTS_TYPES,\n  ...ANNOTATION_TYPES,\n  ...EXPRESSIONS_TYPES,\n  ...INITIALIZATION_TYPES,\n  ...OBJECT_PROPERTIES,\n  ...CLASS_PROPERTIES,\n  ...LITERAL_TYPES,\n  ...SPECIFIERS_TYPES,\n  ...SPECIAL_TYPES\n};","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.genericFunction = undefined;\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _bottomType = require(\"../type-graph/types/bottom-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nconst zeroMetaLocation = new _meta.Meta();\n\nconst genericFunction = exports.genericFunction = (typeScope, getGenericArguments, getTypeParameters, getReturnType) => {\n  const localTypeScope = new _typeScope.TypeScope(typeScope);\n  let genericArguments = getGenericArguments(localTypeScope);\n  genericArguments.forEach(([key, type]) => localTypeScope.body.set(key, type));\n  genericArguments = genericArguments.map(([, t]) => Object.assign(t, {\n    isUserDefined: true\n  }));\n  const parametersTypes = getTypeParameters(localTypeScope);\n  const returnType = getReturnType(localTypeScope);\n  return _genericType.GenericType.term(_functionType.FunctionType.getName(parametersTypes, returnType, genericArguments), {\n    parent: typeScope\n  }, genericArguments, localTypeScope, _functionType.FunctionType.term(_functionType.FunctionType.getName(parametersTypes, returnType), {\n    parent: localTypeScope\n  }, parametersTypes, returnType));\n};\n\nconst mixBaseOperators = moduleScope => {\n  const typeScope = moduleScope.typeScope;\n  const operators = [[\"+\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {\n    parent: typeScope\n  }, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"-\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {\n    parent: typeScope\n  }, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"!\", _functionType.FunctionType.term(\"(boolean) => boolean\", {\n    parent: typeScope\n  }, [_type.Type.Boolean], _type.Type.Boolean)], [\"~\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {\n    parent: typeScope\n  }, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"typeof\", _functionType.FunctionType.term('(unknown) => \"string\" | \"boolean\" | \"number\" | \"function\" | \"object\" | \"undefined\" | \"symbol\" | \"bigint\"', {\n    parent: typeScope\n  }, [_type.Type.Unknown], _unionType.UnionType.term(\"'string' | 'boolean' | 'number' | 'function' | 'object' | 'undefined' | 'symbol' | 'bigint'\", {\n    parent: typeScope\n  }, [_type.Type.term(\"'string'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'number'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'boolean'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'undefined'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'object'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'bigint'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'symbol'\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.term(\"'function'\", {\n    isSubtypeOf: _type.Type.String\n  })]))], [\"void\", _functionType.FunctionType.term(\"(unknown) => undefined\", {\n    parent: typeScope\n  }, [_type.Type.Unknown], _type.Type.Undefined)], [\"delete\", _functionType.FunctionType.term(\"(unknown) => undefined\", {\n    parent: typeScope\n  }, [_type.Type.Unknown], _type.Type.Undefined)], typeScope.body.has(\"Promise\") ? [\"await\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [_unionType.UnionType.term(null, {}, [_type.Type.find(\"Promise\").applyGeneric([l.body.get(\"T\")]), l.body.get(\"T\")])], l => l.body.get(\"T\"))] : [\"await\", _functionType.FunctionType.term(\"(unknown) => unknown\", {\n    parent: typeScope\n  }, [_type.Type.Unknown], _type.Type.Unknown)], [\"==\", _functionType.FunctionType.term(\"(unknown, unknown) => boolean\", {\n    parent: typeScope\n  }, [_type.Type.Unknown, _type.Type.Unknown], _type.Type.Boolean)], [\"===\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => _type.Type.Boolean)], [\"!==\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => _type.Type.Boolean)], [\"!=\", _functionType.FunctionType.term(\"(unknown, unknown) => boolean\", {\n    parent: typeScope\n  }, [_type.Type.Unknown, _type.Type.Unknown], _type.Type.Boolean)], [\">=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], _ => _type.Type.Boolean)], [\"<=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], _ => _type.Type.Boolean)], [\">\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], _ => _type.Type.Boolean)], [\"<\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], _ => _type.Type.Boolean)], [\"b+\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number | string\", {}, [_type.Type.BigInt, _type.Type.Number, _type.Type.String]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"b-\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"/\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"%\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"|\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"&\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"*\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"^\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"**\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"<<\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\">>\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\">>>\", _functionType.FunctionType.term(\"(number, number) => number\", {\n    parent: typeScope\n  }, [_type.Type.Number, _type.Type.Number], _type.Type.Number)], [\"in\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _objectType.ObjectType.Object)]], l => [_type.Type.String, l.body.get(\"T\")], l => _type.Type.Boolean)], [\"instanceof\", _functionType.FunctionType.term(\"(unknown, unknown) => boolean\", {\n    parent: typeScope\n  }, [_type.Type.Unknown, _type.Type.Unknown], _type.Type.Boolean)], [\"=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"+=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number | string\", {}, [_type.Type.BigInt, _type.Type.Number, _type.Type.String]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"-=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"*=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"/=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"%=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"**=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\">>=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\">>>=\", _functionType.FunctionType.term(\"(number, number) => number\", {\n    parent: typeScope\n  }, [_type.Type.Number, _type.Type.Number], _type.Type.Number)], [\"<<=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"|=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"&=\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\"), l.body.get(\"T\")], l => l.body.get(\"T\"))], // Updates\n  [\"++\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"--\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  }, _unionType.UnionType.term(\"bigint | number\", {}, [_type.Type.BigInt, _type.Type.Number]))]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [// Logical\n  \"&&\", genericFunction(typeScope, parent => [[\"A\", _typeVar.TypeVar.term(\"A\", {\n    parent\n  })], [\"B\", _typeVar.TypeVar.term(\"B\", {\n    parent\n  })]], l => [l.body.get(\"A\"), l.body.get(\"B\")], l => _unionType.UnionType.term(\"A | B\", {\n    parent: l\n  }, [l.body.get(\"A\"), l.body.get(\"B\")]))], [\"||\", genericFunction(typeScope, parent => [[\"A\", _typeVar.TypeVar.term(\"A\", {\n    parent\n  })], [\"B\", _typeVar.TypeVar.term(\"B\", {\n    parent\n  })]], l => [l.body.get(\"A\"), l.body.get(\"B\")], l => _unionType.UnionType.term(\"A | B\", {\n    parent: l\n  }, [l.body.get(\"A\"), l.body.get(\"B\")]))], [\"?:\", genericFunction(typeScope, parent => [[\"A\", _typeVar.TypeVar.term(\"A\", {\n    parent\n  })], [\"B\", _typeVar.TypeVar.term(\"B\", {\n    parent\n  })]], l => [_type.Type.Boolean, l.body.get(\"A\"), l.body.get(\"B\")], l => _unionType.UnionType.term(\"A | B\", {\n    parent: l\n  }, [l.body.get(\"A\"), l.body.get(\"B\")]))], [\"if\", _functionType.FunctionType.term(\"(boolean) => void\", {\n    parent: typeScope\n  }, [_type.Type.Boolean], _type.Type.Undefined)], [\"while\", _functionType.FunctionType.term(\"(boolean) => void\", {\n    parent: typeScope\n  }, [_type.Type.Boolean], _type.Type.Undefined)], [\"do-while\", _functionType.FunctionType.term(\"(boolean) => void\", {\n    parent: typeScope\n  }, [_type.Type.Boolean], _type.Type.Undefined)], [\"for\", _functionType.FunctionType.term(\"(?unknown, ?boolean, ?unknown) => void\", {\n    parent: typeScope\n  }, [_unionType.UnionType.term(\"undefined | unknown\", {}, [_type.Type.Undefined, _type.Type.Unknown]), _unionType.UnionType.term(\"boolean | undefined\", {}, [_type.Type.Boolean, _type.Type.Undefined]), _unionType.UnionType.term(\"undefined | unknown\", {}, [_type.Type.Undefined, _type.Type.Unknown])], _type.Type.Undefined)], [\"return\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"new\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))], [\"throw\", genericFunction(typeScope, parent => [[\"T\", _typeVar.TypeVar.term(\"T\", {\n    parent\n  })]], l => [l.body.get(\"T\")], l => l.body.get(\"T\"))]].forEach(([name, type]) => moduleScope.body.set(name, new _variableInfo.VariableInfo(type, moduleScope, zeroMetaLocation)));\n};\n\nexports.default = mixBaseOperators;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getScopeType = getScopeType;\nexports.findNearestScopeByType = findNearestScopeByType;\nexports.findNearestTypeScope = findNearestTypeScope;\nexports.getParentForNode = getParentForNode;\nexports.getScopeFromNode = getScopeFromNode;\nexports.addScopeToTypeGraph = addScopeToTypeGraph;\n\nvar _nodes = require(\"../utils/nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getScopeType(node) {\n  switch (node.type) {\n    case _nodes2.default.BLOCK_STATEMENT:\n      return _variableScope.VariableScope.BLOCK_TYPE;\n\n    case _nodes2.default.FUNCTION_DECLARATION:\n    case _nodes2.default.FUNCTION_EXPRESSION:\n    case _nodes2.default.ARROW_FUNCTION_EXPRESSION:\n    case _nodes2.default.OBJECT_METHOD:\n    case _nodes2.default.CLASS_METHOD:\n    case _nodes2.default.FUNCTION_TYPE_ANNOTATION:\n      return _variableScope.VariableScope.FUNCTION_TYPE;\n\n    case _nodes2.default.OBJECT_EXPRESSION:\n      return _variableScope.VariableScope.OBJECT_TYPE;\n\n    case _nodes2.default.CLASS_DECLARATION:\n    case _nodes2.default.CLASS_EXPRESSION:\n      return _variableScope.VariableScope.CLASS_TYPE;\n  }\n\n  throw new Error(\"Never for getScopeType\");\n}\n\nfunction findNearestScopeByType(type, parentContext) {\n  type = Array.isArray(type) ? type : [type];\n  let parent = parentContext;\n\n  while (parent instanceof _variableScope.VariableScope) {\n    if (type.includes(parent.type)) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  }\n\n  return parent;\n}\n\nfunction findNearestTypeScope(currentScope, typeGraph) {\n  let scope = findNearestScopeByType([_variableScope.VariableScope.FUNCTION_TYPE, _variableScope.VariableScope.CLASS_TYPE], currentScope);\n\n  do {\n    if (scope.declaration instanceof _variableInfo.VariableInfo) {\n      if (\"localTypeScope\" in scope.declaration.type) {\n        // $FlowIssue\n        return scope.declaration.type.localTypeScope;\n      }\n\n      if (scope.declaration.type.instanceType != undefined && scope.declaration.type.instanceType.subordinateMagicType != undefined && \"localTypeScope\" in // $FlowIssue\n      scope.declaration.type.instanceType.subordinateMagicType) {\n        return (// $FlowIssue\n          scope.declaration.type.instanceType.subordinateMagicType.localTypeScope\n        );\n      }\n    }\n\n    const parent = scope.parent;\n\n    if (parent === null) {\n      break;\n    }\n\n    scope = findNearestScopeByType([_variableScope.VariableScope.FUNCTION_TYPE, _variableScope.VariableScope.CLASS_TYPE], parent);\n  } while (scope.parent instanceof _variableScope.VariableScope);\n\n  return typeGraph.typeScope;\n}\n\nfunction getParentForNode(currentNode, parentNode, typeGraph) {\n  if (!parentNode || parentNode.type === _nodes2.default.PROGRAM) {\n    return typeGraph;\n  }\n\n  const name = _variableScope.VariableScope.getName(parentNode);\n\n  const scope = typeGraph.scopes.get(name);\n\n  if (scope === undefined) {\n    return typeGraph;\n  }\n\n  if (_nodes2.default.isUnscopableDeclaration(currentNode)) {\n    return findNearestScopeByType(_variableScope.VariableScope.FUNCTION_TYPE, scope || typeGraph);\n  }\n\n  return scope;\n}\n\nfunction getScopeFromNode(currentNode, parentNode, typeGraph, declaration, scopeCreator) {\n  return new _variableScope.VariableScope(getScopeType(currentNode), parentNode instanceof _variableScope.VariableScope || parentNode instanceof _moduleScope.ModuleScope ? parentNode : getParentForNode(currentNode, parentNode, typeGraph), declaration, scopeCreator, currentNode.skipCalls !== undefined);\n}\n\nfunction addScopeToTypeGraph(currentNode, parentNode, typeGraph, creator) {\n  const scopeName = _variableScope.VariableScope.getName(currentNode);\n\n  if (typeGraph.scopes.has(scopeName)) {\n    return;\n  }\n\n  typeGraph.scopes.set(scopeName, getScopeFromNode(currentNode, parentNode, typeGraph, undefined, getScopeCreator(creator)));\n}\n\nfunction getScopeCreator(creator) {\n  switch (creator.type) {\n    case _nodes2.default.IF_STATEMENT:\n      return \"if\";\n\n    case _nodes2.default.WHILE_STATEMENT:\n      return \"while\";\n\n    case _nodes2.default.DO_WHILE_STATEMENT:\n      return \"do-while\";\n\n    case _nodes2.default.FOR_STATEMENT:\n      return \"for\";\n\n    case _nodes2.default.FOR_OF_STATEMENT:\n      return \"for-of\";\n\n    case _nodes2.default.FOR_IN_STATEMENT:\n      return \"for-in\";\n\n    case _nodes2.default.BLOCK_STATEMENT:\n      return \"block\";\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findThrowableBlock = findThrowableBlock;\nexports.addToThrowable = addToThrowable;\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nfunction findThrowableBlock(parentScope) {\n  if (!parentScope || !(parentScope instanceof _variableScope.VariableScope)) {\n    return null;\n  }\n\n  let parent = parentScope;\n\n  do {\n    if (parent.throwable) {\n      return parent;\n    }\n\n    parent = parent.parent;\n  } while (parent !== null);\n\n  return null;\n}\n\nfunction addToThrowable(throwType, currentScope) {\n  const throwableScope = findThrowableBlock(currentScope);\n\n  if (!throwableScope || !(currentScope instanceof _variableScope.VariableScope) || !throwableScope.throwable) {\n    return;\n  }\n\n  throwableScope.throwable.push(throwType);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compose = undefined;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _common = require(\"../utils/common\");\n\nvar _errors = require(\"./errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst compose = exports.compose = (...fns) => (...args) => {\n  const additionalArgs = args.slice(1);\n  return fns.reduce((res, fn) => fn(res, ...additionalArgs), args[0]);\n};\n\nfunction mixBodyToArrowFunctionExpression(currentNode) {\n  if (currentNode.type !== _nodes2.default.ARROW_FUNCTION_EXPRESSION || currentNode.body.type === _nodes2.default.BLOCK_STATEMENT) {\n    return currentNode;\n  }\n\n  currentNode.body = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: [{\n      type: _nodes2.default.RETURN_STATEMENT,\n      argument: currentNode.body,\n      loc: currentNode.body.loc\n    }],\n    loc: currentNode.body.loc\n  };\n  return currentNode;\n}\n\nfunction sortClassMembers(currentNode) {\n  if (currentNode.type !== _nodes2.default.CLASS_DECLARATION && currentNode.type !== _nodes2.default.CLASS_EXPRESSION) {\n    return currentNode;\n  }\n\n  currentNode.body.body.sort((a, b) => a.kind === \"constructor\" ? -1 : 1);\n  return currentNode;\n}\n\nfunction mixBlockToLogicalOperator(currentNode) {\n  if (currentNode.type !== _nodes2.default.LOGICAL_EXPRESSION || currentNode.operator !== \"&&\" && currentNode.operator !== \"||\" || currentNode.left.type === _nodes2.default.BLOCK_STATEMENT) {\n    return currentNode;\n  }\n\n  currentNode.left = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: currentNode.left,\n    loc: {\n      start: currentNode.loc.start,\n      end: currentNode.loc.start\n    }\n  };\n  currentNode.right = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: currentNode.right,\n    loc: {\n      start: currentNode.loc.end,\n      end: currentNode.loc.end\n    }\n  };\n  return currentNode;\n}\n\nfunction mixBlockToConditionalExpression(currentNode) {\n  if (currentNode.type !== _nodes2.default.CONDITIONAL_EXPRESSION || currentNode.consequent.type === _nodes2.default.BLOCK_STATEMENT) {\n    return currentNode;\n  }\n\n  currentNode.consequent = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: currentNode.consequent,\n    loc: {\n      start: currentNode.loc.start,\n      end: currentNode.loc.start\n    }\n  };\n  currentNode.alternate = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: currentNode.alternate,\n    loc: {\n      start: currentNode.loc.end,\n      end: currentNode.loc.end\n    }\n  };\n  return currentNode;\n}\n\nfunction mixBlockForStatements(currentNode) {\n  if (currentNode.type !== _nodes2.default.IF_STATEMENT && currentNode.type !== _nodes2.default.WHILE_STATEMENT && currentNode.type !== _nodes2.default.FOR_STATEMENT && currentNode.type !== _nodes2.default.FOR_IN_STATEMENT && currentNode.type !== _nodes2.default.FOR_OF_STATEMENT) {\n    return currentNode;\n  }\n\n  if (currentNode.type === _nodes2.default.IF_STATEMENT && currentNode.alternate && currentNode.alternate.type !== _nodes2.default.BLOCK_STATEMENT) {\n    currentNode.alternate = {\n      type: _nodes2.default.BLOCK_STATEMENT,\n      body: [currentNode.alternate],\n      loc: currentNode.alternate.loc\n    };\n  }\n\n  const propertyName = currentNode.type === _nodes2.default.IF_STATEMENT ? \"consequent\" : \"body\";\n\n  if (currentNode[propertyName].type === _nodes2.default.BLOCK_STATEMENT) {\n    return currentNode;\n  }\n\n  currentNode[propertyName] = {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: [currentNode[propertyName]],\n    loc: currentNode[propertyName].loc\n  };\n  return currentNode;\n}\n\nfunction getInitFor(node) {\n  switch (node.type) {\n    case _nodes2.default.FOR_IN_STATEMENT:\n      return {\n        type: _nodes2.default.PURE_KEY,\n        of: node.right\n      };\n\n    case _nodes2.default.FOR_OF_STATEMENT:\n      return {\n        type: _nodes2.default.VALUE,\n        of: node.right\n      };\n\n    default:\n      return;\n  }\n}\n\nfunction mixBlockToCaseStatement(currentNode) {\n  if (currentNode.type !== _nodes2.default.SWITCH_STATEMENT) {\n    return currentNode;\n  }\n\n  for (let i = 0; i < currentNode.cases.length; i++) {\n    const $case = currentNode.cases[i];\n    const body = $case.consequent.body || $case.consequent;\n    $case.parent = currentNode;\n    $case.consequent = {\n      type: _nodes2.default.BLOCK_STATEMENT,\n      loc: $case.loc,\n      body\n    };\n  }\n\n  return currentNode;\n}\n\nfunction mixDeclarationsInideForBlock(currentNode, parentNode) {\n  if (currentNode.type !== _nodes2.default.FOR_IN_STATEMENT && currentNode.type !== _nodes2.default.FOR_OF_STATEMENT && (currentNode.type !== _nodes2.default.FOR_STATEMENT || currentNode.init === null) || parentNode.isCustom) {\n    return currentNode;\n  }\n\n  const init = currentNode.init || { ...currentNode.left,\n    init: getInitFor(currentNode)\n  };\n  return {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    body: [init, currentNode],\n    isCustom: true,\n    loc: init.loc\n  };\n}\n\nfunction mixExportInfo(currentNode) {\n  if (currentNode.type !== _nodes2.default.EXPORT_NAMED_DECLARATION && currentNode.type !== _nodes2.default.EXPORT_DEFAULT_DECLARATION) {\n    return currentNode;\n  }\n\n  if (currentNode.declaration == null) {\n    return {\n      type: _nodes2.default.EXPORT_LIST,\n      exportKind: currentNode.exportKind,\n      specifiers: currentNode.specifiers\n    };\n  }\n\n  return currentNode.declaration.type !== _nodes2.default.VARIABLE_DECLARATION ? { ...currentNode.declaration,\n    exportAs: currentNode.type === _nodes2.default.EXPORT_DEFAULT_DECLARATION ? \"default\" : currentNode.declaration.id.name\n  } : { ...currentNode.declaration,\n    declarations: currentNode.declaration.declarations.map(declaration => ({ ...declaration,\n      exportAs: declaration.id.name\n    }))\n  };\n}\n\nfunction mixTryCatchInfo(currentNode) {\n  if (currentNode.type !== _nodes2.default.TRY_STATEMENT) {\n    return currentNode;\n  }\n\n  return { ...currentNode,\n    block: { ...currentNode.block,\n      catchBlock: currentNode.handler\n    }\n  };\n}\n\nfunction mixParentToClassObjectAndFunction(currentNode, parentNode) {\n  if (typeof currentNode === \"object\" && currentNode !== null && (currentNode.type === _nodes2.default.CLASS_DECLARATION || currentNode.type === _nodes2.default.FUNCTION_DECLARATION)) {\n    currentNode.parentNode = parentNode;\n  }\n\n  return currentNode;\n}\n\nfunction removeNodesWhichConteindInElse(alternateBody, inferencedBody) {\n  for (let i = 0; i < inferencedBody.length; i++) {\n    if (alternateBody.includes(inferencedBody[i])) {\n      inferencedBody[i] = undefined;\n    }\n  }\n}\n\nfunction mixElseIfReturnOrThrowExisted(currentNode, parentNode, {\n  previousBodyState = []\n}) {\n  if (parentNode === undefined || currentNode.type !== _nodes2.default.IF_STATEMENT || currentNode.consequent.body.findIndex(node => node.type === _nodes2.default.RETURN_STATEMENT || node.type === _nodes2.default.BREAK_STATEMENT || node.type === _nodes2.default.CONTINUE_STATEMENT || node.type === _nodes2.default.THROW_STATEMENT) === -1) {\n    return currentNode;\n  }\n\n  const body = parentNode.body.body || parentNode.body;\n\n  if (!Array.isArray(body)) {\n    return currentNode;\n  }\n\n  const indexOfSlice = body.indexOf(currentNode);\n\n  if (indexOfSlice === -1) {\n    return currentNode;\n  }\n\n  const alternate = currentNode.alternate || {\n    type: _nodes2.default.BLOCK_STATEMENT,\n    skipCalls: true,\n    body: [],\n    loc: {\n      start: currentNode.loc.end,\n      end: currentNode.loc.end\n    }\n  };\n  const inferencedAlternate = body.splice(indexOfSlice + 1);\n  alternate.body = alternate.body.concat(inferencedAlternate);\n  removeNodesWhichConteindInElse(inferencedAlternate, previousBodyState);\n  return { ...currentNode,\n    alternate\n  };\n}\n\nconst getBody = currentNode => [...(0, _common.ensureArray)(currentNode.body), ...(0, _common.ensureArray)(currentNode.declarations), ...(0, _common.ensureArray)(currentNode.properties), currentNode.block, currentNode.handler, currentNode.test, currentNode.finalizer, currentNode.alternate, currentNode.value, currentNode.init && currentNode.init.callee, currentNode.init, currentNode.object, currentNode.property, currentNode.left, currentNode.right, currentNode.argument, currentNode.expression && currentNode.expression.callee, currentNode.expression, currentNode.callee, ...(0, _common.ensureArray)(currentNode.elements), ...(0, _common.ensureArray)(currentNode.cases), ...(0, _common.ensureArray)(currentNode.expressions), ...(0, _common.ensureArray)(currentNode.arguments).filter(a => !_nodes2.default.isFunction(a)), ...(0, _common.ensureArray)(currentNode.consequent)].filter(Boolean);\n\nconst getNextParent = (currentNode, parentNode) => parentNode && (_nodes2.default.isFunction(parentNode) && currentNode === parentNode.body || _nodes2.default.isScopeCreator(parentNode) && !_nodes2.default.isScopeCreator(currentNode)) ? parentNode : currentNode;\n\nconst getCurrentNode = compose(mixDeclarationsInideForBlock, mixBodyToArrowFunctionExpression, mixTryCatchInfo, mixBlockForStatements, mixExportInfo, mixBlockToLogicalOperator, mixElseIfReturnOrThrowExisted, mixBlockToConditionalExpression, mixBlockToCaseStatement, mixParentToClassObjectAndFunction, sortClassMembers);\n\nfunction traverseTree(node, pre, middle, post, parentNode = null, meta = {}) {\n  const currentNode = getCurrentNode(node, parentNode, meta);\n  const shouldContinueTraversing = pre(currentNode, parentNode, pre, middle, post, meta);\n\n  if (!shouldContinueTraversing) {\n    return;\n  }\n\n  const body = getBody(currentNode);\n  const nextParent = getNextParent(currentNode, parentNode);\n  let i = 0;\n  const newMeta = { ...meta,\n    previousBodyState: body,\n    kind: currentNode.kind\n  };\n\n  try {\n    for (i = 0; i < body.length; i++) {\n      const node = body[i];\n\n      if (node !== undefined) {\n        middle(node, nextParent, pre, middle, post, newMeta);\n      }\n    }\n\n    for (i = 0; i < body.length; i++) {\n      const node = body[i];\n\n      if (node !== undefined) {\n        traverseTree(node, pre, middle, post, nextParent, newMeta);\n      }\n    }\n  } catch (e) {\n    if (!(e instanceof _errors.UnreachableError)) {\n      throw e;\n    }\n\n    if (i < body.length - 1) {\n      throw new _errors2.default(\"Unreachable code after this line\", e.loc);\n    }\n  }\n\n  post(currentNode, parentNode, pre, middle, post, newMeta);\n}\n\nexports.default = traverseTree;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addTypeNodeToTypeGraph = addTypeNodeToTypeGraph;\nexports.isReachableType = isReachableType;\nexports.addTypeVar = addTypeVar;\nexports.getTypeFromTypeAnnotation = getTypeFromTypeAnnotation;\nexports.mergeObjectsTypes = mergeObjectsTypes;\nexports.createObjectWith = createObjectWith;\nexports.get = get;\nexports.createSelf = createSelf;\nexports.getWrapperType = getWrapperType;\nexports.getFalsy = getFalsy;\nexports.pickFalsy = pickFalsy;\nexports.pickTruthy = pickTruthy;\nexports.isFalsy = isFalsy;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _errors = require(\"./errors\");\n\nvar _errors2 = _interopRequireDefault(_errors);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _typeVar = require(\"../type-graph/types/type-var\");\n\nvar _typeScope = require(\"../type-graph/type-scope\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _bottomType = require(\"../type-graph/types/bottom-type\");\n\nvar _genericType = require(\"../type-graph/types/generic-type\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _throwsType = require(\"../type-graph/types/throws-type\");\n\nvar _variableScope = require(\"../type-graph/variable-scope\");\n\nvar _intersectionType = require(\"../type-graph/types/intersection-type\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _common = require(\"./common\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction addTypeNodeToTypeGraph(currentNode, typeGraph) {\n  const name = (0, _common.getDeclarationName)(currentNode);\n  typeGraph.typeScope.body.set(name, currentNode);\n}\n\nfunction isReachableType(type, typeScope) {\n  if (typeScope === null) {\n    return false;\n  }\n\n  let reachableType = null;\n\n  try {\n    reachableType = _type.Type.find(type.name, {\n      parent: typeScope\n    });\n  } catch {}\n\n  return reachableType !== null && type.equalsTo(reachableType);\n}\n\nfunction addTypeVar(name, localTypeScope, constraint, defaultType, isUserDefined = false) {\n  return _typeVar.TypeVar.new(name, {\n    parent: localTypeScope\n  }, constraint, defaultType, isUserDefined);\n}\n\nfunction nullable(annotation) {\n  return annotation.optional ? {\n    typeAnnotation: { ...annotation.typeAnnotation,\n      type: _nodes2.default.NULLABLE_TYPE_ANNOTATION\n    }\n  } : annotation.typeAnnotation;\n}\n\nfunction getTypeFromTypeAnnotation(typeNode, typeScope, currentScope, rewritable = true, self = null, parentNode, typeGraph, precompute, middlecompute, postcompute, customName) {\n  if (!typeNode || !typeNode.typeAnnotation) {\n    return _type.Type.Unknown;\n  }\n\n  if (typeNode.typeAnnotation.type === _nodes2.default.TS_PARENTHESIZED_TYPE) {\n    typeNode.typeAnnotation = typeNode.typeAnnotation.typeAnnotation;\n  }\n\n  switch (typeNode.typeAnnotation.type) {\n    case _nodes2.default.ARRAY_TYPE_ANNOTATION:\n      const elementType = getTypeFromTypeAnnotation({\n        typeAnnotation: typeNode.typeAnnotation.elementType\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      throw new _errors2.default(`Array type annotation does not exist in Hegel. Use Array<${String(elementType.name)}> instead.`, typeNode.typeAnnotation.loc);\n\n    case _nodes2.default.THIS_TYPE_ANNOTATION:\n    case _nodes2.default.TS_THIS_TYPE_ANNOTATION:\n      if (self === null || self === undefined) {\n        throw new _errors2.default(\"Can not use `this` type without context\", typeNode.loc);\n      }\n\n      return self;\n\n    case _nodes2.default.TS_TYPE_OPERATOR:\n      const res = getTypeFromTypeAnnotation({\n        typeAnnotation: typeNode.typeAnnotation.typeAnnotation\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      return typeNode.typeAnnotation.operator === \"readonly\" ? _type.Type.find(_immutableType.$Immutable.name).applyGeneric([res], typeNode.typeAnnotation.loc) : res;\n\n    case _nodes2.default.TS_LITERAL_TYPE:\n      return getTypeFromTypeAnnotation({\n        typeAnnotation: typeNode.typeAnnotation.literal\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n    case _nodes2.default.ANY_TYPE_ANNOTATION:\n      throw new _errors2.default('There is no \"any\" type in Hegel. Use \"unknown\" instead.', typeNode.typeAnnotation.loc);\n\n    case _nodes2.default.VOID_TYPE_ANNOTATION:\n      throw new _errors2.default('There is no \"void\" type in Hegel. Use \"undefined\" instead.', typeNode.typeAnnotation.loc);\n\n    case _nodes2.default.TYPEOF_TYPE_ANNOTATION:\n      throw new _errors2.default(\"typeof for types does not exist in Hegel. Use magic type $TypeOf instead.\", typeNode.typeAnnotation.loc);\n\n    case _nodes2.default.SYMBOL_TYPE_ANNOTATION:\n    case _nodes2.default.TS_SYMBOL_TYPE_ANNOTATION:\n      return _type.Type.Symbol;\n\n    case _nodes2.default.TS_BIGINT_TYPE_ANNOTATION:\n      return _type.Type.BigInt;\n\n    case _nodes2.default.TS_UNDEFINED_TYPE_ANNOTATION:\n      return _type.Type.Undefined;\n\n    case _nodes2.default.TS_OBJECT_KEYWORD:\n      return _objectType.ObjectType.Object;\n\n    case _nodes2.default.VOID_TYPE_ANNOTATION:\n    case _nodes2.default.TS_VOID_TYPE_ANNOTATION:\n      return _type.Type.Undefined;\n\n    case _nodes2.default.TYPE_GUARD:\n    case _nodes2.default.BOOLEAN_TYPE_ANNOTATION:\n    case _nodes2.default.TS_BOOLEAN_TYPE_ANNOTATION:\n      return _unionType.UnionType.Boolean;\n\n    case _nodes2.default.TS_ANY_TYPE_ANNOTATION:\n    case _nodes2.default.MIXED_TYPE_ANNOTATION:\n    case _nodes2.default.TS_UNKNOWN_TYPE_ANNOTATION:\n    case _nodes2.default.TS_ANY_TYPE_ANNOTATION:\n      return _type.Type.Unknown;\n\n    case _nodes2.default.EMPTY_TYPE_ANNOTATION:\n    case _nodes2.default.TS_NEVER_TYPE_ANNOTATION:\n      return _type.Type.Never;\n\n    case _nodes2.default.NUMBER_TYPE_ANNOTATION:\n    case _nodes2.default.TS_NUMBER_TYPE_ANNOTATION:\n      return _type.Type.Number;\n\n    case _nodes2.default.STRING_TYPE_ANNOTATION:\n    case _nodes2.default.TS_STRING_TYPE_ANNOTATION:\n      return _type.Type.String;\n\n    case _nodes2.default.NULL_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.TS_NULL_LITERAL_TYPE_ANNOTATION:\n      return _type.Type.Null;\n\n    case _nodes2.default.NUMBER_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.NUMERIC_LITERAL:\n      return _type.Type.term(typeNode.typeAnnotation.value, {\n        isSubtypeOf: _type.Type.Number\n      });\n\n    case _nodes2.default.BIGINT_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.BIGINT_LITERAL:\n      return _type.Type.term(typeNode.typeAnnotation.value, {\n        isSubtypeOf: _type.Type.BigInt\n      });\n\n    case _nodes2.default.BOOLEAN_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.BOOLEAN_LITERAL:\n      return _type.Type.term(typeNode.typeAnnotation.value);\n\n    case _nodes2.default.STRING_LITERAL_TYPE_ANNOTATION:\n    case _nodes2.default.STRING_LITERAL:\n      return _type.Type.term(`'${typeNode.typeAnnotation.value}'`, {\n        isSubtypeOf: _type.Type.String\n      });\n\n    case _nodes2.default.TS_SYMBOL_TYPE_ANNOTATION:\n      return _type.Type.Symbol;\n\n    case _nodes2.default.TS_INTERSECTION_TYPE:\n      const objects = typeNode.typeAnnotation.types.map(typeAnnotation => getTypeFromTypeAnnotation({\n        typeAnnotation\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n      return _type.Type.find(_intersectionType.$Intersection.name).applyGeneric(objects, typeNode.loc);\n\n    case _nodes2.default.NULLABLE_TYPE_ANNOTATION:\n      const resultType = getTypeFromTypeAnnotation(typeNode.typeAnnotation, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      return _unionType.UnionType.term(null, {}, [resultType, _type.Type.Undefined]);\n\n    case _nodes2.default.TS_OBJECT_PROPERTY:\n      const result = getTypeFromTypeAnnotation( // Ohhh, TS is beautiful \n      nullable(typeNode.typeAnnotation), typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      return typeNode.typeAnnotation.readonly ? _type.Type.find(_immutableType.$Immutable.name).applyGeneric([result], typeNode.typeAnnotation.loc) : result;\n\n    case _nodes2.default.UNION_TYPE_ANNOTATION:\n    case _nodes2.default.TS_UNION_TYPE_ANNOTATION:\n      const unionVariants = typeNode.typeAnnotation.types.map(typeAnnotation => getTypeFromTypeAnnotation({\n        typeAnnotation\n      }, typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n      return _unionType.UnionType.term(null, {}, unionVariants);\n\n    case _nodes2.default.TUPLE_TYPE_ANNOTATION:\n    case _nodes2.default.TS_TUPLE_TYPE_ANNOTATION:\n      const tupleVariants = (typeNode.typeAnnotation.types || typeNode.typeAnnotation.elementTypes).map(typeAnnotation => getTypeFromTypeAnnotation({\n        typeAnnotation\n      }, typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n      return _tupleType.TupleType.term(_tupleType.TupleType.getName(tupleVariants), {}, tupleVariants);\n\n    case _nodes2.default.TYPE_PARAMETER:\n    case _nodes2.default.TS_TYPE_PARAMETER:\n      const constraint = typeNode.typeAnnotation.bound && getTypeFromTypeAnnotation(typeNode.typeAnnotation.bound, typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      const defaultType = typeNode.typeAnnotation.default && getTypeFromTypeAnnotation({\n        typeAnnotation: typeNode.typeAnnotation.default\n      }, typeScope, currentScope, false, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n      if (constraint && defaultType && !constraint.isPrincipalTypeFor(defaultType)) {\n        throw new _errors2.default(`Type \"${String(defaultType.name)}\" is incompatible with type \"${String(constraint.name)}\"`, typeNode.typeAnnotation.default.loc);\n      }\n\n      return addTypeVar(typeNode.typeAnnotation.name, typeScope, constraint, defaultType, true);\n\n    case _nodes2.default.TS_INDEX_PROPERTY:\n      const key = getTypeFromTypeAnnotation(typeNode.typeAnnotation.parameters[0].typeAnnotation, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      const value = getTypeFromTypeAnnotation( // Ohhh, TS is beautiful \n      typeNode.typeAnnotation.typeAnnotation, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n      return new _collectionType.CollectionType(\"\", {\n        parent: key.parent.priority > value.parent.priority ? key.parent : value.parent\n      }, key, value);\n\n    case _nodes2.default.OBJECT_TYPE_ANNOTATION:\n      if (typeNode.typeAnnotation.exact) {\n        throw new _errors2.default(\"Hegel has another syntax for strict (exact) object type. You should use pure object literal type for strict (exact)\\\n         object and object liter with three dots (...) for soft (inexact) object type\", typeNode.typeAnnotation.loc);\n      }\n\n    case _nodes2.default.TS_OBJECT_TYPE_ANNOTATION:\n    case _nodes2.default.TS_INTERFACE_DECLARATION:\n      const {\n        typeAnnotation: annotation\n      } = typeNode;\n      const objectBody = annotation.body || annotation;\n      const isSoft = annotation.type === _nodes2.default.TS_INTERFACE_DECLARATION || annotation.inexact;\n      const properties = objectBody.properties || objectBody.body || objectBody.members;\n      const superTypes = (annotation.extends || []).map(node => getTypeFromTypeAnnotation({\n        typeAnnotation: node\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n      const isNotTypeDefinition = annotation.type === _nodes2.default.OBJECT_TYPE_ANNOTATION;\n      const params = properties.flatMap(property => {\n        if (property.type === _nodes2.default.OBJECT_TYPE_SPREAD_PROPERTY) {\n          const spreadType = getTypeFromTypeAnnotation({\n            typeAnnotation: property.argument\n          }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n          if (!(spreadType instanceof _objectType.ObjectType)) {\n            throw new _errors2.default(\"Cannot spread non-object type\", property.loc);\n          }\n\n          return [...spreadType.properties];\n        }\n\n        if (isNotTypeDefinition && property.optional) {\n          throw new _errors2.default(\"Hegel has not optional property syntax. Use optional type instead.\", property.loc);\n        }\n\n        return [[getPropertyName(property), getTypeFromTypeAnnotation({\n          typeAnnotation: property.value || property\n        }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute)]];\n      });\n\n      if (customName === undefined) {\n        customName = annotation.id != undefined ? annotation.id.name : _objectType.ObjectType.getName(params, undefined, isSoft);\n      }\n\n      const resultObj = _objectType.ObjectType.term(customName, {\n        isSoft\n      }, params.map(([name, type]) => [name, type instanceof _variableInfo.VariableInfo ? type : new _variableInfo.VariableInfo(type, currentScope)]).concat(superTypes.reduce((res, type, index) => res.concat([...getPropertiesForType(type, annotation.extends[index])]), [])));\n\n      const constructor = resultObj.properties.get(_constants.CONSTRUCTABLE);\n\n      if (constructor !== undefined) {\n        const constructorType = constructor.type instanceof _genericType.GenericType ? constructor.type.subordinateType : constructor.type;\n        resultObj.instanceType = constructorType.returnType;\n      }\n\n      return getResultObjectType(resultObj);\n\n    case _nodes2.default.TS_ARRAY_TYPE_ANNOTATION:\n      return getTypeFromTypeAnnotation({\n        typeAnnotation: {\n          type: _nodes2.default.TS_TYPE_REFERENCE_ANNOTATION,\n          id: {\n            name: \"Array\"\n          },\n          typeParameters: {\n            params: [typeNode.typeAnnotation.elementType]\n          }\n        }\n      }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n    case _nodes2.default.TS_TYPE_QUERY:\n      typeNode.typeAnnotation = {\n        loc: typeNode.typeAnnotation.loc,\n        type: _nodes2.default.GENERIC_TYPE_ANNOTATION,\n        id: {\n          name: \"$TypeOf\"\n        },\n        typeParameters: {\n          params: [{\n            id: typeNode.typeAnnotation.exprName\n          }]\n        }\n      };\n\n    case _nodes2.default.GENERIC_TYPE_ANNOTATION:\n    case _nodes2.default.CLASS_IMPLEMENTS:\n    case _nodes2.default.TS_TYPE_REFERENCE_ANNOTATION:\n    case _nodes2.default.TS_EXPRESSION_WITH_TYPE_ARGUMENTS:\n      const target = typeNode.typeAnnotation || typeNode;\n      const genericArguments = target.typeParameters && target.typeParameters.params;\n      const genericId = target.id || target.typeName || target.expression;\n      const genericName = genericId.name;\n\n      if (genericArguments != undefined) {\n        const typeInScope = _type.Type.find(genericName, {\n          parent: typeScope,\n          loc: target.loc\n        }, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n        const existedGenericType = typeInScope instanceof _typeVar.TypeVar && typeInScope.root != undefined ? typeInScope.root : typeInScope;\n\n        if (!existedGenericType || !(existedGenericType instanceof _genericType.GenericType) && !_typeVar.TypeVar.isSelf(existedGenericType)) {\n          throw new _errors2.default(`Apply undeclareted generic type '${genericName}'`, typeNode.typeAnnotation.loc);\n        }\n\n        if (existedGenericType.name === \"$TypeOf\") {\n          if (genericArguments.length !== 1 || genericArguments[0].id == undefined || genericArguments[0].id.type !== _nodes2.default.IDENTIFIER) {\n            throw new _errors2.default(`\"${existedGenericType.name}\" work only with identifier`, typeNode.typeAnnotation.loc);\n          }\n\n          return existedGenericType.applyGeneric( // $FlowIssue\n          [currentScope.findVariable(genericArguments[0].id)], typeNode.typeAnnotation.loc, false);\n        }\n\n        const genericParams = genericArguments.map(arg => getTypeFromTypeAnnotation({\n          typeAnnotation: arg\n        }, typeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute));\n        return genericParams.some(t => t instanceof _typeVar.TypeVar && t !== self) || _typeVar.TypeVar.isSelf(existedGenericType) ? new _bottomType.$BottomType({\n          parent: existedGenericType.parent\n        }, existedGenericType, genericParams, typeNode.typeAnnotation.loc) : // $FlowIssue\n        existedGenericType.applyGeneric(genericParams, typeNode.typeAnnotation.loc);\n      }\n\n      if (!rewritable) {\n        const typeInScope = _type.Type.find(genericName, {\n          parent: typeScope,\n          loc: target.loc\n        }, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n        if (typeInScope.shouldBeUsedAsGeneric) {\n          throw new _errors2.default(`Generic type \"${String(typeInScope.name)}\" should be used with type paramteres!`, target.loc);\n        }\n\n        return typeInScope instanceof _typeVar.TypeVar && typeInScope.root != undefined ? typeInScope.root : typeInScope;\n      }\n\n      const typeInScope = _type.Type.find(genericName, {\n        parent: typeScope,\n        loc: target.loc\n      });\n\n      if (typeInScope.shouldBeUsedAsGeneric) {\n        throw new _errors2.default(`Generic type \"${String(typeInScope.name)}\" should be used with type paramteres!`, target.loc);\n      }\n\n      const applicationResultType = _type.Type.getTypeRoot(typeInScope);\n\n      if (typeGraph instanceof _moduleScope.PositionedModuleScope) {\n        typeGraph.addPosition(genericId, applicationResultType);\n      }\n\n      return applicationResultType;\n\n    case _nodes2.default.TS_OBJECT_METHOD:\n    case _nodes2.default.FUNCTION_TYPE_ANNOTATION:\n    case _nodes2.default.TS_CALL_SIGNATURE_DECLARATION:\n    case _nodes2.default.TS_CONSTRUCT_SIGNATURE_DECLARATION:\n    case _nodes2.default.TS_FUNCTION_TYPE_ANNOTATION:\n      const localTypeScope = new _typeScope.TypeScope(typeScope);\n      const genericParams = typeNode.typeAnnotation.typeParameters ? typeNode.typeAnnotation.typeParameters.params.map(param => getTypeFromTypeAnnotation({\n        typeAnnotation: param\n      }, localTypeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute)) : [];\n      const {\n        params: paramsNode,\n        parameters,\n        rest\n      } = typeNode.typeAnnotation;\n      const argNodes = [...(paramsNode || parameters), rest && { ...rest,\n        type: _nodes2.default.REST_ELEMENT\n      }];\n      const args = argNodes.reduce((res, annotation) => {\n        if (annotation == undefined) {\n          return res;\n        }\n\n        const result = getTypeFromTypeAnnotation( // Ohhh, TS is beautiful \n        annotation.typeAnnotation.type === _nodes2.default.TS_TYPE_ANNOTATION ? nullable(annotation) : annotation, localTypeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n        return [...res, annotation.type === _nodes2.default.REST_ELEMENT ? _functionType.RestArgument.term(null, {}, result) : result];\n      }, []);\n      const {\n        returnType: returnTypeNode\n      } = typeNode.typeAnnotation;\n      let throwableType;\n      let returnType = getTypeFromTypeAnnotation(returnTypeNode ? {\n        typeAnnotation: returnTypeNode\n      } : // Ohhh, TS is beautiful \n      typeNode.typeAnnotation.typeAnnotation, localTypeScope, currentScope, rewritable, self, parentNode, typeGraph, precompute, middlecompute, postcompute);\n\n      if (returnType instanceof _throwsType.$ThrowsResult || returnType instanceof _unionType.UnionType) {\n        if (returnType instanceof _unionType.UnionType) {\n          const [returnTypes, errors] = returnType.variants.reduce(([result, errors], type) => type instanceof _throwsType.$ThrowsResult ? [result, [...errors, type.errorType]] : [[...result, type], errors], [[], []]);\n\n          if (errors.length !== 0) {\n            returnType = _unionType.UnionType.term(null, {}, returnTypes);\n            throwableType = new _throwsType.$ThrowsResult(null, {}, _unionType.UnionType.term(null, {}, errors));\n          }\n        } else {\n          throwableType = returnType;\n          returnType = _type.Type.Undefined;\n        }\n      }\n\n      const typeName = _functionType.FunctionType.getName(args, returnType, genericParams, false, throwableType && throwableType.errorType);\n\n      const type = _functionType.FunctionType.term(typeName, {}, args, returnType);\n\n      type.throwable = throwableType && throwableType.errorType;\n\n      if (genericParams.length === 0 || !(type instanceof _functionType.FunctionType)) {\n        return type;\n      }\n\n      return _genericType.GenericType.new(typeName, {}, genericParams, localTypeScope, type);\n  }\n\n  return _type.Type.Unknown;\n}\n\nfunction mergeObjectsTypes(obj1 = _objectType.ObjectType.term(\"{ }\", {}, []), obj2 = _objectType.ObjectType.term(\"{ }\", {}, []), typeScope) {\n  if (obj1 instanceof _typeVar.TypeVar) {\n    return obj1;\n  }\n\n  if (obj2 instanceof _typeVar.TypeVar) {\n    return obj2;\n  }\n\n  return _objectType.ObjectType.term(null, {\n    isSoft: !obj1.isStrict\n  }, [...obj1.properties.entries(), ...obj2.properties.entries()]);\n}\n\nfunction createObjectWith(key, type, typeScope, meta) {\n  const properties = [[key, new _variableInfo.VariableInfo(type, new _variableScope.VariableScope(_variableScope.VariableScope.OBJECT_TYPE, new _moduleScope.ModuleScope(\"Hegel works wrong if you see this path. Please send us an issue.\")), meta)]];\n  return _objectType.ObjectType.term(_objectType.ObjectType.getName(properties), {}, properties);\n}\n\nfunction get(variable, propertyChaining, memberExpressionLoc) {\n  if (!propertyChaining) {\n    return;\n  }\n\n  return propertyChaining.reduce((type, propertyName) => {\n    if (!(type instanceof _objectType.ObjectType)) {\n      return;\n    }\n\n    const property = type.properties.get(propertyName);\n\n    if (property === undefined) {\n      return;\n    }\n\n    return property.type;\n  }, variable.type);\n}\n\nfunction createSelf(node, parent) {\n  return _typeVar.TypeVar.new(node.id.name, {\n    isSubtypeOf: _typeVar.TypeVar.Self,\n    parent\n  }, undefined, undefined, true);\n}\n\nfunction getPropertyName(property) {\n  if (property.key !== undefined) {\n    return property.key.name;\n  }\n\n  switch (property.type) {\n    case _nodes2.default.TS_CALL_SIGNATURE_DECLARATION:\n      return _constants.CALLABLE;\n\n    case _nodes2.default.TS_CONSTRUCT_SIGNATURE_DECLARATION:\n      return _constants.CONSTRUCTABLE;\n\n    case _nodes2.default.TS_INDEX_PROPERTY:\n      return _constants.INDEXABLE;\n  }\n\n  throw new Error(\"Never\");\n}\n\nfunction getResultObjectType(object) {\n  const indexable = object.properties.get(_constants.INDEXABLE);\n\n  if (indexable !== undefined) {\n    object.properties.delete(_constants.INDEXABLE);\n    indexable.type.isSubtypeOf = object;\n    indexable.type.name = object.name;\n    object.parent.body.set(object.name, indexable.type);\n    object.name = `${String(object.name)}.prototype`;\n    object.parent.body.set(object.name, object);\n    return indexable.type;\n  }\n\n  return object;\n}\n\nfunction getPropertiesForType(type, node) {\n  switch (type && type.constructor) {\n    case _objectType.ObjectType:\n      // $FlowIssue\n      return type.properties;\n\n    case _bottomType.$BottomType:\n      // $FlowIssue\n      return getPropertiesForType(type.unpack(), node);\n\n    case _functionType.FunctionType:\n    case _collectionType.CollectionType:\n      // $FlowIssue\n      return getPropertiesForType(type.isSubtypeOf, node);\n\n    case _genericType.GenericType:\n      throw new _errors2.default(\"Generic type should be applied before usage\", node.loc);\n\n    case _type.Type:\n      throw new _errors2.default(\"Type can not be extended by simple type\", node.loc);\n\n    default:\n      throw new _errors2.default(`Can not be extended by ${String(type && type.name)}`, node.loc);\n  }\n}\n\nfunction getWrapperType(argument, typeGraph) {\n  let type = argument instanceof _variableInfo.VariableInfo ? argument.type : argument;\n  type = type instanceof _immutableType.$AppliedImmutable ? type.readonly : type;\n\n  if (type instanceof _unionType.UnionType) {\n    const variants = type.variants.map(t => getWrapperType(t, typeGraph));\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n  return type.getWrapperType() || argument;\n}\n\nfunction getFalsy() {\n  return [_type.Type.False, _type.Type.term(0, {\n    isSubtypeOf: _type.Type.Number\n  }), _type.Type.term(\"0n\", {\n    isSubtypeOf: _type.Type.BigInt\n  }), _type.Type.term(\"''\", {\n    isSubtypeOf: _type.Type.String\n  }), _type.Type.Null, _type.Type.Undefined];\n}\n\nfunction pickFalsy(type) {\n  if (type instanceof _unionType.UnionType) {\n    const variants = type.variants.map(pickFalsy).filter(Boolean);\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n  if (type === _unionType.UnionType.Boolean) {\n    return _type.Type.False;\n  }\n\n  if (type === _type.Type.String) {\n    return _type.Type.term(\"''\", {\n      isSubtypeOf: _type.Type.String\n    });\n  }\n\n  if (type === _type.Type.Number) {\n    return _type.Type.term(0, {\n      isSubtypeOf: _type.Type.Number\n    });\n  }\n\n  if (type === _type.Type.BigInt) {\n    return _type.Type.term(\"0n\", {\n      isSubtypeOf: _type.Type.BigInt\n    });\n  }\n\n  if (type === _type.Type.Undefined || type === _type.Type.Null) {\n    return type;\n  }\n\n  if (isFalsy(type)) {\n    return type;\n  }\n}\n\nfunction pickTruthy(type) {\n  if (type instanceof _unionType.UnionType) {\n    const variants = type.variants.map(pickTruthy).filter(Boolean);\n    return _unionType.UnionType.term(null, {}, variants);\n  }\n\n  if (type === _unionType.UnionType.Boolean) {\n    return _type.Type.True;\n  }\n\n  if (!isFalsy(type)) {\n    return type;\n  }\n}\n\nfunction isFalsy(type) {\n  return getFalsy().includes(type);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _keysType = require(\"../type-graph/types/keys-type\");\n\nvar _pickType = require(\"../type-graph/types/pick-type\");\n\nvar _omitType = require(\"../type-graph/types/omit-type\");\n\nvar _softType = require(\"../type-graph/types/soft-type\");\n\nvar _classType = require(\"../type-graph/types/class-type\");\n\nvar _strictType = require(\"../type-graph/types/strict-type\");\n\nvar _typeOfType = require(\"../type-graph/types/type-of-type\");\n\nvar _throwsType = require(\"../type-graph/types/throws-type\");\n\nvar _valuesType = require(\"../type-graph/types/values-type\");\n\nvar _entriesType = require(\"../type-graph/types/entries-type\");\n\nvar _excludeType = require(\"../type-graph/types/exclude-type\");\n\nvar _partialType = require(\"../type-graph/types/partial-type\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _returnType = require(\"../type-graph/types/return-type\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _instanceOfType = require(\"../type-graph/types/instance-of-type\");\n\nvar _propertyType = require(\"../type-graph/types/property-type\");\n\nvar _intersectionType = require(\"../type-graph/types/intersection-type\");\n\nconst mixUtilityTypes = moduleScope => {\n  const typeScope = moduleScope.typeScope;\n  const utilityTypes = new Map([[\"$PropertyType\", new _propertyType.$PropertyType(_propertyType.$PropertyType.name, {\n    parent: typeScope\n  })], [\"$InstanceOf\", new _instanceOfType.$InstanceOf(_instanceOfType.$InstanceOf.name, {\n    parent: typeScope\n  })], [\"$Keys\", new _keysType.$Keys(_keysType.$Keys.name, {\n    parent: typeScope\n  })], [\"$Entries\", new _entriesType.$Entries(_entriesType.$Entries.name, {\n    parent: typeScope\n  })], [\"$Values\", new _valuesType.$Values(_valuesType.$Values.name, {\n    parent: typeScope\n  })], [\"$Partial\", new _partialType.$Partial(_partialType.$Partial.name, {\n    parent: typeScope\n  })], [\"$Pick\", new _pickType.$Pick(_pickType.$Pick.name, {\n    parent: typeScope\n  })], [\"$Omit\", new _omitType.$Omit(_omitType.$Omit.name, {\n    parent: typeScope\n  })], [\"$ReturnType\", new _returnType.$ReturnType(_returnType.$ReturnType.name, {\n    parent: typeScope\n  })], [\"$TypeOf\", new _typeOfType.$TypeOf(_typeOfType.$TypeOf.name, {\n    parent: typeScope\n  })], [\"$Intersection\", new _intersectionType.$Intersection(_intersectionType.$Intersection.name, {\n    parent: typeScope\n  })], [\"$Throws\", new _throwsType.$Throws(_throwsType.$Throws.name, {\n    parent: typeScope\n  })], [\"$Immutable\", new _immutableType.$Immutable(_immutableType.$Immutable.name, {\n    parent: typeScope\n  })], [\"$Collection\", new _collectionType.$Collection(_collectionType.$Collection.name, {\n    parent: typeScope\n  })], [\"$Soft\", new _softType.$Soft(_softType.$Soft.name, {\n    parent: typeScope\n  })], [\"$Strict\", new _strictType.$Strict(_strictType.$Strict.name, {\n    parent: typeScope\n  })], [\"$Class\", new _classType.$Class(_classType.$Class.name, {\n    parent: typeScope\n  })], [\"$Exclude\", new _excludeType.$Exclude(_excludeType.$Exclude.name, {\n    parent: typeScope\n  })]]);\n\n  for (const [name, type] of utilityTypes) {\n    typeScope.body.set(name, type);\n    type.parent = typeScope;\n  }\n};\n\nexports.default = mixUtilityTypes;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPropertyName = getPropertyName;\nexports.getVariableInfoFromDelcaration = getVariableInfoFromDelcaration;\nexports.getSuperTypeOf = getSuperTypeOf;\nexports.getVariableType = getVariableType;\nexports.addVariableToGraph = addVariableToGraph;\n\nvar _nodes = require(\"./nodes\");\n\nvar _nodes2 = _interopRequireDefault(_nodes);\n\nvar _meta = require(\"../type-graph/meta/meta\");\n\nvar _type = require(\"../type-graph/types/type\");\n\nvar _unionType = require(\"../type-graph/types/union-type\");\n\nvar _tupleType = require(\"../type-graph/types/tuple-type\");\n\nvar _objectType = require(\"../type-graph/types/object-type\");\n\nvar _functionType = require(\"../type-graph/types/function-type\");\n\nvar _variableInfo = require(\"../type-graph/variable-info\");\n\nvar _constants = require(\"../type-graph/constants\");\n\nvar _collectionType = require(\"../type-graph/types/collection-type\");\n\nvar _immutableType = require(\"../type-graph/types/immutable-type\");\n\nvar _common = require(\"./common\");\n\nvar _moduleScope = require(\"../type-graph/module-scope\");\n\nvar _typeUtils = require(\"./type-utils\");\n\nvar _scopeUtils = require(\"./scope-utils\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction getPropertyName(node) {\n  const isPrivate = node.type === _nodes2.default.CLASS_PRIVATE_METHOD || node.type === _nodes2.default.CLASS_PRIVATE_PROPERTY;\n\n  if (isPrivate) {\n    return `#${node.key.id.name}`;\n  }\n\n  if (node.kind === \"constructor\") {\n    return _constants.CONSTRUCTABLE;\n  }\n\n  return node.key.name || `${node.key.value}`;\n}\n\nfunction getVariableInfoFromDelcaration(currentNode, parentNode, typeGraph, precompute, middlecompute, postcompute) {\n  const parentScope = (0, _scopeUtils.getParentForNode)(currentNode, parentNode, typeGraph);\n  const currentTypeScope = (0, _scopeUtils.findNearestTypeScope)(parentScope, typeGraph);\n  const annotatedType = (0, _typeUtils.getTypeFromTypeAnnotation)(currentNode.id && currentNode.id.typeAnnotation, currentTypeScope, parentScope, false, null, parentNode, typeGraph, precompute, middlecompute, postcompute);\n  return new _variableInfo.VariableInfo(annotatedType, parentScope, new _meta.Meta(currentNode.loc), currentNode.kind === \"const\");\n}\n\nfunction getSuperTypeOf(type, typeScope, withUnion = false) {\n  if (type === _type.Type.True || type === _type.Type.False) {\n    return _unionType.UnionType.Boolean;\n  }\n\n  if (type instanceof _unionType.UnionType) {\n    return withUnion ? _unionType.UnionType.term(null, {}, type.variants.map(variant => getSuperTypeOf(variant, typeScope, withUnion))) : type;\n  }\n\n  if (type.isSubtypeOf == undefined || type.name === null || type instanceof _functionType.FunctionType || type instanceof _objectType.ObjectType && String(type.name)[0] !== \"{\") {\n    return type;\n  }\n\n  if (type instanceof _tupleType.TupleType) {\n    // $FlowIssue Array is always GenericType\n    return _collectionType.CollectionType.Array.root.applyGeneric([getSuperTypeOf(type.items.length === 0 ? _type.Type.Unknown : _unionType.UnionType.term(null, {}, type.items.map(a => getSuperTypeOf(a, typeScope, withUnion))), typeScope, true)]);\n  }\n\n  if (type instanceof _objectType.ObjectType) {\n    const propertyTypes = [...type.properties.entries()].map(([key, v]) => [key, v.type]);\n    const newProperties = propertyTypes.map(([key, p]) => [key, // $FlowIssue\n    Object.assign(new _variableInfo.VariableInfo(), type.properties.get(key), {\n      type: getSuperTypeOf(p, typeScope, withUnion)\n    })]);\n    return _objectType.ObjectType.term(_objectType.ObjectType.getName(newProperties), {}, newProperties);\n  }\n\n  return type.isSubtypeOf;\n}\n\nfunction getVariableType(variable, newType, typeScope, inferenced = false, freezed = false) {\n  if (variable && variable.type !== _type.Type.Unknown) {\n    return variable.type;\n  }\n\n  if (!inferenced || newType instanceof _immutableType.$AppliedImmutable || variable && variable.isConstant && (newType.constructor === _type.Type || newType.constructor === _tupleType.TupleType)) {\n    return newType;\n  }\n\n  return getSuperTypeOf(newType, typeScope);\n}\n\nfunction addVariableToGraph(currentNode, parentNode, moduleScope, precompute, middlecompute, postcompute, customName = (0, _common.getDeclarationName)(currentNode)) {\n  const variableInfo = getVariableInfoFromDelcaration(currentNode, parentNode, moduleScope, precompute, middlecompute, postcompute);\n  variableInfo.parent.body.set(customName, variableInfo);\n\n  if (moduleScope instanceof _moduleScope.PositionedModuleScope && currentNode.id != null) {\n    moduleScope.addPosition(currentNode.id, variableInfo);\n  }\n\n  return variableInfo;\n}","import{parse}from\"@babel/parser\";import{VariableInfo,createModuleScope,createGlobalScope,HegelError}from\"@hegel/core\";let module=undefined;const STANDARD_LIB_OPTIONS={plugins:[\"typescript\"]};const DEFAULT_OPTIONS={plugins:[\"bigInt\",\"classProperties\",\"numericSeparator\",\"classPrivateMethods\",\"classPrivateProperties\",[\"flow\",{all:true}]]};// eslint-disable-next-line\nconst STANDARD_AST=parse(STD_LIB_CONTENT,STANDARD_LIB_OPTIONS);export function getTypeByLocation(location){if(module===undefined){return;}const varInfoOrType=module.getVarAtPosition(location);if(varInfoOrType===undefined){return;}return varInfoOrType instanceof VariableInfo?varInfoOrType.type:varInfoOrType;}if(typeof getTypeByLocation!=='undefined'&&getTypeByLocation&&getTypeByLocation===Object(getTypeByLocation)&&Object.isExtensible(getTypeByLocation)&&!getTypeByLocation.hasOwnProperty('__filemeta')){Object.defineProperty(getTypeByLocation,'__filemeta',{configurable:true,value:{name:\"getTypeByLocation\",filename:\"src/docs/try/components/hegel.js\"}});}if(typeof getTypeByLocation!=='undefined'&&getTypeByLocation&&getTypeByLocation===Object(getTypeByLocation)&&Object.isExtensible(getTypeByLocation)&&!getTypeByLocation.hasOwnProperty('__filemeta')){Object.defineProperty(getTypeByLocation,'__filemeta',{configurable:true,value:{name:\"getTypeByLocation\",filename:\"src/docs/try/components/hegel.js\"}});}let stdLibTypeGraph;export async function mixTypeDefinitions(globalScope){if(stdLibTypeGraph===undefined){stdLibTypeGraph=await getStandardTypeDefinitions(globalScope);}const body=new Map(globalScope.body);for(const[name,variable]of stdLibTypeGraph.body.entries()){variable.parent=globalScope;body.set(name,variable);}const typesBody=new Map(globalScope.typeScope.body);for(const[name,type]of stdLibTypeGraph.typeScope.body.entries()){type.parent=globalScope.typeScope;typesBody.set(name,type);}globalScope.body=body;globalScope.typeScope.body=typesBody;}if(typeof mixTypeDefinitions!=='undefined'&&mixTypeDefinitions&&mixTypeDefinitions===Object(mixTypeDefinitions)&&Object.isExtensible(mixTypeDefinitions)&&!mixTypeDefinitions.hasOwnProperty('__filemeta')){Object.defineProperty(mixTypeDefinitions,'__filemeta',{configurable:true,value:{name:\"mixTypeDefinitions\",filename:\"src/docs/try/components/hegel.js\"}});}if(typeof mixTypeDefinitions!=='undefined'&&mixTypeDefinitions&&mixTypeDefinitions===Object(mixTypeDefinitions)&&Object.isExtensible(mixTypeDefinitions)&&!mixTypeDefinitions.hasOwnProperty('__filemeta')){Object.defineProperty(mixTypeDefinitions,'__filemeta',{configurable:true,value:{name:\"mixTypeDefinitions\",filename:\"src/docs/try/components/hegel.js\"}});}export async function getStandardTypeDefinitions(globalScope){const errors=[];const graph=await createModuleScope(STANDARD_AST,errors,()=>{},globalScope,true);if(errors.length>0){throw errors;}return graph;}if(typeof getStandardTypeDefinitions!=='undefined'&&getStandardTypeDefinitions&&getStandardTypeDefinitions===Object(getStandardTypeDefinitions)&&Object.isExtensible(getStandardTypeDefinitions)&&!getStandardTypeDefinitions.hasOwnProperty('__filemeta')){Object.defineProperty(getStandardTypeDefinitions,'__filemeta',{configurable:true,value:{name:\"getStandardTypeDefinitions\",filename:\"src/docs/try/components/hegel.js\"}});}if(typeof getStandardTypeDefinitions!=='undefined'&&getStandardTypeDefinitions&&getStandardTypeDefinitions===Object(getStandardTypeDefinitions)&&Object.isExtensible(getStandardTypeDefinitions)&&!getStandardTypeDefinitions.hasOwnProperty('__filemeta')){Object.defineProperty(getStandardTypeDefinitions,'__filemeta',{configurable:true,value:{name:\"getStandardTypeDefinitions\",filename:\"src/docs/try/components/hegel.js\"}});}export async function getDiagnostics(sourceCode){let errors=[];try{const file=parse(sourceCode,DEFAULT_OPTIONS);[[module],errors]=await createGlobalScope([file],()=>{},false,mixTypeDefinitions,true);}catch(e){const error=new HegelError(`AnalyzationError: ${e.message}`,{start:{line:0,column:0},end:{line:Number.MAX_VALUE,column:Number.MAX_VALUE}});errors=[error];}return errors.map(toTransferableObject);}if(typeof getDiagnostics!=='undefined'&&getDiagnostics&&getDiagnostics===Object(getDiagnostics)&&Object.isExtensible(getDiagnostics)&&!getDiagnostics.hasOwnProperty('__filemeta')){Object.defineProperty(getDiagnostics,'__filemeta',{configurable:true,value:{name:\"getDiagnostics\",filename:\"src/docs/try/components/hegel.js\"}});}if(typeof getDiagnostics!=='undefined'&&getDiagnostics&&getDiagnostics===Object(getDiagnostics)&&Object.isExtensible(getDiagnostics)&&!getDiagnostics.hasOwnProperty('__filemeta')){Object.defineProperty(getDiagnostics,'__filemeta',{configurable:true,value:{name:\"getDiagnostics\",filename:\"src/docs/try/components/hegel.js\"}});}function toTransferableObject(error){const loc=error.loc;return{message:error.message,source:error.source,loc:loc&&formatLoc(loc)};}function formatLoc(loc){return loc.start?{start:{line:loc.start.line,column:loc.start.column},end:{line:loc.end.line,column:loc.end.column}}:{start:{line:loc.line,column:loc.column},end:{line:loc.line,column:loc.column+1}};}\naddEventListener('message', e => {let {type,method,id,params} = e.data,f,p;if (type === 'RPC' && method) {if (f = __webpack_exports__[method]) {p = Promise.resolve().then(() => f.apply(__webpack_exports__, params));} else {p = Promise.reject('No such method');}p.then(result => {postMessage({type: 'RPC',id,result});}).catch(e => {let error = {message: e};if (e.stack) {error.message = e.message;error.stack = e.stack;error.name = e.name;}postMessage({type: 'RPC',id,error});});}});postMessage({type: 'RPC',method: 'ready'});"],"sourceRoot":""}