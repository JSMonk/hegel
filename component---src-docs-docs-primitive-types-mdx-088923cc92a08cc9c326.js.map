{"version":3,"sources":["webpack:///../src/docs/docs/primitive-types.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ocAMO,IAAMA,EAAe,Q,mNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,mBADR,mBAGA,uBACA,2JACA,sBACE,kBAAIC,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,wBADQ,SAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,wBADQ,cAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,aADQ,YAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,YADQ,WAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,YADQ,WAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,YADQ,WAGpB,kBAAIA,WAAW,MAAK,mBAAGA,WAAW,MAAS,CACvC,KAAQ,YADQ,YAItB,yHACA,iBAAQ,CACN,GAAM,sBADR,sBAGA,mEAAkD,0BAAYA,WAAW,KAAvB,QAAlD,QAA2G,0BAAYA,WAAW,KAAvB,aAA3G,yGAEA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+EAKL,uCAAsB,0BAAYA,WAAW,KAAvB,QAAtB,QAA+E,0BAAYA,WAAW,KAAvB,aAA/E,iLACA,iBAAQ,CACN,GAAM,WADR,WAGA,qDAAoC,0BAAYA,WAAW,KAAvB,WAApC,0CAAkI,0BAAYA,WAAW,KAAvB,QAAlI,QAA2L,0BAAYA,WAAW,KAAvB,SAA3L,KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mNASL,iBAAQ,CACN,GAAM,UADR,UAGA,2VAA0U,0BAAYA,WAAW,KAAvB,MAA1U,8FAC2D,0BAAYA,WAAW,KAAvB,UAD3D,kGAEA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uKAQL,iBAAQ,CACN,GAAM,UADR,UAGA,qBAAG,0BAAYA,WAAW,KAAvB,UAAH,kFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gDAIL,qBAAG,sBAAQA,WAAW,KAAnB,WAAH,KAAoD,0BAAYA,WAAW,KAAvB,UAApD,qCAA4I,0BAAYA,WAAW,KAAvB,UAA5I,iNACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mWAcL,iBAAQ,CACN,GAAM,UADR,UAGA,2YACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gMAOL,iHACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uBAIL,wJACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,wXAmBL,qFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uMAaL,iBAAQ,CACN,GAAM,UADR,UAGA,8IAA6H,0BAAYA,WAAW,KAAvB,UAA7H,sDAAsO,0BAAYA,WAAW,KAAvB,UAAtO,kDACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+CAIL,qBAAG,sBAAQA,WAAW,KAAnB,WAAH,wFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,2F,iNASTJ,EAAWK,gBAAiB","file":"component---src-docs-docs-primitive-types-mdx-088923cc92a08cc9c326.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"primitive-types\"\n    }}>{`Primitive Types`}</h1>\n    <hr></hr>\n    <p>{`Imagine type as a Set of different values. Some of them are finite and some are not. In nowadays JavaScript has 7 primitive types:`}</p>\n    <ul>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#null-and-undefined\"\n        }}>{`Null`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#null-and-undefined\"\n        }}>{`Undefined`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#boolean\"\n        }}>{`Boolean`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#number\"\n        }}>{`Number`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#number\"\n        }}>{`BigInt`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#string\"\n        }}>{`String`}</a></li>\n      <li parentName=\"ul\"><a parentName=\"li\" {...{\n          \"href\": \"#symbol\"\n        }}>{`Symbol`}</a></li>\n    </ul>\n    <p>{`Hegel has not only the same types, but also adds several new types. Let's discover each of them:`}</p>\n    <h2 {...{\n      \"id\": \"null-and-undefined\"\n    }}>{`Null and Undefined`}</h2>\n    <p>{`The most primitive types in JavaScript are `}<inlineCode parentName=\"p\">{`null`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{`, because each of them contains only one value.\nYou can define variable with this datatype in Hegel:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let emptyValue: null = null;\nlet undefinedValue: undefined = undefined;\n`}</code></pre>\n    <p>{`As you can see `}<inlineCode parentName=\"p\">{`null`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{` types have the same name as their literals, but some datatypes do not. In Hegel you can annotate your variables/object properties with both literal value and datatype name.`}</p>\n    <h2 {...{\n      \"id\": \"boolean\"\n    }}>{`Boolean`}</h2>\n    <p>{`The second primitive type is `}<inlineCode parentName=\"p\">{`boolean`}</inlineCode>{`, because it contains only two values: `}<inlineCode parentName=\"p\">{`true`}</inlineCode>{` and `}<inlineCode parentName=\"p\">{`false`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Using literal as a datatype\nlet canIContain4Values: false = false;\nlet canIUseLiteralAsTypeAnnotation: true = true;\n\n// Using expressions\nlet canIUseWithExpressions: boolean = !canIContain4Values;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"number\"\n    }}>{`Number`}</h2>\n    <p>{`JavaScript Number datatype presents any signed 64-bit number. JavaScript has not different datatypes for floating or unsigned numbers. -1, 2.7182 and 0xff will have the same datatype - number. Also, JavaScript has \"special\" identifiers: Infinity and NaN which also included in number datatype (And in JavaScript is existed `}<inlineCode parentName=\"p\">{`-0`}</inlineCode>{`, but this is a long story).\nIn Hegel you can annotate your variable/object property with `}<inlineCode parentName=\"p\">{`number`}</inlineCode>{` datatype name or with literal in different format (hexademical, binary, exponential and etc.)`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let decimal: 6 = 6;\nlet hex: 0xf00d = 0xf00d;\nlet binary: 0b1010 = 0b1010;\nlet octal: 0o744 = 0o744;\nlet anyNumber: number = decimal + hex + binary + octal;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"bigint\"\n    }}>{`BigInt`}</h2>\n    <p><inlineCode parentName=\"p\">{`BigInt`}</inlineCode>{` was added in ES2019 and presents any integer number without bits limitations.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`let reallyBigNumber: bigint = 2n ** 255n;\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Warning`}</strong>{`: `}<inlineCode parentName=\"p\">{`BigInt`}</inlineCode>{` is not subtype or super type for `}<inlineCode parentName=\"p\">{`Number`}</inlineCode>{` data type. Hegel will show you an error if you try to use bigint as number or number as bigint. Also, in JavaScript you can't mix number and bigint in math operators, so, Hegel will show you an error too.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Error: Type \"bigint\" is incompatible with type \"number\"\nconst usageBigIntAsNumber: number = 4n + 2n;\n\n// Error: Type \"number\" is incompatible with type \"bigint\"\nconst usageNumberAsBigInt: bigint = 4 + 2;\n\n// Error: Type \"4n\" is incompatible with type \"number\"\n4 * 4n;\n\n// Error: Type \"255\" is incompatible with type \"bigint\"\n2n ** 255;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"string\"\n    }}>{`String`}</h2>\n    <p>{`Unlike String in other programming languages, JavaScript's String has a value (not reference) behavior. So, any characters set wrapped in single quote ('), double quote (\") or backtick/backquote (\\`) will be a valid JavaScript string literal. In Hegel you can annotate variable/object property with both literal or string datatype name, the same as with other datatypes.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const firstName: \"Robert\" = \"Robert\";\nconst lastName: \"Paulson\" = \"Paulson\";\nconst fullName: string = firstName + \" \" + lastName;\nconst sentence: string = \\`His name is \\${fullName}.\\`;\n`}</code></pre>\n    <p>{`JavaScript implicitly converts other types of values into strings by concatenating them.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-javascript\"\n      }}>{`44 + \"6\"; // 446\n`}</code></pre>\n    <p>{`Hegel implements a strong type system, so it will accept only strings when concatenating them or when template literal is used.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const world = {\n  toString() {\n    return \"World\";\n  },\n};\n\n\"Hello \" + \"World\"; // ðŸ‘Œ!\n\n// Error: Type \"42\" is incompatible with type \"string\"\n\"Hello \" + 42;\n\n// Error: Type \"{ toString: () => string }\" is incompatible with type \"string\"\n\"Hello \" + world;\n\n// Error: Type \"{ toString: () => string }\" is incompatible with type \"string\"\n\\`Hello, \\${world}\\`;\n`}</code></pre>\n    <p>{`To prevent error you need explicity convert value to string:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const world = {\n  toString() {\n    return \"World\";\n  },\n};\n\n\"Hello \" + \"World\"; // ðŸ‘Œ!\n\"Hello \" + String(42); // ðŸ‘Œ!\n\"Hello \" + String(world); // ðŸ‘Œ!\n\\`Hello, \\${String(world)}\\`; // ðŸ‘Œ!\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"symbol\"\n    }}>{`Symbol`}</h2>\n    <p>{`Symbol is another \"new\" datatype which was included in language starting from ECMAScript 2015. Symbols are created by `}<inlineCode parentName=\"p\">{`Symbol`}</inlineCode>{` function invocation in JavaScript. Hegel provides `}<inlineCode parentName=\"p\">{`symbol`}</inlineCode>{` datatype that can be used as type annotation.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const unique: symbol = Symbol(\"unique\");\n`}</code></pre>\n    <p><strong parentName=\"p\">{`Warning`}</strong>{`: Symbol datatype has not any literal, so you can not use symbol values as datatype.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Error: Unexpected token\nconst unique: Symbol(\"unique\") = Symbol(\"unique\");\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}