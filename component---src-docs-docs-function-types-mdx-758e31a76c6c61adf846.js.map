{"version":3,"sources":["webpack:///../src/docs/docs/function-types.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ocAMO,IAAMA,EAAe,Q,kNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,kBADR,kBAGA,uBACA,iIACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,8nBA4BL,iBAAQ,CACN,GAAM,oBADR,oBAGA,6LACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,wHAOL,uDAAsC,0BAAYA,WAAW,KAAvB,UAAtC,2HACA,iBAAQ,CACN,GAAM,iCADR,iCAGA,uFAAsE,mBAAGA,WAAW,KAAQ,CACxF,KAAQ,yBAD0D,kBAAtE,6FAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mNAUL,yGACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,yEAML,kDAAiC,0BAAYA,WAAW,KAAvB,QAAjC,qEAAuJ,mBAAGA,WAAW,KAAQ,CACzK,KAAQ,oHAD2I,oBAAvJ,2HAGmH,0BAAYA,WAAW,KAAvB,sBAHnH,6BAG+M,0BAAYA,WAAW,KAAvB,UAH/M,YAIA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uMAUL,iBAAQ,CACN,GAAM,iBADR,iBAGA,yNACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,8CAML,gKAA+I,mBAAGA,WAAW,KAAQ,CACjK,KAAQ,sBACP,0BAAYA,WAAW,KAAvB,SAF0I,SAA/I,OAE2E,mBAAGA,WAAW,KAAQ,CAC7F,KAAQ,sBAD+D,eAG3E,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gQAaL,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,ufAiBL,iBAAQ,CACN,GAAM,oBADR,kBAGA,+IAA8H,0BAAYA,WAAW,KAAvB,gCAA9H,kBACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,ktBAwBL,8BACE,iBAAGA,WAAW,cAAd,mRACoL,mBAAGA,WAAW,KAAQ,CACtM,KAAQ,mFADwK,iBADpL,qBAGgD,mBAAGA,WAAW,KAAQ,CAClE,KAAQ,mFADoC,aAHhD,gBAOF,0EACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,g6BA+BL,iBAAQ,CACN,GAAM,iBACL,0BAAYA,WAAW,MAAvB,YAFH,SAGA,6CAA4B,0BAAYA,WAAW,KAAvB,YAA5B,+DACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gX,gNAsBTJ,EAAWK,gBAAiB","file":"component---src-docs-docs-function-types-mdx-758e31a76c6c61adf846.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"function-types\"\n    }}>{`Function Types`}</h1>\n    <hr></hr>\n    <p>{`Functions have two places where you can annotate types: arguments (input) and the return value (output).`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Function Declaration\nfunction sum1(a: number, b: number): number {\n  return a + b;\n}\n\n// Function Expression\nconst sum2 = function (a: number, b: number): number {\n  return a + b;\n};\n\n// Arrow Function Expression\nconst sum3 = (a: number, b: number): number => a + b;\n\nlet result = sum1(1, 2); // ðŸ‘Œ!\nresult = sum2(1, 2); // ðŸ‘Œ!\nresult = sum3(1, 2); // ðŸ‘Œ!\n\n// Error: Type \"false\" is incompatible with type \"number\"\nresult = sum1(false, \"\");\n\n// Error: Type \"''\" is incompatible with type \"number\"\nresult = sum2(\"\", 4);\n\n// Error: Type \"'1'\" is incompatible with type \"number\"\nresult = sum3(\"1\", \"2\");\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"function-returns\"\n    }}>{`Function Returns`}</h2>\n    <p>{`As you understand, arguments types will be checked when you try to apply arguments to a function, but return type will be checked when you implement function logic.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function awesome(name: string): string {\n  // Error: Type \"2\" is incompatible with type \"string\"\n  return 2;\n}\n`}</code></pre>\n    <p>{`Return types ensure that every `}<inlineCode parentName=\"p\">{`return`}</inlineCode>{` will be called with the same type. This prevents you from accidentally not returning a value under certain conditions.`}</p>\n    <h2 {...{\n      \"id\": \"optional-and-default-argument\"\n    }}>{`Optional and Default Argument`}</h2>\n    <p>{`All arguments are required by default, but as was mentioned in `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/optional-types\"\n      }}>{`Optional Types`}</a>{`, if you annotate some argument as optional type then this argument will become optional:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function awesome(name: ?string) {\n  const actualName = name === undefined ? \"you\" : name;\n  return \\`Awesome, \\${actualName}.\\`;\n}\n\nlet result = awesome(); // ðŸ‘Œ!\nresult = awesome(\"JavaScript\"); // ðŸ‘Œ!\n`}</code></pre>\n    <p>{`In JavaScript, we can also set a default value for optional arguments like this:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function awesome(name = \"you\") {\n  return \\`Awesome, \\${name}.\\`;\n}\n`}</code></pre>\n    <p>{`So, which type should the `}<inlineCode parentName=\"p\">{`name`}</inlineCode>{` argument be annotated with? You can see this demonstrated in the `}<a parentName=\"p\" {...{\n        \"href\": \"/try#GYVwdgxgLglg9mABAQwO4FMDOcC26AUYyeAXIplAE4xgDmiAvIgEQCecIzAlIgN4BQiRJXRQQlJAAMAghmx4ANIgAkvIngC+AOkkBufhqA\"\n      }}>{`Hegel Playground`}</a>{`.\nIf you hover over the function name and then on the argument name, you will see some magic; the function argument is `}<inlineCode parentName=\"p\">{`string | undefined`}</inlineCode>{` outside the function but `}<inlineCode parentName=\"p\">{`string`}</inlineCode>{` inside.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// awesome: (string | undefined) => string\nfunction awesome(name: string = \"you\") {\n  return \\`Awesome, \\${name}.\\`;\n}\n\nlet result = awesome(); // ðŸ‘Œ!\nresult = awesome(\"JavaScript\"); // ðŸ‘Œ!\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"rest-argument\"\n    }}>{`Rest Argument`}</h2>\n    <p>{`Sometimes, you don't know how many arguments will be applied to the function. JavaScript supports rest arguments. The rest operator '...' groups all applied arguments in an array of arguments.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function sum(...numbers) {\n  // ...\n}\n`}</code></pre>\n    <p>{`In Hegel you can annotate this argument the same as other arguments, but with a constraint. The type of this rest argument should be an `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/array-types\"\n      }}><inlineCode parentName=\"a\">{`Array`}</inlineCode>{` type`}</a>{` or `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/tuple-types\"\n      }}>{`tuple type`}</a></p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function sum(...numbers: Array<number>) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\nlet result = sum(); // ðŸ‘Œ!\nresult = sum(1); // ðŸ‘Œ!\nresult = sum(1, 2); // ðŸ‘Œ!\nresult = sum(1, 2, 42); // ðŸ‘Œ!\nresult = sum(1, 2, 42, 14); // ðŸ‘Œ!\n// ...\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function sum(\n  ...numbers: [number] | [number, number] | [number, number, number]\n) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\n// Error: Type \"[]\" is incompatible with type \"...[number, number, number] | [number, number] | [number]\"\nlet result = sum();\nresult = sum(1); // ðŸ‘Œ!\nresult = sum(1, 2); // ðŸ‘Œ!\nresult = sum(1, 2, 3); // ðŸ‘Œ!\n\n// Error Type \"[1, 2, 3, 4]\" is incompatible with type \"...[number, number, number] | [number, number] | [number]\"\nresult = sum(1, 2, 3, 4);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"function-types-1\"\n    }}>{`Function Types`}</h2>\n    <p>{`Sometimes, you need to annotate arguments or return types as a function. Hegel has syntax for function type annotation `}<inlineCode parentName=\"p\">{`(type1, type2) => returnType`}</inlineCode>{`. For example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function twice(fn: (number) => number, arg: number) {\n  return fn(fn(arg));\n}\n\nlet result: number = 0;\n\nresult = twice((a: number): number => a + 4, 4); // ðŸ‘Œ!\nresult = twice(\n  // ðŸ‘Œ!\n  (a: number | string): number => (typeof a === \"string\" ? parseInt(a) : a) + 4,\n  4\n);\n\n// Error: Type \"(string) => number\" is incompatible with type \"(number) => number\"\nresult = twice((a: string): number => parseInt(a), 4);\n\n// Error: Type \"(number) => string\" is incompatible with type \"(number) => number\"\nresult = twice((a: number): string => String(a), 4);\n\n// Error: Type \"(number) => number | string\" is incompatible with type \"(number) => number\"\nresult = twice((a: number): number | string => a, 4);\n`}</code></pre>\n    <blockquote>\n      <p parentName=\"blockquote\">{`If you play with the previous example you will see the next rule of the function type:\nYou can assign one function to another only if the actual argument types are wider than declared and the return type is more specific than declared. This rule sounds like: function is `}<a parentName=\"p\" {...{\n          \"href\": \"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\"\n        }}>{`contravariant`}</a>{` by arguments and `}<a parentName=\"p\" {...{\n          \"href\": \"https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)\"\n        }}>{`covariant`}</a>{` by return.`}</p>\n    </blockquote>\n    <p>{`A more classical and simple example of this rule:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`class Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name;\n  }\n}\nclass Dog extends Animal {}\nclass Corgi extends Dog {}\n\nfunction presentMyDog(goodBoy: Dog, dogPresenter: (Dog) => Dog): string {\n  const dog = dogPresenter(goodBoy);\n  return \\`\\${dog.name}, my \\${dog.name}, i will give you to noone.\\`;\n}\n\nconst nickolay = new Corgi(\"Nickolay\");\n\nlet result = \"\";\n\nresult = presentMyDog(nickolay, (goodBoy: Dog): Dog => goodBoy); // ðŸ‘Œ!\nresult = presentMyDog(nickolay, (goodBoy: Animal): Dog => nickolay); // ðŸ‘Œ!\n\n// Error: Type \"(Corgi) => Dog\" is incompatible with type \"(Dog) => Dog\"\nresult = presentMyDog(nickolay, (goodBoy: Corgi): Dog => nickolay);\n\nresult = presentMyDog(nickolay, (goodBoy: Dog): Corgi => nickolay); // ðŸ‘Œ!\n\n// Error: Type \"(Dog) => Animal\" is incompatible with type \"(Dog) => Dog\"\nresult = presentMyDog(nickolay, (goodBoy: Dog): Animal => nickolay);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"function-type\"\n    }}><inlineCode parentName=\"h2\">{`Function`}</inlineCode>{` type`}</h2>\n    <p>{`Also, Hegel supports `}<inlineCode parentName=\"p\">{`Function`}</inlineCode>{` type which represents any possible function in JavaScript:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function argsLength(fn: Function) {\n  return fn.length;\n}\n\nlet length = 0;\n\nlength = argsLength(() => 2);\nlength = argsLength((a: number) => a);\nlength = argsLength(parseFloat);\n\n// Error: Type \"2\" is incompatible with type \"Function\"\nlength = argsLength(2);\n\n// Error: Type \"[]\" is incompatible with type \"Function\"\nlength = argsLength([]);\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}