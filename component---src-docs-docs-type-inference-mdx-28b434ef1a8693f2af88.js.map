{"version":3,"sources":["webpack:///../src/docs/docs/type-inference.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ocAMO,IAAMA,EAAe,Q,kNAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,kBADR,kBAGA,uBACA,wFACA,qIACA,uBAAK,sBAAMC,WAAW,OAAU,CAC5B,UAAa,wBADZ,kGAKL,yFACA,iBAAQ,CACN,GAAM,2BADR,2BAGA,qEACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,ySAyBL,oIACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,gUAWL,iBAAQ,CACN,GAAM,mDADR,mDAGA,0JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0NAYL,iBAAQ,CACN,GAAM,8CADR,8CAGA,uMACA,iBAAQ,CACN,GAAM,gBADR,gBAGA,0HAAyG,0BAAYA,WAAW,KAAvB,aAAzG,2BAA0L,0BAAYA,WAAW,KAAvB,sBAA1L,yBACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,oMAQL,iBAAQ,CACN,GAAM,4BADR,4BAGA,0JACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kOAYL,iBAAQ,CACN,GAAM,aADR,aAGA,oIACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,wHAOL,2GACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qFAOL,+KACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qVAcL,wMACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,8jBA0BL,iBAAQ,CACN,GAAM,6BADR,6BAGA,oDAAmC,mBAAGA,WAAW,KAAQ,CACrD,KAAQ,iDADuB,WAAnC,+NAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,ydAeL,6GACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0SAiBL,iBAAQ,CACN,GAAM,+CADR,+CAGA,kHACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,oP,gNAkBTJ,EAAWK,gBAAiB","file":"component---src-docs-docs-type-inference-mdx-28b434ef1a8693f2af88.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"type-inference\"\n    }}>{`Type Inference`}</h1>\n    <hr></hr>\n    <p>{`One of the main features of Hegel is high-level type inference.`}</p>\n    <p>{`Type Inference is an ability of analyzer to define valid type for variable/function without type annotation.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"isItNumber\" is \"number\" even if you will not annotate it.\nlet isItNumber = 42;\n`}</code></pre>\n    <p>{`There are many places where Hegel can infer type instead of you.`}</p>\n    <h2 {...{\n      \"id\": \"variable-type-inference\"\n    }}>{`Variable type Inference`}</h2>\n    <p>{`Hegel can infer any JavaScript literal type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`/*\nType of \"a\" variable is \"{\n    1: number,\n    2: bigint,\n    3: string,\n    4: boolean,\n    5: symbol,\n    6: null,\n    7: undefined,\n    8: RegExp\n}\"\n*/\nconst a = {\n  1: 1,\n  2: 2n,\n  3: \"3\",\n  4: true,\n  5: Symbol(\"for\"),\n  6: null,\n  7: undefined,\n  8: /da/gi,\n};\n`}</code></pre>\n    <p>{`Also, Hegel can inference variable type if variable value is a result of functionr or operator application.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"sum\" variable is \"bigint\"\nconst sum = 2n + 44n;\n\n// Type of \"type\" variable is \"'string' | 'boolean' | 'number' | 'function' | 'object' | 'undefined' | 'symbol' | 'bigint'\"\nconst type = typeof isNaN;\n\n// Type of \"formated\" variable is \"string\"\nconst formated = sum.toLocaleString();\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"inference-of-generic-function-invocation-result\"\n    }}>{`Inference of generic function invocation result`}</h2>\n    <p>{`One more case for inference algorythm is function invocation. If you call generic function you may not apply type argument to it.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function first<T>(arr: Array<T>): T | undefined {\n    return arr[0];\n}\n\n// Type of \"arr\" variable is Array<number>\nlet arr = [1, 2];\n\n// Type of \"f\" variable is \"number | undefined\"\nconst f = first(arr);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"inference-of-function-arguments-and-return\"\n    }}>{`Inference of function arguments and return`}</h2>\n    <p>{`Also, you able to skip function arguments types and return type annotations and Hegel will try to infer this types. Lets see at few examples to understand rules of inference.`}</p>\n    <h3 {...{\n      \"id\": \"empty-return\"\n    }}>{`Empty return`}</h3>\n    <p>{`If you defined function without return statement inside then return type of this function will be `}<inlineCode parentName=\"p\">{`undefined`}</inlineCode>{` for sync functions and `}<inlineCode parentName=\"p\">{`Promise<undefined>`}</inlineCode>{` for async functions.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"syncNothing\" function is \"() => undefined\"\nfunction syncNothing() {}\n\n// Type of \"asyncNothing\" function is \"async () => Promise<undefined>\"\nasync function asyncNothing() {}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"existed-return-statement\"\n    }}>{`Existed return statement`}</h3>\n    <p>{`If you defined function with return statement inside then return type of this function will be type of return statement argument.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"getNumber\" function is \"() => number\"\nfunction getNumber() {\n    return 42;\n}\n\n// Type of \"getNumberAsync\" function is \"async () => Promise<number>\"\nasync function getNumberAsync() {\n    return 42;\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"arguments\"\n    }}>{`Arguments`}</h3>\n    <p>{`First of all, Hegel defines your argument as type variable and convert your function into generic function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"provideEverything\" function is \"<_a>(_a) => undefined\"\nfunction provideEverything(everything) {\n\n}\n`}</code></pre>\n    <p>{`This algorythm gives an ability to inference full generic functions like identity.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"id\" function is \"<_a>(_a) => _a\"\nfunction id(x) {\n  return x;\n}\n`}</code></pre>\n    <p>{`If your argument is used as argument of an operator or function then this argument type will become the same as argument at used operator or function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Inference by operator usage\n// Type of \"greatings\" function is \"(string) => string\"\nfunction greatings(name) {\n    return \"Hello, \" + name + \"!\";\n}\n\n// Inference by function usage\n// Type of \"welcome\" function is \"(string) => string\"\nfunction welcome(name) {\n    return greatings(name) + \"Nice to see you at this page\";\n}\n`}</code></pre>\n    <p>{`If the argument of operator or function is same type as variable then argument type will not be changed, but will be added a constraint of this operator or function argument. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"add\" function is \"<T: bigint | number | string>(T, T) => T\"\nfunction add(a, b) {\n    return a + b;\n}\n\n// Type of \"prop\" function is \"<_a: Object, _b: $Keys<_a>>(_a, _b) => $PropertyType<_a, _b>\"\nfunction prop(a, b) {\n    return a[b];\n}\n\n// Type of \"length\" function is \"<_a: { length: _a0, ... }, _a0>(_a) => _a0\"\nfunction length(a) {\n    return a.length;\n}\n\n// Type of \"mul\" function is \"<T: bigint | number | string>(T, number) => T\"\nfunction mul(a, b) {\n    while(b > 0) {\n        a = add(a, a);\n        b--;\n    }\n    return a;\n}\n`}</code></pre>\n    <h3 {...{\n      \"id\": \"function-throws-inference\"\n    }}>{`Function throws inference`}</h3>\n    <p>{`As was mentioned, Hegel has `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/magic-types#throwsreturntype-errortype\"\n      }}>{`$Throws`}</a>{` magic type, which gives an ability to annotate type of Error which can be thrown by a function. But this type can be inferenced too, by analyzing of which function you use and which type you throw inside your function.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`// Type of \"assertType\" function is \n// \"(unknown, 'bigint' | 'boolean' | 'function' | 'number' | 'object' | 'string' | 'symbol' | 'undefined') => undefined throws TypeError\"\nfunction assertType(arg, type) {\n    if (typeof arg !== type) {\n        throw new TypeError(\"Wrong argument type\");\n    }\n}\n\n// Type of \"validateNumber\" function is \"(unknown) => undefined throws TypeError\"\nfunction validateNumber(arg) {\n  assertType(arg, \"number\");\n}\n`}</code></pre>\n    <p>{`If you provide try-catch statement for the \"validateNumber\" - throws will be removed`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function assertType(arg, type) {\n    if (typeof arg !== type) {\n        throw new TypeError(\"Wrong argument type\");\n    }\n}\n\n// Type of \"validateNumber\" function is \"(unknown) => undefined\"\nfunction validateNumber(arg) {\n  try {\n    assertType(arg, \"number\");\n  } catch {\n\n  }\n}\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"error-type-inference-inside-catch-statement\"\n    }}>{`Error type inference inside catch statement`}</h2>\n    <p>{`As result of previous inference Hegel can inference the argument type of catch statement.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`function assertType(arg, type) {\n    if (typeof arg !== type) {\n        throw new TypeError(\"Wrong argument type\");\n    }\n}\n\ntry {\n  assertType(4, \"string\");\n\n// Type of \"e\" variable is \"TypeError | unknown\"\n} catch(e) {}\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}