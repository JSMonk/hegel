{"version":3,"sources":["webpack:///../src/docs/docs/tuple-types.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"ocAMO,IAAMA,EAAe,Q,+MAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,eADR,eAGA,uBACA,oCAAmB,mBAAGC,WAAW,KAAQ,CACrC,KAAQ,0BADO,mBAAnB,QAEqC,mBAAGA,WAAW,KAAQ,CACvD,KAAQ,0BADyB,gBAFrC,iOAI2P,0BAAYA,WAAW,KAAvB,yBAJ3P,KAKA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+CAIL,iBAAQ,CACN,GAAM,8BADR,8BAGA,+BAAc,mBAAGA,WAAW,KAAQ,CAChC,KAAQ,sBADE,eAAd,wJAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qPAaL,qCAAoB,mBAAGA,WAAW,KAAQ,CACtC,KAAQ,sBADQ,eAApB,oHAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,6KAUL,iBAAQ,CACN,GAAM,8BADR,8BAGA,uGAAsF,mBAAGA,WAAW,KAAQ,CACxG,KAAQ,sBAD0E,eAAtF,yGAEkI,mBAAGA,WAAW,KAAQ,CACpJ,KAAQ,8BADsH,6BAFlI,8BAKA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,sQASL,iBAAQ,CACN,GAAM,aADR,aAGA,oCAAmB,mBAAGA,WAAW,KAAQ,CACrC,KAAQ,sBADO,eAAnB,gJAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,geAaL,iEACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,0K,6MAWTJ,EAAWK,gBAAiB","file":"component---src-docs-docs-tuple-types-mdx-56994c871120201c0a8d.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/runner/work/hegel/hegel/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"tuple-types\"\n    }}>{`Tuple Types`}</h1>\n    <hr></hr>\n    <p>{`The same as `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/primitive-types\"\n      }}>{`Primitive Types`}</a>{` and `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/primitive-types\"\n      }}>{`Object Types`}</a>{`, Hegel provides support for usage array literal as type, and this array literal types called Tuples. Tuple types allow you to define an array with a fixed number of elements with known types. The syntax fo tuple types is `}<inlineCode parentName=\"p\">{`[type1, type2, type3]`}</inlineCode>{`.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const tuple: [string, number] = [\"\", 0];\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"getting-element-from-tuple\"\n    }}>{`Getting element from Tuple`}</h2>\n    <p>{`Unlike `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/array-types\"\n      }}>{`Array Types`}</a>{` Tuple will return strict type which is placed at position in tuple type definition and will show an error, if you try to access out of tuple range.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const tuple: [string, number] = [\"\", 0];\n\n// first type is \"string\"\nconst first = tuple[0];\n\n// second type is \"number\"\nconst second = tuple[1];\n\n// Error: Property \"2\" does not exist in \"[string, number]\"\nconst third = tuple[2];\n`}</code></pre>\n    <p>{`Also, unlike `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/array-types\"\n      }}>{`Array Types`}</a>{`, Tuples have strict defined type for length and as result they cannot mutate \"length\" property in a tuple type.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const tuple: [string, number] = [\"\", 0];\n\n// length type is \"2\"\nconst length = tuple.length;\n\n// Error: Type \"3\" is incompatible with type \"2\"\ntuple.length = 3;\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"tuple-methods-and-mutation\"\n    }}>{`Tuple methods and mutation`}</h2>\n    <p>{`As you may understand, Hegel provides the same methods for Tuples Types as for `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/array-types\"\n      }}>{`Array Types`}</a>{`, but with one exception. If you try to use any of methods from Array which will mutate source tuple (`}<a parentName=\"p\" {...{\n        \"href\": \"https://doesitmutate.xyz/\"\n      }}>{`https://doesitmutate.xyz/`}</a>{`) you will have an error. `}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const numbers: [number, number, number] = [1, 2, 3];\nconst plusOne = numbers.map(a => a + 1);\nconst lessThan3 = numbers.filter(a => a < 3);\n\n// Error: Property \"reverse\" does not exist in \"[number, number, number]\"\nconst reversed = numbers.reverse();\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"subtyping\"\n    }}>{`Subtyping`}</h2>\n    <p>{`The same as `}<a parentName=\"p\" {...{\n        \"href\": \"/docs/array-types\"\n      }}>{`Array Types`}</a>{` Tuple types have invariant nature, so you can't assign to one tuple another with wider element type or with greater or less elements count.`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const source: [number, number] = [0, 0];\n\n// Error: Type \"[number, number]\" is incompatible with type \"[number | string, number]\"\nconst widerByElementType: [number | string, number] = source;\n\n// Error: Type \"[number, number]\" is incompatible with type \"[number, number, number]\"\nconst widerByElementsCount: [number, number, number] = source;\n\n// Error: Type \"[number, number]\" is incompatible with type \"[number]\"\nconst narrowerByElementsCount: [number] = source;\n`}</code></pre>\n    <p>{`And also tuples donâ€™t match array types:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const source: [number, number] = [0, 0];\n\n// Error: Type \"[number, number]\" is incompatible with type \"Array<number>\"\nconst array: Array<number> = source;\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}